

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>draco.analysis.transform &mdash; draco 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=9edc463e" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            draco
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev.html">Development Guidelines</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">draco</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">draco.analysis.transform</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for draco.analysis.transform</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Miscellaneous transformations to do on data.</span>

<span class="sd">This includes grouping frequencies and products to performing the m-mode transform.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">overload</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.linalg</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">la</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">caput</span><span class="w"> </span><span class="kn">import</span> <span class="n">config</span><span class="p">,</span> <span class="n">mpiarray</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">caput.algorithms</span><span class="w"> </span><span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">invert_no_zero</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">caput.containers</span><span class="w"> </span><span class="kn">import</span> <span class="n">ContainerPrototype</span><span class="p">,</span> <span class="n">copy_datasets_filter</span><span class="p">,</span> <span class="n">empty_like</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">caput.pipeline</span><span class="w"> </span><span class="kn">import</span> <span class="n">exceptions</span><span class="p">,</span> <span class="n">tasklib</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy.lib.recfunctions</span><span class="w"> </span><span class="kn">import</span> <span class="n">structured_to_unstructured</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">..core</span><span class="w"> </span><span class="kn">import</span> <span class="n">containers</span><span class="p">,</span> <span class="n">io</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..util</span><span class="w"> </span><span class="kn">import</span> <span class="n">regrid</span><span class="p">,</span> <span class="n">tools</span>


<div class="viewcode-block" id="FrequencyRebin">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.FrequencyRebin">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FrequencyRebin</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Rebin neighbouring frequency channels.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    channel_bin : int</span>
<span class="sd">        Number of channels to in together.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">channel_bin</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="FrequencyRebin.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.FrequencyRebin.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Take the input dataset and rebin the frequencies.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ss : containers.SiderealStream or containers.TimeStream</span>
<span class="sd">            Input data to rebin. Can also be an `andata.CorrData` instance,</span>
<span class="sd">            however the output will be a `containers.TimeStream` instance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sb : containers.SiderealStream or containers.TimeStream</span>
<span class="sd">            Rebinned data. Type should match the input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;freq&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ss</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Data does not have a frequency axis.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_bin</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Binning must exactly divide the number of channels.&quot;</span><span class="p">)</span>

        <span class="c1"># Get all frequencies onto same node</span>
        <span class="n">ss</span><span class="o">.</span><span class="n">redistribute</span><span class="p">([</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;ra&quot;</span><span class="p">])</span>

        <span class="c1"># Calculate the new frequency centres and widths</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">][</span><span class="s2">&quot;centre&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_bin</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">fw</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">][</span><span class="s2">&quot;width&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_bin</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">freq_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">fc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ss</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">freq_map</span><span class="p">[</span><span class="s2">&quot;centre&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fc</span>
        <span class="n">freq_map</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fw</span>

        <span class="c1"># Create new container for rebinned stream</span>
        <span class="n">sb</span> <span class="o">=</span> <span class="n">empty_like</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq_map</span><span class="p">)</span>

        <span class="c1"># Get all frequencies onto same node</span>
        <span class="n">sb</span><span class="o">.</span><span class="n">redistribute</span><span class="p">([</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;ra&quot;</span><span class="p">])</span>

        <span class="c1"># Rebin the arrays, do this with a loop to save memory</span>
        <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">freq</span><span class="p">)):</span>
            <span class="c1"># Calculate rebinned index</span>
            <span class="n">ri</span> <span class="o">=</span> <span class="n">fi</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_bin</span>

            <span class="n">sb</span><span class="o">.</span><span class="n">vis</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ss</span><span class="o">.</span><span class="n">vis</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span> <span class="o">*</span> <span class="n">ss</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span>

            <span class="k">if</span> <span class="s2">&quot;gain&quot;</span> <span class="ow">in</span> <span class="n">ss</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
                <span class="n">sb</span><span class="o">.</span><span class="n">gain</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="n">ss</span><span class="o">.</span><span class="n">gain</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_bin</span>
                <span class="p">)</span>  <span class="c1"># Don&#39;t do weighted average for the moment</span>

            <span class="n">sb</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ss</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span>

            <span class="c1"># If we are on the final sub-channel then divide the arrays through</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">fi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_bin</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sb</span><span class="o">.</span><span class="n">vis</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="o">*=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">sb</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="n">ri</span><span class="p">])</span>

        <span class="n">sb</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sb</span></div>
</div>



<div class="viewcode-block" id="TelescopeStreamMixIn">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.TelescopeStreamMixIn">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">TelescopeStreamMixIn</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A mixin providing functionality for creating telescope-defined sidereal streams.</span>

<span class="sd">    This mixin is designed to be used with pipeline tasks that require certain</span>
<span class="sd">    index maps in order to create SiderealStream containers compatible with the</span>
<span class="sd">    baseline configuration provided in a telescope instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TelescopeStreamMixIn.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.TelescopeStreamMixIn.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tel</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set up the telescope instance and precompute index maps.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tel : TransitTelescope</span>
<span class="sd">            The telescope instance to use to compute the prod, stack,</span>
<span class="sd">            and reverse_stack index maps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">get_telescope</span><span class="p">(</span><span class="n">tel</span><span class="p">)</span>

        <span class="c1"># Precalculate the stack properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bt_stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">(</span>
                    <span class="p">(</span><span class="n">tools</span><span class="o">.</span><span class="n">cmap</span><span class="p">(</span><span class="n">upp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">upp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">nfeed</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">upp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">upp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">else</span> <span class="p">(</span><span class="n">tools</span><span class="o">.</span><span class="n">cmap</span><span class="p">(</span><span class="n">upp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">upp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">nfeed</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">upp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">uniquepairs</span>
            <span class="p">],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;prod&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;u4&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;conjugate&quot;</span><span class="p">,</span> <span class="s2">&quot;u1&quot;</span><span class="p">)],</span>
        <span class="p">)</span>

        <span class="c1"># Construct the equivalent prod and stack index_map for the telescope instance</span>
        <span class="n">triu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">nfeed</span><span class="p">)</span>
        <span class="n">dt_prod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s2">&quot;input_a&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;u2&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;input_b&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;u2&quot;</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bt_prod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">triu</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;&lt;u2&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dt_prod</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Construct the equivalent reverse_map stack for the telescope instance.</span>
        <span class="c1"># Note that we identify invalid products here using an index that is the</span>
        <span class="c1"># size of the stack axis.</span>
        <span class="n">feedmask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">feedmask</span><span class="p">[</span><span class="n">triu</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bt_rev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="n">feedmask</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;stack&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;u4&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;conjugate&quot;</span><span class="p">,</span> <span class="s2">&quot;u1&quot;</span><span class="p">)]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bt_rev</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">feedmask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">feedmap</span><span class="p">[</span><span class="n">triu</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">npairs</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bt_rev</span><span class="p">[</span><span class="s2">&quot;conjugate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">feedmask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">feedconj</span><span class="p">[</span><span class="n">triu</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="CollateProducts">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.CollateProducts">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CollateProducts</span><span class="p">(</span><span class="n">TelescopeStreamMixIn</span><span class="p">,</span> <span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract and order the correlation products for map-making.</span>

<span class="sd">    The task will take a sidereal task and format the products that are needed</span>
<span class="sd">    or the map-making. It uses a BeamTransfer instance to figure out what these</span>
<span class="sd">    products are, and how they should be ordered. It similarly selects only the</span>
<span class="sd">    required frequencies.</span>

<span class="sd">    It is important to note that while the input</span>
<span class="sd">    :class:`~containers.SiderealStream` can contain more feeds and frequencies</span>
<span class="sd">    than are contained in the BeamTransfers, the converse is not true. That is,</span>
<span class="sd">    all the frequencies and feeds that are in the BeamTransfers must be found in</span>
<span class="sd">    the timestream object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    weight : string (&#39;natural&#39;, &#39;uniform&#39;, or &#39;inverse_variance&#39;)</span>
<span class="sd">        How to weight the redundant baselines when stacking:</span>
<span class="sd">            &#39;natural&#39; - each baseline weighted by its redundancy (default)</span>
<span class="sd">            &#39;uniform&#39; - each baseline given equal weight</span>
<span class="sd">            &#39;inverse_variance&#39; - each baseline weighted by the weight attribute</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">weight</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">enum</span><span class="p">([</span><span class="s2">&quot;natural&quot;</span><span class="p">,</span> <span class="s2">&quot;uniform&quot;</span><span class="p">,</span> <span class="s2">&quot;inverse_variance&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;natural&quot;</span><span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealStream</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealStream</span><span class="p">:</span> <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">TimeStream</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">TimeStream</span><span class="p">:</span> <span class="o">...</span>

<div class="viewcode-block" id="CollateProducts.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.CollateProducts.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Select and reorder the products.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ss</span>
<span class="sd">            Data with products</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sp</span>
<span class="sd">            Dataset containing only the required products.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For each input in the file, find the corresponding index in the telescope instance</span>
        <span class="n">input_ind</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">find_inputs</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">input_index</span><span class="p">,</span> <span class="n">ss</span><span class="o">.</span><span class="n">input</span><span class="p">,</span> <span class="n">require_match</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

        <span class="c1"># Figure out the reverse mapping (i.e., for each input in the telescope instance,</span>
        <span class="c1"># find the corresponding index in file)</span>
        <span class="n">rev_input_ind</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">find_inputs</span><span class="p">(</span>
            <span class="n">ss</span><span class="o">.</span><span class="n">input</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">input_index</span><span class="p">,</span> <span class="n">require_match</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1"># Figure out mapping between the frequencies</span>
        <span class="n">freq_ind</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">find_keys</span><span class="p">(</span>
            <span class="n">ss</span><span class="o">.</span><span class="n">freq</span><span class="p">[:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">require_match</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="n">bt_freq</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">][</span><span class="n">freq_ind</span><span class="p">]</span>
        <span class="c1"># Determine the input product map and conjugation.</span>
        <span class="c1"># If the input timestream is already stacked, then attempt to redefine</span>
        <span class="c1"># its representative products so that they contain only feeds that exist</span>
        <span class="c1"># and are not masked in the telescope instance.</span>
        <span class="k">if</span> <span class="n">ss</span><span class="o">.</span><span class="n">is_stacked</span><span class="p">:</span>
            <span class="n">stack_new</span><span class="p">,</span> <span class="n">stack_flag</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">redefine_stack_index_map</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="p">,</span> <span class="n">ss</span><span class="o">.</span><span class="n">input</span><span class="p">,</span> <span class="n">ss</span><span class="o">.</span><span class="n">prod</span><span class="p">,</span> <span class="n">ss</span><span class="o">.</span><span class="n">stack</span><span class="p">,</span> <span class="n">ss</span><span class="o">.</span><span class="n">reverse_map</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">stack_flag</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;There are </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">stack_flag</span><span class="p">)</span><span class="si">:</span><span class="s2">0.0f</span><span class="si">}</span><span class="s2"> stacked baselines &quot;</span>
                    <span class="s2">&quot;that are masked in the telescope instance.&quot;</span>
                <span class="p">)</span>

            <span class="n">ss_prod</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">prod</span><span class="p">[</span><span class="n">stack_new</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">]]</span>
            <span class="n">ss_conj</span> <span class="o">=</span> <span class="n">stack_new</span><span class="p">[</span><span class="s2">&quot;conjugate&quot;</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">ss_prod</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">prod</span>
            <span class="n">ss_conj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ss_prod</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># Create output container</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">bt_freq</span><span class="p">,</span>
            <span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">input_index</span><span class="p">,</span>
            <span class="n">prod</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bt_prod</span><span class="p">,</span>
            <span class="n">stack</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bt_stack</span><span class="p">,</span>
            <span class="n">reverse_map_stack</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bt_rev</span><span class="p">,</span>
            <span class="n">copy_from</span><span class="o">=</span><span class="n">ss</span><span class="p">,</span>
            <span class="n">distributed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">comm</span><span class="o">=</span><span class="n">ss</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Check if frequencies are already ordered</span>
        <span class="n">no_redistribute</span> <span class="o">=</span> <span class="n">freq_ind</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">freq</span><span class="p">[:])))</span>

        <span class="c1"># If frequencies are mapped across ranks, we have to redistribute so all</span>
        <span class="c1"># frequencies and products are on each rank</span>
        <span class="n">raxis</span> <span class="o">=</span> <span class="s2">&quot;freq&quot;</span> <span class="k">if</span> <span class="n">no_redistribute</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;ra&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Distributing across &#39;</span><span class="si">{</span><span class="n">raxis</span><span class="si">}</span><span class="s2">&#39; axis&quot;</span><span class="p">)</span>
        <span class="n">ss</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="n">raxis</span><span class="p">)</span>
        <span class="n">sp</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="n">raxis</span><span class="p">)</span>

        <span class="c1"># Initialize datasets in output container</span>
        <span class="n">sp</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">sp</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">sp</span><span class="o">.</span><span class="n">input_flags</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">input_flags</span><span class="p">[</span><span class="n">rev_input_ind</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Infer number of products that went into each stack</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">!=</span> <span class="s2">&quot;inverse_variance&quot;</span><span class="p">:</span>
            <span class="n">ssi</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">input_flags</span><span class="p">[:]</span>
            <span class="n">ssp</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">][:]</span>
            <span class="n">sss</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">reverse_map</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">][</span><span class="s2">&quot;stack&quot;</span><span class="p">][:]</span>
            <span class="n">nstack</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">nprod_in_stack</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">calculate_redundancy</span><span class="p">(</span><span class="n">ssi</span><span class="p">,</span> <span class="n">ssp</span><span class="p">,</span> <span class="n">sss</span><span class="p">,</span> <span class="n">nstack</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
                <span class="n">nprod_in_stack</span> <span class="o">=</span> <span class="p">(</span><span class="n">nprod_in_stack</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># Create counter to increment during the stacking.</span>
        <span class="c1"># This will be used to normalize at the end.</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">weight</span><span class="p">[:])</span>

        <span class="c1"># Dereference the global slices, there&#39;s a hidden MPI call in the [:] operation.</span>
        <span class="n">spv</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span>
        <span class="n">ssv</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span>
        <span class="n">spw</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span>
        <span class="n">ssw</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span>

        <span class="c1"># Get the local frequency and time slice/mapping</span>
        <span class="n">freq_ind</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">no_redistribute</span> <span class="k">else</span> <span class="n">freq_ind</span>
        <span class="n">time_ind</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">no_redistribute</span> <span class="k">else</span> <span class="n">ssv</span><span class="o">.</span><span class="n">local_bounds</span>

        <span class="c1"># Iterate over products (stacked) in the sidereal stream</span>
        <span class="k">for</span> <span class="n">ss_pi</span><span class="p">,</span> <span class="p">((</span><span class="n">ii</span><span class="p">,</span> <span class="n">ij</span><span class="p">),</span> <span class="n">conj</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ss_prod</span><span class="p">,</span> <span class="n">ss_conj</span><span class="p">)):</span>
            <span class="c1"># Map the feed indices into ones for the Telescope class</span>
            <span class="n">bi</span><span class="p">,</span> <span class="n">bj</span> <span class="o">=</span> <span class="n">input_ind</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">input_ind</span><span class="p">[</span><span class="n">ij</span><span class="p">]</span>

            <span class="c1"># If either feed is not in the telescope class, skip it.</span>
            <span class="k">if</span> <span class="n">bi</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">bj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">sp_pi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">feedmap</span><span class="p">[</span><span class="n">bi</span><span class="p">,</span> <span class="n">bj</span><span class="p">]</span>
            <span class="n">feedconj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">feedconj</span><span class="p">[</span><span class="n">bi</span><span class="p">,</span> <span class="n">bj</span><span class="p">]</span>

            <span class="c1"># Skip if product index is not valid</span>
            <span class="k">if</span> <span class="n">sp_pi</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Generate weight</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;inverse_variance&quot;</span><span class="p">:</span>
                <span class="n">wss</span> <span class="o">=</span> <span class="n">ssw</span><span class="o">.</span><span class="n">local_array</span><span class="p">[</span><span class="n">freq_ind</span><span class="p">,</span> <span class="n">ss_pi</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">wss</span> <span class="o">=</span> <span class="p">(</span><span class="n">ssw</span><span class="o">.</span><span class="n">local_array</span><span class="p">[</span><span class="n">freq_ind</span><span class="p">,</span> <span class="n">ss_pi</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">wss</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">nprod_in_stack</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">ss_pi</span><span class="p">,</span> <span class="n">time_ind</span><span class="p">]</span>

            <span class="c1"># Accumulate visibilities, conjugating if required</span>
            <span class="k">if</span> <span class="n">feedconj</span> <span class="o">==</span> <span class="n">conj</span><span class="p">:</span>
                <span class="n">spv</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:,</span> <span class="n">sp_pi</span><span class="p">]</span> <span class="o">+=</span> <span class="n">wss</span> <span class="o">*</span> <span class="n">ssv</span><span class="o">.</span><span class="n">local_array</span><span class="p">[</span><span class="n">freq_ind</span><span class="p">,</span> <span class="n">ss_pi</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">spv</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:,</span> <span class="n">sp_pi</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="n">wss</span> <span class="o">*</span> <span class="n">ssv</span><span class="o">.</span><span class="n">local_array</span><span class="p">[</span><span class="n">freq_ind</span><span class="p">,</span> <span class="n">ss_pi</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
                <span class="p">)</span>

            <span class="c1"># Accumulate variances in quadrature.  Save in the weight dataset.</span>
            <span class="n">spw</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:,</span> <span class="n">sp_pi</span><span class="p">]</span> <span class="o">+=</span> <span class="n">wss</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span>
                <span class="n">ssw</span><span class="o">.</span><span class="n">local_array</span><span class="p">[</span><span class="n">freq_ind</span><span class="p">,</span> <span class="n">ss_pi</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># Increment counter</span>
            <span class="n">counter</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:,</span> <span class="n">sp_pi</span><span class="p">]</span> <span class="o">+=</span> <span class="n">wss</span>

        <span class="c1"># Divide through by counter to get properly weighted visibility average</span>
        <span class="n">sp</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>
        <span class="n">sp</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">counter</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">weight</span><span class="p">[:])</span>

        <span class="c1"># Copy over any additional datasets that need to be frequency filtered</span>
        <span class="n">copy_datasets_filter</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="s2">&quot;freq&quot;</span><span class="p">,</span> <span class="n">freq_ind</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">,</span> <span class="s2">&quot;prod&quot;</span><span class="p">,</span> <span class="s2">&quot;stack&quot;</span><span class="p">])</span>

        <span class="c1"># Switch back to frequency distribution. This will have minimal</span>
        <span class="c1"># cost if we are already distributed in frequency</span>
        <span class="n">ss</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
        <span class="n">sp</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sp</span></div>
</div>



<div class="viewcode-block" id="SelectFreq">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.SelectFreq">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SelectFreq</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Select a subset of frequencies from a container.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    freq_physical : list</span>
<span class="sd">        List of physical frequencies in MHz.</span>
<span class="sd">        Given first priority.</span>
<span class="sd">    channel_range : list</span>
<span class="sd">        Range of frequency channel indices, either</span>
<span class="sd">        [start, stop, step], [start, stop], or [stop]</span>
<span class="sd">        is acceptable.  Given second priority.</span>
<span class="sd">    channel_index : list</span>
<span class="sd">        List of frequency channel indices.</span>
<span class="sd">        Given third priority.</span>
<span class="sd">    freq_physical_range : list</span>
<span class="sd">        Range of physical frequencies to include given as (low_freq, high_freq).</span>
<span class="sd">        Given fourth priority.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">freq_physical</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[])</span>
    <span class="n">freq_physical_range</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[])</span>
    <span class="n">channel_range</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[])</span>
    <span class="n">channel_index</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[])</span>

<div class="viewcode-block" id="SelectFreq.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.SelectFreq.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Selet a subset of the frequencies.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : ContainerPrototype</span>
<span class="sd">            A data container with a frequency axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        newdata : ContainerPrototype</span>
<span class="sd">            New container with trimmed frequencies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set up frequency selection.</span>
        <span class="n">freq_map</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">]</span>

        <span class="c1"># Construct the frequency channel selection</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_physical</span><span class="p">:</span>
            <span class="n">newindex</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">freq_map</span><span class="p">[</span><span class="s2">&quot;centre&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">freq</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_physical</span>
                <span class="p">}</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_range</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_range</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">):</span>
            <span class="n">newindex</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_range</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_index</span><span class="p">:</span>
            <span class="n">newindex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_index</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_physical_range</span><span class="p">:</span>
            <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freq_physical_range</span><span class="p">)</span>
            <span class="n">newindex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="p">(</span><span class="n">freq_map</span><span class="p">[</span><span class="s2">&quot;centre&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">low</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">freq_map</span><span class="p">[</span><span class="s2">&quot;centre&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">)</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Must specify either freq_physical, channel_range, or channel_index.&quot;</span>
            <span class="p">)</span>

        <span class="n">freq_map</span> <span class="o">=</span> <span class="n">freq_map</span><span class="p">[</span><span class="n">newindex</span><span class="p">]</span>

        <span class="c1"># Destribute input container over ra or time.</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">([</span><span class="s2">&quot;ra&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;pixel&quot;</span><span class="p">])</span>

        <span class="c1"># Create new container with subset of frequencies.</span>
        <span class="n">newdata</span> <span class="o">=</span> <span class="n">empty_like</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq_map</span><span class="p">)</span>

        <span class="c1"># Make sure all datasets are initialised</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">newdata</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
                <span class="n">newdata</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># Redistribute new container over ra or time.</span>
        <span class="n">newdata</span><span class="o">.</span><span class="n">redistribute</span><span class="p">([</span><span class="s2">&quot;ra&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;pixel&quot;</span><span class="p">])</span>

        <span class="c1"># Copy over datasets. If the dataset has a frequency axis,</span>
        <span class="c1"># then we only copy over the subset.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ContainerPrototype</span><span class="p">):</span>
            <span class="n">copy_datasets_filter</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">newdata</span><span class="p">,</span> <span class="s2">&quot;freq&quot;</span><span class="p">,</span> <span class="n">newindex</span><span class="p">,</span> <span class="n">copy_without_selection</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newdata</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="p">[</span><span class="n">newindex</span><span class="p">]</span>
            <span class="n">newdata</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="n">newindex</span><span class="p">]</span>
            <span class="n">newdata</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">gain</span><span class="p">[</span><span class="n">newindex</span><span class="p">]</span>

            <span class="n">newdata</span><span class="o">.</span><span class="n">input_flags</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">input_flags</span><span class="p">[:]</span>

        <span class="c1"># Switch back to frequency distribution</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
        <span class="n">newdata</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">newdata</span></div>
</div>



<div class="viewcode-block" id="GenerateSubBands">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.GenerateSubBands">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GenerateSubBands</span><span class="p">(</span><span class="n">SelectFreq</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate multiple sub-bands from an input container.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    sub_band_spec : dict</span>
<span class="sd">        Dictionary of the format {&quot;band_a&quot;: {&quot;channel_range&quot;: [0, 64]}, ...}</span>
<span class="sd">        where each entry is a separate sub-band with the key providing the tag</span>
<span class="sd">        that will be used to describe the sub-band and the value providing a</span>
<span class="sd">        dictionary that can contain any of the config properties used by the</span>
<span class="sd">        SelectFreq task to downselect along the frequency axis to obtain the</span>
<span class="sd">        sub-band from the input container.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">sub_band_spec</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>

<div class="viewcode-block" id="GenerateSubBands.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.GenerateSubBands.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cache the data product that will be sub-divided along the frequency axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : container</span>
<span class="sd">            Any container with a freq axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_parameters</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">key</span><span class="p">:</span> <span class="n">val</span><span class="o">.</span><span class="n">default</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">SelectFreq</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sub_bands</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_band_spec</span><span class="o">.</span><span class="n">keys</span><span class="p">())[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="GenerateSubBands.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.GenerateSubBands.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Select the next sub-band from the container that was provided on setup.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sub : container</span>
<span class="sd">            Same type of container as was provided on setup,</span>
<span class="sd">            downselected along the frequency axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_bands</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">PipelineStopIteration</span>

        <span class="n">tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_bands</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_freq_selection</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_band_spec</span><span class="p">[</span><span class="n">tag</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">base_tag</span><span class="p">,</span> <span class="n">tag</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tag</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_set_freq_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set properties of the SelectFreq base class to choose the next sub-band.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="n">default</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>



<div class="viewcode-block" id="ElevationDependentHybridVisWeight">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.ElevationDependentHybridVisWeight">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ElevationDependentHybridVisWeight</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add elevation dependence to hybrid visibility weights.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ElevationDependentHybridVisWeight.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.ElevationDependentHybridVisWeight.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">HybridVisStream</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove the weights dataset and broadcast to elevation weights.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data</span>
<span class="sd">            Hybrid visibilities with elevation-independent weights.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data</span>
<span class="sd">            Input container with different weights dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># if elevation-dependent weights alread exist, this</span>
        <span class="c1"># should be a no-op and just pass the dataset along</span>
        <span class="k">if</span> <span class="s2">&quot;elevation_vis_weight&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Container already has the required dataset.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;vis_weight&quot;</span><span class="p">][:]</span><span class="o">.</span><span class="n">local_array</span>
            <span class="c1"># Remove the reference to the vis_weight dataset</span>
            <span class="k">del</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;vis_weight&quot;</span><span class="p">]</span>
            <span class="c1"># Add the new elevation-dependent weight dataset</span>
            <span class="n">data</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;elevation_vis_weight&quot;</span><span class="p">)</span>
            <span class="c1"># Write the weights into the new dataset, broadcasting over</span>
            <span class="c1"># the elevation axis</span>
            <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="n">data</span></div>
</div>



<div class="viewcode-block" id="MModeTransform">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.MModeTransform">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MModeTransform</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Transform a sidereal stream to m-modes.</span>

<span class="sd">    Currently ignores any noise weighting.</span>

<span class="sd">    The maximum m used in the container is derived from the number of</span>
<span class="sd">    time samples, or if a manager is supplied `telescope.mmax` is used.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    remove_integration_window : bool</span>
<span class="sd">        Deconvolve the effect of the finite width of the RA integration (presuming it</span>
<span class="sd">        was a rectangular integration window). This is applied to both the visibilities</span>
<span class="sd">        and the weights.</span>
<span class="sd">    use_fftw : bool</span>
<span class="sd">        If True, then use fftW to do the Fourier Transform, else use</span>
<span class="sd">        numpy fft. Default is True.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">remove_integration_window</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">use_fftw</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="MModeTransform.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.MModeTransform.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">manager</span><span class="p">:</span> <span class="n">io</span><span class="o">.</span><span class="n">TelescopeConvertible</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the telescope instance if a manager object is given.</span>

<span class="sd">        This is used to set the `mmax` used in the transform.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        manager : manager.ProductManager, optional</span>
<span class="sd">            The telescope/manager used to set the `mmax`. If not set, `mmax`</span>
<span class="sd">            is derived from the timestream.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">manager</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">get_telescope</span><span class="p">(</span><span class="n">manager</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="MModeTransform.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.MModeTransform.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sstream</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealContainer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">MContainer</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform the m-mode transform.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sstream : containers.SiderealStream or containers.HybridVisStream</span>
<span class="sd">            The input sidereal stream.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mmodes : containers.MModes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">contmap</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">containers</span><span class="o">.</span><span class="n">SiderealStream</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">MModes</span><span class="p">,</span>
            <span class="n">containers</span><span class="o">.</span><span class="n">HybridVisStream</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">HybridVisMModes</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="c1"># Get the output container type</span>
        <span class="n">out_cont</span> <span class="o">=</span> <span class="n">contmap</span><span class="p">[</span><span class="n">sstream</span><span class="o">.</span><span class="vm">__class__</span><span class="p">]</span>

        <span class="n">sstream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">svis</span> <span class="o">=</span> <span class="n">sstream</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">sweight</span> <span class="o">=</span> <span class="n">sstream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="c1"># Sum the noise variance over time samples, this will become the noise</span>
        <span class="c1"># variance for the m-modes</span>
        <span class="n">nra</span> <span class="o">=</span> <span class="n">sstream</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">weight_sum</span> <span class="o">=</span> <span class="n">nra</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span>
            <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">sweight</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">mmax</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mmax</span> <span class="o">=</span> <span class="n">svis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span>

        <span class="c1"># Create the container to store the modes in</span>
        <span class="n">ma</span> <span class="o">=</span> <span class="n">out_cont</span><span class="p">(</span>
            <span class="n">mmax</span><span class="o">=</span><span class="n">mmax</span><span class="p">,</span>
            <span class="n">oddra</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">nra</span> <span class="o">%</span> <span class="mi">2</span><span class="p">),</span>
            <span class="n">axes_from</span><span class="o">=</span><span class="n">sstream</span><span class="p">,</span>
            <span class="n">attrs_from</span><span class="o">=</span><span class="n">sstream</span><span class="p">,</span>
            <span class="n">comm</span><span class="o">=</span><span class="n">sstream</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ma</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
        <span class="n">mvis</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">mweight</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="c1"># Generate the m-mode transform directly into the output container</span>
        <span class="c1"># NOTE: Need to zero fill as not every element gets set within _make_marray</span>
        <span class="n">mvis</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">_make_marray</span><span class="p">(</span><span class="n">svis</span><span class="p">,</span> <span class="n">mvis</span><span class="p">,</span> <span class="n">mmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_fftw</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">use_fftw</span><span class="p">)</span>

        <span class="c1"># Assign the weights into the container</span>
        <span class="n">mweight</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">weight_sum</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

        <span class="c1"># Divide out the m-mode sinc-suppression caused by the rectangular integration window</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_integration_window</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">mmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">m</span> <span class="o">/</span> <span class="n">nra</span><span class="p">)</span>
            <span class="n">inv_w</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>

            <span class="n">sl_vis</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mvis</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">mvis</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">inv_w</span><span class="p">[</span><span class="n">sl_vis</span><span class="p">]</span>

            <span class="n">sl_weight</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mweight</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">mweight</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">w</span><span class="p">[</span><span class="n">sl_weight</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="n">ma</span></div>
</div>



<span class="k">def</span><span class="w"> </span><span class="nf">_make_marray</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">mmodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_fftw</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make an m-mode array from a sidereal stream.</span>

<span class="sd">    This will loop over the first axis of `ts` to avoid needing a lot of memory for</span>
<span class="sd">    intermediate arrays.</span>

<span class="sd">    It can also write the m-mode output directly into a passed `mmodes` array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex64</span>

    <span class="k">if</span> <span class="n">mmodes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One of `mmodes` or `mmax` must be set.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mmodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If mmodes is set, mmax must be None.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mmodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mmodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;ts and mmodes have incompatible shapes: &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">mmodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">mmodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mmodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mmax</span> <span class="o">=</span> <span class="n">mmodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># Total number of modes</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># Calculate the max m to use for both positive and negative m. This is a little</span>
    <span class="c1"># tricky to get correct as we need to account for the number of negative</span>
    <span class="c1"># frequencies produced by the FFT</span>
    <span class="n">mlim</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">mmax</span><span class="p">)</span>
    <span class="n">mlim_neg</span> <span class="o">=</span> <span class="n">N</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">N</span> <span class="o">%</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">mmax</span> <span class="o">&gt;=</span> <span class="n">N</span> <span class="o">//</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">mmax</span>

    <span class="c1"># Do the transform and move the M axis to the front. There&#39;s</span>
    <span class="c1"># a bug in `pyfftw` which causes an error if `ts.ndim - len(axes) &gt;= 2`,</span>
    <span class="c1"># so we have to flatten the other axes to get around that. This is</span>
    <span class="c1"># still faster than `numpy` or `scipy` ffts.</span>
    <span class="n">shp</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">use_fftw</span><span class="p">:</span>
        <span class="n">m_fft</span> <span class="o">=</span> <span class="n">fft</span><span class="o">.</span><span class="n">fftw</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">shp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">axes</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shp</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">m_fft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">shp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shp</span><span class="p">)</span>

    <span class="n">m_fft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">m_fft</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Write the positive and negative m&#39;s</span>
    <span class="n">npos</span> <span class="o">=</span> <span class="n">mlim</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">nneg</span> <span class="o">=</span> <span class="n">mlim_neg</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Applying fft normalisation here is quite a bit</span>
    <span class="c1"># faster than applying it directly to `m_fft`. It&#39;s</span>
    <span class="c1"># not entirely clear why.</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">shp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">mmodes</span><span class="p">[:</span><span class="n">npos</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_fft</span><span class="p">[:</span><span class="n">npos</span><span class="p">]</span> <span class="o">*</span> <span class="n">norm</span>
    <span class="c1"># Take the conjugate of the negative modes</span>
    <span class="n">mmodes</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">nneg</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_fft</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="n">nneg</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="o">*</span> <span class="n">norm</span>

    <span class="k">return</span> <span class="n">mmodes</span>


<div class="viewcode-block" id="MModeInverseTransform">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.MModeInverseTransform">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MModeInverseTransform</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Transform m-modes to sidereal stream.</span>

<span class="sd">    Currently ignores any noise weighting.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Using `apply_integration_window` will modify the input mmodes.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    nra : int</span>
<span class="sd">        Number of RA bins in the output. Note that if the number of samples does not</span>
<span class="sd">        Nyquist sample the maximum m, information may be lost. If not set, then try to</span>
<span class="sd">        get from an `original_nra` attribute on the incoming MModes, otherwise determine</span>
<span class="sd">        an appropriate number of RA bins from the mmax.</span>
<span class="sd">    apply_integration_window : bool</span>
<span class="sd">        Apply the effect of the finite width of the RA integration (presuming a</span>
<span class="sd">        rectangular integration window). This is applied to both the visibilities and</span>
<span class="sd">        the weights. If this is true, as a side effect the input data will be modified</span>
<span class="sd">        in place.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nra</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">apply_integration_window</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="MModeInverseTransform.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.MModeInverseTransform.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mmodes</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">MContainer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealContainer</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform the m-mode inverse transform.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mmodes : containers.MModes</span>
<span class="sd">            The input m-modes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sstream : containers.SiderealStream</span>
<span class="sd">            The output sidereal stream.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: If n_time is smaller than Nyquist sampling the m-mode axis then</span>
        <span class="c1"># the m-modes get clipped. If it is larger, they get zero padded. This</span>
        <span class="c1"># is NOT passed directly as parameter &#39;n&#39; to `numpy.fft.ifft`, as this</span>
        <span class="c1"># would give unwanted behaviour (https://github.com/numpy/numpy/pull/7593).</span>

        <span class="c1"># Ensure m-modes are distributed in frequency</span>
        <span class="n">mmodes</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Use the nra property if set otherwise use the natural nra from the incoming</span>
        <span class="c1"># container</span>
        <span class="n">nra_cont</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">mmodes</span><span class="o">.</span><span class="n">mmax</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">mmodes</span><span class="o">.</span><span class="n">oddra</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">nra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nra</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nra</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">nra_cont</span>

        <span class="c1"># Apply the m-mode sinc-suppression caused by the rectangular integration window</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_integration_window</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">mmodes</span><span class="o">.</span><span class="n">mmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">m</span> <span class="o">/</span> <span class="n">nra</span><span class="p">)</span>
            <span class="n">inv_w</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>

            <span class="n">sl_vis</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mmodes</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">mmodes</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">w</span><span class="p">[</span><span class="n">sl_vis</span><span class="p">]</span>

            <span class="n">sl_weight</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mmodes</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">mmodes</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">inv_w</span><span class="p">[</span><span class="n">sl_weight</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="c1"># Re-construct array of S-streams</span>
        <span class="n">ssarray</span> <span class="o">=</span> <span class="n">_make_ssarray</span><span class="p">(</span><span class="n">mmodes</span><span class="o">.</span><span class="n">vis</span><span class="p">[:],</span> <span class="n">n</span><span class="o">=</span><span class="n">nra</span><span class="p">)</span>
        <span class="n">nra</span> <span class="o">=</span> <span class="n">ssarray</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Get the actual nra used</span>
        <span class="n">ssarray</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">ssarray</span><span class="p">[:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">mmodes</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>

        <span class="c1"># Construct container and set visibility data</span>
        <span class="n">sstream</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealStream</span><span class="p">(</span>
            <span class="n">ra</span><span class="o">=</span><span class="n">nra</span><span class="p">,</span>
            <span class="n">axes_from</span><span class="o">=</span><span class="n">mmodes</span><span class="p">,</span>
            <span class="n">attrs_from</span><span class="o">=</span><span class="n">mmodes</span><span class="p">,</span>
            <span class="n">distributed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">comm</span><span class="o">=</span><span class="n">mmodes</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">sstream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Assign the visibilities and weights into the container</span>
        <span class="n">sstream</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">ssarray</span>
        <span class="c1"># There is no way to recover time information for the weights.</span>
        <span class="c1"># Just assign the time average to each baseline and frequency.</span>
        <span class="n">sstream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">mmodes</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:][:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">/</span> <span class="n">nra</span>

        <span class="k">return</span> <span class="n">sstream</span></div>
</div>



<div class="viewcode-block" id="SiderealMModeResample">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.SiderealMModeResample">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SiderealMModeResample</span><span class="p">(</span>
    <span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">group_tasks</span><span class="p">(</span><span class="n">MModeTransform</span><span class="p">,</span> <span class="n">MModeInverseTransform</span><span class="p">)</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Resample a sidereal stream by FFT.</span>

<span class="sd">    This performs a forward and inverse m-mode transform to resample a sidereal stream.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    nra : int</span>
<span class="sd">        The number of RA bins for the output stream.</span>
<span class="sd">    remove_integration_window, apply_integration_window : bool</span>
<span class="sd">        Remove the integration window from the incoming data, and/or apply it to the</span>
<span class="sd">        output sidereal stream.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_make_ssarray</span><span class="p">(</span><span class="n">mmodes</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># Construct an array of sidereal time streams from m-modes</span>
    <span class="n">marray</span> <span class="o">=</span> <span class="n">_unpack_marray</span><span class="p">(</span><span class="n">mmodes</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">marray</span> <span class="o">*</span> <span class="n">marray</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_unpack_marray</span><span class="p">(</span><span class="n">mmodes</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># Unpack m-modes into the correct format for an FFT</span>
    <span class="c1"># (i.e. from [m, +/-, freq, baseline] to [freq, baseline, time-FFT])</span>

    <span class="n">shape</span> <span class="o">=</span> <span class="n">mmodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">mmax_plus</span> <span class="o">=</span> <span class="n">mmodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mmodes</span><span class="p">[</span><span class="n">mmax_plus</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="n">mmax_minus</span> <span class="o">=</span> <span class="n">mmax_plus</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mmax_minus</span> <span class="o">=</span> <span class="n">mmax_plus</span>

    <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ntimes</span> <span class="o">=</span> <span class="n">mmax_plus</span> <span class="o">+</span> <span class="n">mmax_minus</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ntimes</span> <span class="o">=</span> <span class="n">n</span>
        <span class="n">mmax_plus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">((</span><span class="n">ntimes</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">mmax_plus</span><span class="p">))</span>
        <span class="n">mmax_minus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(((</span><span class="n">ntimes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">mmax_minus</span><span class="p">))</span>

    <span class="c1"># Create array to contain mmodes</span>
    <span class="n">marray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="o">*</span><span class="n">shape</span><span class="p">,</span> <span class="n">ntimes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
    <span class="c1"># Add the DC bin</span>
    <span class="n">marray</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mmodes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Add all m-modes up to mmax_minus</span>
    <span class="k">for</span> <span class="n">mi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">mmax_minus</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">marray</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">mi</span><span class="p">]</span> <span class="o">=</span> <span class="n">mmodes</span><span class="p">[</span><span class="n">mi</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">marray</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="n">mi</span><span class="p">]</span> <span class="o">=</span> <span class="n">mmodes</span><span class="p">[</span><span class="n">mi</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">mmax_plus</span> <span class="o">!=</span> <span class="n">mmax_minus</span><span class="p">:</span>
        <span class="c1"># In case of even number of samples. Add the Nyquist frequency.</span>
        <span class="n">marray</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">mmax_plus</span><span class="p">]</span> <span class="o">=</span> <span class="n">mmodes</span><span class="p">[</span><span class="n">mmax_plus</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">marray</span>


<div class="viewcode-block" id="LanczosRegridder">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.LanczosRegridder">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">LanczosRegridder</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Interpolate the time-like axis of a dataset onto a regular grid.</span>

<span class="sd">    Uses a maximum-likelihood inverse of a Lanczos interpolation to do the</span>
<span class="sd">    regridding. This gives a reasonably local regridding, that is pretty well</span>
<span class="sd">    behaved in m-space.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    samples : int</span>
<span class="sd">        Number of samples to interpolate onto.</span>
<span class="sd">    start: float</span>
<span class="sd">        Start of the interpolated samples.</span>
<span class="sd">    end: float</span>
<span class="sd">        End of the interpolated samples.</span>
<span class="sd">    kernel_width : int</span>
<span class="sd">        Width of the interpolation kernel. NOTE: This was formally called</span>
<span class="sd">        `lanczos_width`.</span>
<span class="sd">    epsilon: float</span>
<span class="sd">        Numerical regulariser used in kernel inversion. Default is 1.0e-3.</span>
<span class="sd">    mask_zero_weight: bool</span>
<span class="sd">        Mask the output noise weights at frequencies where the weights were</span>
<span class="sd">        zero for all time samples.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">samples</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1024</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">kernel_width</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">)</span>
    <span class="n">mask_zero_weight</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="LanczosRegridder.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.LanczosRegridder.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">observer</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the local observers position.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        observer : :class:`~caput.astro.observer.Observer`</span>
<span class="sd">            An Observer object holding the geographic location of the telescope.</span>
<span class="sd">            Note that :class:`~drift.core.TransitTelescope` instances are also</span>
<span class="sd">            Observers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observer</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">get_telescope</span><span class="p">(</span><span class="n">observer</span><span class="p">)</span></div>


<div class="viewcode-block" id="LanczosRegridder.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.LanczosRegridder.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Regrid visibility data in the time direction.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : containers.TODContainer</span>
<span class="sd">            Time-ordered data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_data : containers.TODContainer</span>
<span class="sd">            The regularly gridded interpolated timestream.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Redistribute if needed</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># View of data</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="n">vis_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

        <span class="c1"># Get input time grid</span>
        <span class="n">timelike_axis</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="n">timelike_axis</span><span class="p">][:]</span>

        <span class="c1"># check bounds</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Start or end points for regridder fall outside bounds of input data.&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># perform regridding</span>
        <span class="n">new_grid</span><span class="p">,</span> <span class="n">new_vis</span><span class="p">,</span> <span class="n">ni</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_regrid</span><span class="p">(</span><span class="n">vis_data</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">times</span><span class="p">)</span>

        <span class="c1"># Wrap to produce MPIArray</span>
        <span class="n">new_vis</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">new_vis</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">distributed_axis</span><span class="p">)</span>
        <span class="n">ni</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">ni</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">distributed_axis</span><span class="p">)</span>

        <span class="c1"># Create new container for output</span>
        <span class="n">cont_type</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="n">cont_type</span><span class="p">(</span><span class="n">axes_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="n">timelike_axis</span><span class="p">:</span> <span class="n">new_grid</span><span class="p">})</span>
        <span class="n">new_data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
        <span class="n">new_data</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">new_vis</span>
        <span class="n">new_data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">ni</span>

        <span class="k">return</span> <span class="n">new_data</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_regrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vis_data</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
        <span class="c1"># Create a regular grid, padded at either end to supress interpolation issues</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_width</span>
        <span class="n">interp_grid</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">pad</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">+</span> <span class="n">pad</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span>
        <span class="p">)</span>
        <span class="c1"># scale to specified range</span>
        <span class="n">interp_grid</span> <span class="o">=</span> <span class="n">interp_grid</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span>

        <span class="c1"># Construct regridding matrix for reverse problem</span>
        <span class="n">lzf</span> <span class="o">=</span> <span class="n">regrid</span><span class="o">.</span><span class="n">lanczos_forward_matrix</span><span class="p">(</span>
            <span class="n">interp_grid</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_width</span>
        <span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Reshape data</span>
        <span class="n">vr</span> <span class="o">=</span> <span class="n">vis_data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vis_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">nr</span> <span class="o">=</span> <span class="n">weight</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vis_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Construct a signal &#39;covariance&#39;</span>
        <span class="n">Si</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">interp_grid</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span>

        <span class="c1"># Calculate the interpolated data and a noise weight at the points in the padded grid</span>
        <span class="n">sts</span><span class="p">,</span> <span class="n">ni</span> <span class="o">=</span> <span class="n">regrid</span><span class="o">.</span><span class="n">band_wiener</span><span class="p">(</span><span class="n">lzf</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">Si</span><span class="p">,</span> <span class="n">vr</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Throw away the padded ends</span>
        <span class="n">sts</span> <span class="o">=</span> <span class="n">sts</span><span class="p">[:,</span> <span class="n">pad</span><span class="p">:</span><span class="o">-</span><span class="n">pad</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ni</span> <span class="o">=</span> <span class="n">ni</span><span class="p">[:,</span> <span class="n">pad</span><span class="p">:</span><span class="o">-</span><span class="n">pad</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">interp_grid</span> <span class="o">=</span> <span class="n">interp_grid</span><span class="p">[</span><span class="n">pad</span><span class="p">:</span><span class="o">-</span><span class="n">pad</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Reshape to the correct shape</span>
        <span class="n">sts</span> <span class="o">=</span> <span class="n">sts</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">*</span><span class="n">vis_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">))</span>
        <span class="n">ni</span> <span class="o">=</span> <span class="n">ni</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">*</span><span class="n">vis_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_zero_weight</span><span class="p">:</span>
            <span class="c1"># set weights to zero where there is no data</span>
            <span class="n">w_mask</span> <span class="o">=</span> <span class="n">weight</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mf">0.0</span>
            <span class="n">ni</span> <span class="o">*=</span> <span class="n">w_mask</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">interp_grid</span><span class="p">,</span> <span class="n">sts</span><span class="p">,</span> <span class="n">ni</span></div>



<span class="c1"># Alias for compatibility</span>
<span class="n">Regridder</span> <span class="o">=</span> <span class="n">LanczosRegridder</span>


<div class="viewcode-block" id="ShiftRA">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.ShiftRA">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ShiftRA</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add a shift to the RA axis.</span>

<span class="sd">    This is useful for fixing a bug in earlier revisions of CHIME processing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    delta : float</span>
<span class="sd">        The shift to *add* to the RA axis.</span>
<span class="sd">    periodic : bool, optional</span>
<span class="sd">        If True, wrap any time sample that is shifted to RA &gt; 360 deg around to its</span>
<span class="sd">        360-degree-periodic counterpart, and likewise for any sample that is shifted</span>
<span class="sd">        to RA &lt; 0 deg. This wrapping is applied to the RA index_map along with any</span>
<span class="sd">        dataset with an `ra` axis. Default: False.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">delta</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">periodic</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="ShiftRA.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.ShiftRA.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sscont</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealContainer</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealContainer</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a shift to the input sidereal container.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sscont</span>
<span class="sd">            The container to shift. The input is modified in place.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sscont</span>
<span class="sd">            The shifted container.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sscont</span><span class="p">,</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealContainer</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expected a SiderealContainer, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">sscont</span><span class="p">)</span><span class="si">}</span><span class="s2"> instead.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Shift RA coordinates by delta</span>
        <span class="n">sscont</span><span class="o">.</span><span class="n">ra</span><span class="p">[:]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic</span><span class="p">:</span>
            <span class="c1"># If shift is positive, subtract 360 deg from any sample shifted to</span>
            <span class="c1"># &gt; 360 deg. Same idea if shift is negative, for samples shifted to &lt; 0 deg</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sscont</span><span class="o">.</span><span class="n">ra</span><span class="p">[</span><span class="n">sscont</span><span class="o">.</span><span class="n">ra</span><span class="p">[:]</span> <span class="o">&gt;=</span> <span class="mi">360</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">360</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sscont</span><span class="o">.</span><span class="n">ra</span><span class="p">[</span><span class="n">sscont</span><span class="o">.</span><span class="n">ra</span><span class="p">[:]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">360</span>

            <span class="c1"># Get indices that sort shifted RA axis in ascending order, and apply sort</span>
            <span class="n">ascending_ra_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">sscont</span><span class="o">.</span><span class="n">ra</span><span class="p">[:])</span>
            <span class="n">sscont</span><span class="o">.</span><span class="n">ra</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">sscont</span><span class="o">.</span><span class="n">ra</span><span class="p">[</span><span class="n">ascending_ra_idx</span><span class="p">]</span>

            <span class="c1"># Loop over datasets in container</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">dset</span> <span class="ow">in</span> <span class="n">sscont</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="s2">&quot;ra&quot;</span> <span class="ow">in</span> <span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]:</span>
                    <span class="c1"># If dataset has RA axis, identify which axis it is</span>
                    <span class="n">ra_axis_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;ra&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                    <span class="c1"># Make sure dataset isn&#39;t distributed in RA. If it is, redistribute</span>
                    <span class="c1"># along another (somewhat arbitrarily chosen) axis. (This should</span>
                    <span class="c1"># usually not be necessary.)</span>
                    <span class="k">if</span> <span class="n">dset</span><span class="o">.</span><span class="n">distributed</span> <span class="ow">and</span> <span class="n">dset</span><span class="o">.</span><span class="n">distributed_axis</span> <span class="o">==</span> <span class="n">ra_axis_idx</span><span class="p">:</span>
                        <span class="n">redist_axis</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ra_axis_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="n">dset</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="n">redist_axis</span><span class="p">)</span>

                    <span class="c1"># Apply RA-sorting from earlier to the appropriate axis</span>
                    <span class="n">slc</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span>
                    <span class="n">slc</span><span class="p">[</span><span class="n">ra_axis_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">ascending_ra_idx</span>
                    <span class="n">dset</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[:][</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slc</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">sscont</span></div>
</div>



<div class="viewcode-block" id="SelectPol">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.SelectPol">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SelectPol</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract a subset of Stokes parameters from beamformed data.</span>

<span class="sd">    Supports extraction of Stokes I, Q, U, and V from beamformed data for</span>
<span class="sd">    linear polarisations (XX, YY, reXY, imXY). Assumes beamformed data are</span>
<span class="sd">    already calibrated and normalized.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    pol : list of str</span>
<span class="sd">            List of Stokes parameters to extract.</span>
<span class="sd">            Must be a subset of [&#39;I&#39;, &#39;Q&#39;, &#39;U&#39;, &#39;V&#39;].</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">pol</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>

<div class="viewcode-block" id="SelectPol.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.SelectPol.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check that the requested polarisations are valid.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;I&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;XX&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;YY&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
            <span class="s2">&quot;Q&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;XX&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;YY&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">},</span>
            <span class="s2">&quot;U&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;reXY&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
            <span class="s2">&quot;V&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;imXY&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
        <span class="p">}</span>

        <span class="n">missing_pol</span> <span class="o">=</span> <span class="p">[</span><span class="n">pstr</span> <span class="k">for</span> <span class="n">pstr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">if</span> <span class="n">pstr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">missing_pol</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Do not support the selection of </span><span class="si">{</span><span class="n">missing_pol</span><span class="si">}</span><span class="s2">.  &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Available options include </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Duplicate Stokes parameters requested in `pol`.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SelectPol.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.SelectPol.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polcont</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract the requested Stokes parameters from the input container.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        polcont : ContainerPrototype</span>
<span class="sd">            A container with a &#39;pol&#39; axis containing linear polarisation data</span>
<span class="sd">            (e.g., XX, YY, reXY, imXY).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        outcont : same type as polcont</span>
<span class="sd">            A new container containing only the requested Stokes parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">polcont</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;pol&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">polcont</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Container of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">polcont</span><span class="p">)</span><span class="si">}</span><span class="s2"> does not have a pol axis.&quot;</span>
            <span class="p">)</span>

        <span class="n">input_pol</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">polcont</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;pol&quot;</span><span class="p">])</span>

        <span class="c1"># First, make sure that we have all of the input polarisations we require</span>
        <span class="c1"># to construct the selected polarisations.</span>
        <span class="n">required_pol</span> <span class="o">=</span> <span class="p">[</span><span class="n">pol</span> <span class="k">for</span> <span class="n">pstr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">for</span> <span class="n">pol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="n">pstr</span><span class="p">]]</span>
        <span class="n">missing_pol</span> <span class="o">=</span> <span class="p">[</span><span class="n">pol</span> <span class="k">for</span> <span class="n">pol</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">required_pol</span><span class="p">)</span> <span class="k">if</span> <span class="n">pol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">input_pol</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_pol</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Missing the following polarisations </span><span class="si">{</span><span class="n">missing_pol</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;which are needed to construct </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Identify the &quot;data&quot; and &quot;weight&quot; dataset</span>
        <span class="n">data_dset_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">polcont</span><span class="p">,</span> <span class="s2">&quot;_data_dset_name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">weight_dset_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">polcont</span><span class="p">,</span> <span class="s2">&quot;_weight_dset_name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Create the output container</span>
        <span class="n">outcont</span> <span class="o">=</span> <span class="n">empty_like</span><span class="p">(</span><span class="n">polcont</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">polcont</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">outcont</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
                <span class="n">outcont</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="n">outcont</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Create a function that generates the appropriate slices</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">make_slice</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">axis_pos</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="n">axis_pos</span> <span class="o">+</span> <span class="p">(</span><span class="n">index</span><span class="p">,)</span>

        <span class="c1"># Loop over datasets</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">dset</span> <span class="ow">in</span> <span class="n">polcont</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">out_dset</span> <span class="o">=</span> <span class="n">outcont</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

            <span class="k">if</span> <span class="s2">&quot;pol&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]:</span>
                <span class="c1"># No polarisation axis, directly copy over dataset</span>
                <span class="n">out_dset</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[:]</span>
                <span class="k">continue</span>

            <span class="c1"># Polarisation axis present, initialize output dataset to zero</span>
            <span class="n">out_dset</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">pol_axis_pos</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;pol&quot;</span><span class="p">)</span>

            <span class="c1"># If this is the weight dataset, keep track of where it is</span>
            <span class="c1"># non-zero across all of the summed polarisations.</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="n">weight_dset_name</span><span class="p">:</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
                    <span class="n">out_dset</span><span class="p">[:]</span><span class="o">.</span><span class="n">global_shape</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">out_dset</span><span class="p">[:]</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span>
                    <span class="n">comm</span><span class="o">=</span><span class="n">outcont</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="c1"># Loop over output polarisations</span>
            <span class="k">for</span> <span class="n">oo</span><span class="p">,</span> <span class="n">po</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">):</span>
                <span class="n">oslc</span> <span class="o">=</span> <span class="n">make_slice</span><span class="p">(</span><span class="n">oo</span><span class="p">,</span> <span class="n">pol_axis_pos</span><span class="p">)</span>
                <span class="n">pol_to_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="n">po</span><span class="p">]</span>
                <span class="n">nsum</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pol_to_sum</span><span class="p">)</span>

                <span class="c1"># Loop over the input polarisations that we need to sum</span>
                <span class="k">for</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sign</span> <span class="ow">in</span> <span class="n">pol_to_sum</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">ii</span> <span class="o">=</span> <span class="n">input_pol</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
                    <span class="n">islc</span> <span class="o">=</span> <span class="n">make_slice</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">pol_axis_pos</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="n">data_dset_name</span><span class="p">:</span>
                        <span class="c1"># This is the primary data product, where we would like</span>
                        <span class="c1"># to account for the sign.</span>
                        <span class="n">out_dset</span><span class="p">[</span><span class="n">oslc</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">dset</span><span class="p">[</span><span class="n">islc</span><span class="p">]</span>

                    <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="n">weight_dset_name</span><span class="p">:</span>
                        <span class="c1"># Keep track of what samples have non-zero weight</span>
                        <span class="c1"># across all input polarisations.</span>
                        <span class="n">flag</span><span class="p">[</span><span class="n">oslc</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">dset</span><span class="p">[</span><span class="n">islc</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span>

                        <span class="c1"># Invert weights so that we properly propagate the variance.</span>
                        <span class="n">out_dset</span><span class="p">[</span><span class="n">oslc</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">dset</span><span class="p">[</span><span class="n">islc</span><span class="p">])</span>

                    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">out_dset</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">):</span>
                        <span class="c1"># All cases of boolean datasets with a polarisation axis</span>
                        <span class="c1"># are masks, where a True value indicates a masked sample.</span>
                        <span class="c1"># In this case, we will combine the masks, so that if any</span>
                        <span class="c1"># of the input polarisations are masked then the output</span>
                        <span class="c1"># polarisation is also masked.</span>
                        <span class="n">out_dset</span><span class="p">[</span><span class="n">oslc</span><span class="p">]</span> <span class="o">|=</span> <span class="n">dset</span><span class="p">[</span><span class="n">islc</span><span class="p">]</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># For all other datasets, we will simply take the average</span>
                        <span class="n">out_dset</span><span class="p">[</span><span class="n">oslc</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dset</span><span class="p">[</span><span class="n">islc</span><span class="p">]</span>

                <span class="c1"># Normalize the output based on how many polarisations were summed</span>
                <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="n">weight_dset_name</span><span class="p">:</span>
                    <span class="n">out_dset</span><span class="p">[</span><span class="n">oslc</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">flag</span><span class="p">[</span><span class="n">oslc</span><span class="p">]</span> <span class="o">*</span> <span class="n">nsum</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">out_dset</span><span class="p">[</span><span class="n">oslc</span><span class="p">])</span>
                    <span class="p">)</span>

                <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">out_dset</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
                    <span class="n">out_dset</span><span class="p">[</span><span class="n">oslc</span><span class="p">]</span> <span class="o">//=</span> <span class="n">nsum</span>

                <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">out_dset</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">):</span>
                    <span class="k">pass</span>

                <span class="k">elif</span> <span class="s2">&quot;freq_cov&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
                    <span class="n">out_dset</span><span class="p">[</span><span class="n">oslc</span><span class="p">]</span> <span class="o">/=</span> <span class="n">nsum</span><span class="o">**</span><span class="mi">2</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out_dset</span><span class="p">[</span><span class="n">oslc</span><span class="p">]</span> <span class="o">/=</span> <span class="n">nsum</span>

        <span class="k">return</span> <span class="n">outcont</span></div>
</div>



<div class="viewcode-block" id="PolWeightedAverage">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.PolWeightedAverage">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PolWeightedAverage</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute an optimally weighted pseudo-Stokes I from XX and YY polarisations.</span>

<span class="sd">    This computes a weighted average:</span>
<span class="sd">        data_I = (w_XX * d_XX + w_YY * d_YY) / (w_XX + w_YY)</span>
<span class="sd">        weight_I = w_XX + w_YY</span>

<span class="sd">    Requires the input container to be a subclass of DataWeightContainer and to</span>
<span class="sd">    contain both XX and YY polarisations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PolWeightedAverage.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.PolWeightedAverage.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polcont</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute pseudo-Stokes I from XX and YY.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        polcont : DataWeightContainer</span>
<span class="sd">            A container with weight dataset and a &#39;pol&#39; axis containing XX and YY.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        outcont : same type as polcont</span>
<span class="sd">            A container with a single polarisation axis labeled &#39;I&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check input container</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">polcont</span><span class="p">,</span> <span class="s2">&quot;_weight_dset_name&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Input must be a subclass of DataWeightContainer with defined weight datasets.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;pol&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">polcont</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Input container of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">polcont</span><span class="p">)</span><span class="si">}</span><span class="s2"> does not have a &#39;pol&#39; axis.&quot;</span>
            <span class="p">)</span>

        <span class="n">input_pol</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">polcont</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;pol&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;XX&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">input_pol</span> <span class="ow">or</span> <span class="s2">&quot;YY&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">input_pol</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input must contain both &#39;XX&#39; and &#39;YY&#39; polarisations.&quot;</span><span class="p">)</span>

        <span class="n">ixx</span> <span class="o">=</span> <span class="n">input_pol</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;XX&quot;</span><span class="p">)</span>
        <span class="n">iyy</span> <span class="o">=</span> <span class="n">input_pol</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;YY&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">iyy</span> <span class="o">&gt;</span> <span class="n">ixx</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">ixx</span>
            <span class="n">stride</span> <span class="o">=</span> <span class="n">iyy</span> <span class="o">-</span> <span class="n">ixx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">iyy</span>
            <span class="n">stride</span> <span class="o">=</span> <span class="n">ixx</span> <span class="o">-</span> <span class="n">iyy</span>

        <span class="n">pol_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">stride</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">stride</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">make_pol_slice</span><span class="p">(</span><span class="n">axis_names</span><span class="p">):</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">axis_names</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;pol&quot;</span><span class="p">)</span>
            <span class="n">slc</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="n">axis</span> <span class="o">+</span> <span class="p">(</span><span class="n">pol_slice</span><span class="p">,)</span>
            <span class="k">return</span> <span class="n">axis</span><span class="p">,</span> <span class="n">slc</span>

        <span class="c1"># Create output container</span>
        <span class="n">outcont</span> <span class="o">=</span> <span class="n">empty_like</span><span class="p">(</span><span class="n">polcont</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s2">&quot;I&quot;</span><span class="p">]))</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">polcont</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">outcont</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
                <span class="n">outcont</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="n">polcont</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
        <span class="n">outcont</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Extract the weights dataset for the XX and YY polarisation.</span>
        <span class="c1"># Save their sum to the output container.</span>
        <span class="n">waxis</span> <span class="o">=</span> <span class="n">polcont</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span>
        <span class="n">wpax</span><span class="p">,</span> <span class="n">wslc</span> <span class="o">=</span> <span class="n">make_pol_slice</span><span class="p">(</span><span class="n">waxis</span><span class="p">)</span>

        <span class="n">weight</span> <span class="o">=</span> <span class="n">polcont</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="n">wslc</span><span class="p">]</span>
        <span class="n">outcont</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">wpax</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">outcont</span><span class="o">.</span><span class="n">weight</span><span class="p">[:])</span>

        <span class="c1"># Loop over all other datasets</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">dset</span> <span class="ow">in</span> <span class="n">polcont</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Already dealt with weights</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="n">polcont</span><span class="o">.</span><span class="n">_weight_dset_name</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># If the dataset does not have a pol axis, then just</span>
            <span class="c1"># copy it over directly and continue.</span>
            <span class="k">if</span> <span class="s2">&quot;pol&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]:</span>
                <span class="n">outcont</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="n">name</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[:]</span>
                <span class="k">continue</span>

            <span class="c1"># Make the weights broadcastable against this dataset</span>
            <span class="n">pax</span><span class="p">,</span> <span class="n">dslc</span> <span class="o">=</span> <span class="n">make_pol_slice</span><span class="p">(</span><span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span>
            <span class="n">wexp</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">broadcast_weights</span><span class="p">(</span><span class="n">waxis</span><span class="p">,</span> <span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span>

            <span class="c1"># Take the weighted average</span>
            <span class="n">outcont</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="n">name</span><span class="p">][:]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight</span><span class="p">[</span><span class="n">wexp</span><span class="p">]</span> <span class="o">*</span> <span class="n">dset</span><span class="p">[</span><span class="n">dslc</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">pax</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="n">norm</span><span class="p">[</span><span class="n">wexp</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">outcont</span></div>
</div>



<div class="viewcode-block" id="StokesIVis">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.StokesIVis">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">StokesIVis</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract instrumental Stokes I from visibilities.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="StokesIVis.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.StokesIVis.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">telescope</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the local observers.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        telescope : :class:`~caput.astro.observer.Observer`</span>
<span class="sd">            An Observer object holding the geographic location of the telescope.</span>
<span class="sd">            Note that :class:`~drift.core.TransitTelescope` instances are also</span>
<span class="sd">            Observers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">get_telescope</span><span class="p">(</span><span class="n">telescope</span><span class="p">)</span></div>


<div class="viewcode-block" id="StokesIVis.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.StokesIVis.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract instrumental Stokes I.</span>

<span class="sd">        This process will reduce the length of the baseline axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : containers.VisContainer</span>
<span class="sd">            Container with visibilities and baselines matching</span>
<span class="sd">            the telescope object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : containers.VisContainer</span>
<span class="sd">            Container with the same type as `data`, with polarised</span>
<span class="sd">            baselines combined into Stokes I.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Get stokes I</span>
        <span class="n">vis</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">baselines</span> <span class="o">=</span> <span class="n">stokes_I</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="p">)</span>

        <span class="c1"># Make the output container</span>
        <span class="c1"># TODO: the axes for this container should probably</span>
        <span class="c1"># be adjusted to make more sense</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">empty_like</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">stack</span><span class="o">=</span><span class="n">baselines</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">out</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">vis</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">weight</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>
</div>



<div class="viewcode-block" id="stokes_I">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.stokes_I">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">stokes_I</span><span class="p">(</span><span class="n">sstream</span><span class="p">,</span> <span class="n">tel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract instrumental Stokes I from a time/sidereal stream.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sstream : containers.SiderealStream, container.TimeStream</span>
<span class="sd">        Stream of correlation data.</span>
<span class="sd">    tel : TransitTelescope</span>
<span class="sd">        Instance describing the telescope.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vis_I : mpiarray.MPIArray[nfreq, nbase, ntime]</span>
<span class="sd">        The instrumental Stokes I visibilities, distributed over baselines.</span>
<span class="sd">    vis_weight : mpiarray.MPIArray[nfreq, nbase, ntime]</span>
<span class="sd">        The weights for each visibility, distributed over baselines.</span>
<span class="sd">    ubase : np.ndarray[nbase, 2]</span>
<span class="sd">        Baseline vectors corresponding to output.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make sure the data is distributed in a reasonable way</span>
    <span class="n">sstream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
    <span class="c1"># Construct a complex number representing each baseline (used for determining</span>
    <span class="c1"># unique baselines).</span>
    <span class="c1"># Due to floating point precision, some baselines don&#39;t get matched as having</span>
    <span class="c1"># the same lengths. To get around this, round all separations to 0.1 mm precision</span>
    <span class="n">bl_round</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">tel</span><span class="o">.</span><span class="n">baselines</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">tel</span><span class="o">.</span><span class="n">baselines</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">)</span>

    <span class="c1"># Map unique baseline lengths to each polarisation pair</span>
    <span class="n">ubase</span><span class="p">,</span> <span class="n">uinv</span><span class="p">,</span> <span class="n">ucount</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">bl_round</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ubase</span> <span class="o">=</span> <span class="n">ubase</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Construct the output arrays</span>
    <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">sstream</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">global_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">ubase</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">sstream</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">global_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="n">vis_I</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">new_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sstream</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">vis_weight</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">new_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sstream</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Find co-pol baselines (XX and YY)</span>
    <span class="n">pairs</span> <span class="o">=</span> <span class="n">tel</span><span class="o">.</span><span class="n">uniquepairs</span>
    <span class="n">pols</span> <span class="o">=</span> <span class="n">tel</span><span class="o">.</span><span class="n">polarisation</span><span class="p">[</span><span class="n">pairs</span><span class="p">]</span>
    <span class="n">is_copol</span> <span class="o">=</span> <span class="n">pols</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">pols</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Iterate over products to construct the Stokes I vis</span>
    <span class="n">ssv</span> <span class="o">=</span> <span class="n">sstream</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
    <span class="n">ssw</span> <span class="o">=</span> <span class="n">sstream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ui</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">uinv</span><span class="p">):</span>
        <span class="c1"># Skip if not a co-pol baseline</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_copol</span><span class="p">[</span><span class="n">ii</span><span class="p">]:</span>
            <span class="k">continue</span>

        <span class="c1"># Skip if not all polarisations are included</span>
        <span class="k">if</span> <span class="n">ucount</span><span class="p">[</span><span class="n">ui</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Skip if there&#39;s a bad feed</span>
        <span class="k">if</span> <span class="n">tel</span><span class="o">.</span><span class="n">feedmap</span><span class="p">[(</span><span class="o">*</span><span class="n">pairs</span><span class="p">[</span><span class="n">ii</span><span class="p">],)]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Accumulate the visibilities and weights</span>
        <span class="n">vis_I</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:,</span> <span class="n">ui</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ssv</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">]</span>
        <span class="n">vis_weight</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:,</span> <span class="n">ui</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ssw</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">vis_I</span><span class="p">,</span> <span class="n">vis_weight</span><span class="p">,</span> <span class="n">ubase</span></div>



<div class="viewcode-block" id="TransformJanskyToKelvin">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.TransformJanskyToKelvin">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">TransformJanskyToKelvin</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Task to convert from Jy to Kelvin and vice-versa.</span>

<span class="sd">    This integrates over the primary beams in the telescope class to derive the</span>
<span class="sd">    brightness temperature to flux conversion.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    convert_Jy_to_K : bool</span>
<span class="sd">        If True, apply a Jansky to Kelvin conversion factor. If False apply a Kelvin to</span>
<span class="sd">        Jansky conversion.</span>
<span class="sd">    reference_declination : float, optional</span>
<span class="sd">        The declination to set the flux reference for. A source transiting at this</span>
<span class="sd">        declination will produce a visibility signal equal to its flux. If `None`</span>
<span class="sd">        (default) use the zenith.</span>
<span class="sd">    share : {&quot;none&quot;, &quot;all&quot;}</span>
<span class="sd">        Which datasets should the output share with the input. Default is &quot;all&quot;.</span>
<span class="sd">    nside : int</span>
<span class="sd">        The NSIDE to use for the primary beam area calculation. This may need to be</span>
<span class="sd">        increased for beams with intricate small scale structure. Default is 256.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">convert_Jy_to_K</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">reference_declination</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">share</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">enum</span><span class="p">([</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>

    <span class="n">nside</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">256</span><span class="p">)</span>

<div class="viewcode-block" id="TransformJanskyToKelvin.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.TransformJanskyToKelvin.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">telescope</span><span class="p">:</span> <span class="n">io</span><span class="o">.</span><span class="n">TelescopeConvertible</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the telescope object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        telescope</span>
<span class="sd">            An object we can get a telescope object from. This telescope must be able to</span>
<span class="sd">            calculate the beams at all incoming frequencies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">get_telescope</span><span class="p">(</span><span class="n">telescope</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">_init_trans</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">)</span>

        <span class="c1"># If not explicitly set, use the zenith as the reference declination</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_declination</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference_declination</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">latitude</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_omega_cache</span> <span class="o">=</span> <span class="p">{}</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_beam_area</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feed</span><span class="p">,</span> <span class="n">freq</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the primary beam solid angle.&quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">healpy</span>

        <span class="n">beam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">beam</span><span class="p">(</span><span class="n">feed</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>
        <span class="n">horizon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">_horizon</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">beam_pow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">horizon</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">pxarea</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">beam</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="n">beam_pow</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="n">pxarea</span>

        <span class="c1"># Normalise omega by the squared magnitude of the beam at the reference position</span>
        <span class="c1"># NOTE: this is slightly less accurate than the previous approach of reseting</span>
        <span class="c1"># the internal `_angpos` property to force evaluation of the beam at the exact</span>
        <span class="c1"># coordinates, but is more generically applicable, and works (for instance) with</span>
        <span class="c1"># the CHIMEExternalBeam class.</span>
        <span class="c1">#</span>
        <span class="c1"># Also, for a reason I don&#39;t fully understand it&#39;s more accurate to use the</span>
        <span class="c1"># value of the pixel including the reference position, and not do an</span>
        <span class="c1"># interpolation using it&#39;s neighbours...</span>
        <span class="n">beam_ref</span> <span class="o">=</span> <span class="n">beam_pow</span><span class="p">[</span>
            <span class="n">healpy</span><span class="o">.</span><span class="n">ang2pix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_declination</span><span class="p">,</span> <span class="n">lonlat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">omega</span> <span class="o">*=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">beam_ref</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">omega</span>

<div class="viewcode-block" id="TransformJanskyToKelvin.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.TransformJanskyToKelvin.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sstream</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealStream</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealStream</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply the brightness temperature to flux conversion to the data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sstream</span>
<span class="sd">            The visibilities to apply the conversion to. They are converted to/from</span>
<span class="sd">            brightness temperature units depending on the setting of `convert_Jy_to_K`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_sstream</span>
<span class="sd">            Visibilities with the conversion applied. This may be the same as the input</span>
<span class="sd">            container if `share == &quot;all&quot;`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">scipy.constants</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">c</span>

        <span class="n">sstream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Get the local frequencies in the sidereal stream</span>
        <span class="n">sfreq</span> <span class="o">=</span> <span class="n">sstream</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">local_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">efreq</span> <span class="o">=</span> <span class="n">sfreq</span> <span class="o">+</span> <span class="n">sstream</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">local_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">local_freq</span> <span class="o">=</span> <span class="n">sstream</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="n">sfreq</span><span class="p">:</span><span class="n">efreq</span><span class="p">]</span>

        <span class="c1"># Get the indices of the incoming frequencies as far as the telescope class is</span>
        <span class="c1"># concerned</span>
        <span class="n">local_freq_inds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">local_freq</span><span class="p">:</span>
            <span class="n">local_freq_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">frequencies</span> <span class="o">-</span> <span class="n">freq</span><span class="p">)))</span>

        <span class="c1"># Get the feedpairs we have data for and their beamclass (usually this maps to</span>
        <span class="c1"># polarisation)</span>
        <span class="n">feedpairs</span> <span class="o">=</span> <span class="n">structured_to_unstructured</span><span class="p">(</span><span class="n">sstream</span><span class="o">.</span><span class="n">prodstack</span><span class="p">)</span>
        <span class="n">beamclass_pairs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">beamclass</span><span class="p">[</span><span class="n">feedpairs</span><span class="p">]</span>

        <span class="c1"># Calculate all the unique beams that we need to calculate areas for</span>
        <span class="n">unique_beamclass</span><span class="p">,</span> <span class="n">bc_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">beamclass_pairs</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Calculate any missing beam areas and to the cache</span>
        <span class="k">for</span> <span class="n">beamclass</span><span class="p">,</span> <span class="n">bc_ind</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">unique_beamclass</span><span class="p">,</span> <span class="n">bc_index</span><span class="p">):</span>
            <span class="n">feed_ind</span> <span class="o">=</span> <span class="n">feedpairs</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">bc_ind</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">freq</span><span class="p">,</span> <span class="n">freq_ind</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">local_freq</span><span class="p">,</span> <span class="n">local_freq_inds</span><span class="p">):</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">beamclass</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_omega_cache</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_omega_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beam_area</span><span class="p">(</span><span class="n">feed_ind</span><span class="p">,</span> <span class="n">freq_ind</span><span class="p">)</span>

        <span class="c1"># Loop over all frequencies and visibilities and get the effective primary</span>
        <span class="c1"># beam area for each</span>
        <span class="n">om_ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">local_freq</span><span class="p">),</span> <span class="n">sstream</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">fi</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">local_freq</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">bi</span><span class="p">,</span> <span class="p">(</span><span class="n">bci</span><span class="p">,</span> <span class="n">bcj</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">beamclass_pairs</span><span class="p">):</span>
                <span class="n">om_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_omega_cache</span><span class="p">[(</span><span class="n">bci</span><span class="p">,</span> <span class="n">freq</span><span class="p">)]</span>
                <span class="n">om_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_omega_cache</span><span class="p">[(</span><span class="n">bcj</span><span class="p">,</span> <span class="n">freq</span><span class="p">)]</span>
                <span class="n">om_ij</span><span class="p">[</span><span class="n">fi</span><span class="p">,</span> <span class="n">bi</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">om_i</span> <span class="o">*</span> <span class="n">om_j</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>

        <span class="c1"># Calculate the Jy to K conversion</span>
        <span class="n">wavelength</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span> <span class="p">(</span><span class="n">local_freq</span> <span class="o">*</span> <span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">))[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">K_to_Jy</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="mf">1e26</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">k</span> <span class="o">*</span> <span class="n">om_ij</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">/</span> <span class="n">wavelength</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">Jy_to_K</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">K_to_Jy</span><span class="p">)</span>

        <span class="c1"># Get the container we will apply the conversion to (either the input, or a</span>
        <span class="c1"># copy)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">share</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">new_stream</span> <span class="o">=</span> <span class="n">sstream</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># self.share == &quot;none&quot;</span>
            <span class="n">new_stream</span> <span class="o">=</span> <span class="n">sstream</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Apply the conversion to the data and the weights</span>
        <span class="n">vis</span> <span class="o">=</span> <span class="n">new_stream</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">new_stream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_Jy_to_K</span><span class="p">:</span>
            <span class="n">vis</span> <span class="o">*=</span> <span class="n">Jy_to_K</span>
            <span class="n">weight</span> <span class="o">*=</span> <span class="n">K_to_Jy</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vis</span> <span class="o">*=</span> <span class="n">K_to_Jy</span>
            <span class="n">weight</span> <span class="o">*=</span> <span class="n">Jy_to_K</span><span class="o">**</span><span class="mi">2</span>

        <span class="k">return</span> <span class="n">new_stream</span></div>
</div>



<div class="viewcode-block" id="MixData">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.MixData">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MixData</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mix together pieces of data with specified weights.</span>

<span class="sd">    This can generate arbitrary linear combinations of the data and weights for both</span>
<span class="sd">    `SiderealStream` and `RingMap` objects, and can be used for many purposes such as:</span>
<span class="sd">    adding together simulated timestreams, injecting signal into data, replacing weights</span>
<span class="sd">    in simulated data with those from real data, performing jackknifes, etc.</span>

<span class="sd">    All coefficients are applied naively to generate the final combinations, i.e. no</span>
<span class="sd">    normalisations or weighted summation is performed.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    data_coeff : list</span>
<span class="sd">        A list of coefficients to apply to the data dataset of each input container to</span>
<span class="sd">        produce the final output. These are applied to either the `vis` or `map` dataset</span>
<span class="sd">        depending on the the type of the input container.</span>
<span class="sd">    weight_coeff : list</span>
<span class="sd">        Coefficient to be applied to each input containers weights to generate the</span>
<span class="sd">        output.</span>
<span class="sd">    tag_coeff : list</span>
<span class="sd">        Boolean array indicating which input containers tags should be used to generate</span>
<span class="sd">        the output tag.</span>
<span class="sd">    aux_coeff : dict</span>
<span class="sd">        Coefficients to be applied to auxiliary datasets in the input container to</span>
<span class="sd">        generate the output.  This should be a dictionary where each key is the name</span>
<span class="sd">        of a dataset in the input container, and the corresponding value is a list</span>
<span class="sd">        of coefficients used to mix.</span>
<span class="sd">    invert_weight : bool</span>
<span class="sd">        Invert the weights to convert to variance prior to mixing.  Re-invert in the</span>
<span class="sd">        final mixed data product to convert back to inverse variance.</span>
<span class="sd">    require_nonzero_weight : bool</span>
<span class="sd">        Set the weight to zero in the mixed data if the weight is zero in any of the</span>
<span class="sd">        input data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data_coeff</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">list_type</span><span class="p">(</span><span class="n">type_</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">weight_coeff</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">list_type</span><span class="p">(</span><span class="n">type_</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">tag_coeff</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">list_type</span><span class="p">(</span><span class="n">type_</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">aux_coeff</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">dict</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">{})</span>
    <span class="n">invert_weight</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">require_nonzero_weight</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">mixed_data</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="MixData.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.MixData.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check the lists have the same length.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_coeff</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight_coeff</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">config</span><span class="o">.</span><span class="n">CaputConfigError</span><span class="p">(</span>
                <span class="s2">&quot;data and weight coefficient lists must be the same length&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_data_ind</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wfunc</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">invert_weight</span> <span class="k">else</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span></div>


<div class="viewcode-block" id="MixData.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.MixData.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="p">(</span>
            <span class="n">containers</span><span class="o">.</span><span class="n">SiderealStream</span> <span class="o">|</span> <span class="n">containers</span><span class="o">.</span><span class="n">HybridVisStream</span> <span class="o">|</span> <span class="n">containers</span><span class="o">.</span><span class="n">RingMap</span>
        <span class="p">),</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add the input data into the mixed data output.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data</span>
<span class="sd">            The data to be added into the mix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_ind</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_coeff</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;This task cannot accept more items than there are coefficents set.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mixed_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mixed_data</span> <span class="o">=</span> <span class="n">empty_like</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

            <span class="c1"># If requested, add auxiliary datasets</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_coeff</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mixed_data</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mixed_data</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mixed_data</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="n">key</span><span class="p">][:]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="c1"># Redistribute over frequency</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mixed_data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

            <span class="c1"># Zero out data and weights</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mixed_data</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mixed_data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_nonzero_weight</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_flag</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mixed_data</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mixed_data</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">distributed_axis</span><span class="p">,</span>
                    <span class="n">comm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mixed_data</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="c1"># Validate the types are the same</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mixed_data</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;type(data) (=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">) must match &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;type(data_stack) (=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Validate the shapes match</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mixed_data</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Size of data (</span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">) must match &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;data_stack (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mixed_data</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mixed_data</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Size of data (</span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">) must match &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;data_stack (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mixed_data</span><span class="o">.</span><span class="n">weightshape</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Mix in the data and weights</span>
        <span class="n">dco</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_coeff</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_ind</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">dco</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mixed_data</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">dco</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span>

        <span class="n">wco</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_coeff</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_ind</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">wco</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mixed_data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">wco</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wfunc</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:])</span>

            <span class="c1"># Update the flag</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_nonzero_weight</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_flag</span> <span class="o">&amp;=</span> <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">&gt;</span> <span class="mf">0.0</span>

        <span class="c1"># Deal with auxiliary datasets</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">aux_coeff</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux_coeff</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">aco</span> <span class="o">=</span> <span class="n">aux_coeff</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_ind</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">aco</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mixed_data</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="n">key</span><span class="p">][:]</span> <span class="o">+=</span> <span class="n">aco</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="n">key</span><span class="p">][:]</span>

        <span class="c1"># Save the tags</span>
        <span class="k">if</span> <span class="s2">&quot;tag&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tag_coeff</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag_coeff</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_ind</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_data_ind</span> <span class="o">+=</span> <span class="mi">1</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_make_output</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealStream</span> <span class="o">|</span> <span class="n">containers</span><span class="o">.</span><span class="n">HybridVisStream</span> <span class="o">|</span> <span class="n">containers</span><span class="o">.</span><span class="n">RingMap</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the container with the mixed inputs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mixed_data</span>
<span class="sd">            The mixed data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_ind</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_coeff</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Did not receive enough inputs. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_ind</span><span class="si">}</span><span class="s2">, expected </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_coeff</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Get an ephemeral reference to the mixed data and remove the task reference so</span>
        <span class="c1"># the object can be eventually deleted</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mixed_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mixed_data</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Apply the logical AND of all flags</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_nonzero_weight</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flag</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flag</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Convert back to inverse variance</span>
        <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wfunc</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:])</span>

        <span class="c1"># Combine the tags</span>
        <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tags</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span>

<div class="viewcode-block" id="MixData.process_finish">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.MixData.process_finish">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process_finish</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealStream</span> <span class="o">|</span> <span class="n">containers</span><span class="o">.</span><span class="n">HybridVisStream</span> <span class="o">|</span> <span class="n">containers</span><span class="o">.</span><span class="n">RingMap</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the container with the mixed inputs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mixed_data</span>
<span class="sd">            The mixed data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_output</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="Jackknife">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.Jackknife">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Jackknife</span><span class="p">(</span><span class="n">MixData</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform a jackknife of two datasets.</span>

<span class="sd">    This is identical to MixData but sets the default config properties</span>
<span class="sd">    to values appropriate for carrying out a jackknife of two datasets.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data_coeff</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">list_type</span><span class="p">(</span><span class="n">type_</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">])</span>
    <span class="n">weight_coeff</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">list_type</span><span class="p">(</span><span class="n">type_</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">])</span>
    <span class="n">tag_coeff</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">list_type</span><span class="p">(</span><span class="n">type_</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>
    <span class="n">invert_weight</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">require_nonzero_weight</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>



<div class="viewcode-block" id="MixTwoDatasets">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.MixTwoDatasets">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MixTwoDatasets</span><span class="p">(</span><span class="n">MixData</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mix two datasets in a single iteration.&quot;&quot;&quot;</span>

    <span class="n">data_coeff</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">list_type</span><span class="p">(</span><span class="n">type_</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">weight_coeff</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">list_type</span><span class="p">(</span><span class="n">type_</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">tag_coeff</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">list_type</span><span class="p">(</span><span class="n">type_</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<div class="viewcode-block" id="MixTwoDatasets.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.MixTwoDatasets.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Combine the two datasets into mixed data output.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data1 : containers.SiderealStream | containers.RingMap</span>
<span class="sd">            First dataset to mix</span>
<span class="sd">        data2 : containers.SiderealStream | containers.RingMap</span>
<span class="sd">            Second dataset to mix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Combine the two datasets</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">data1</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">data2</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_output</span><span class="p">()</span>

        <span class="c1"># Reset data counter and tags</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_ind</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tags</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="MixTwoDatasets.process_finish">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.MixTwoDatasets.process_finish">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process_finish</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overwrite `process_finish` to no-op.&quot;&quot;&quot;</span>
        <span class="k">return</span></div>
</div>



<div class="viewcode-block" id="Downselect">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.Downselect">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Downselect</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">SelectionsMixin</span><span class="p">,</span> <span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply axis selections to a container.</span>

<span class="sd">    Apply slice or `np.take` operations across multiple axes of a container.</span>
<span class="sd">    The selections are applied to every dataset.</span>

<span class="sd">    If a dataset is distributed, there must be at least one axis not included</span>
<span class="sd">    in the selections.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Downselect.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.Downselect.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">ContainerPrototype</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ContainerPrototype</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply downselections to the container.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data</span>
<span class="sd">            Container to process</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out</span>
<span class="sd">            Container of same type as the input with specific axis selections.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sel</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Parse axes with selections and reformat to use only</span>
        <span class="c1"># the axis name</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">selections</span><span class="p">:</span>
            <span class="o">*</span><span class="n">axis</span><span class="p">,</span> <span class="n">type_</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
            <span class="n">axis_name</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

            <span class="n">ax_sel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sel</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">axis_name</span><span class="si">}</span><span class="s2">_sel&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">type_</span> <span class="o">==</span> <span class="s2">&quot;map&quot;</span><span class="p">:</span>
                <span class="c1"># Use index map to get the correct axis indices</span>
                <span class="n">imap</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="n">axis_name</span><span class="p">])</span>
                <span class="n">ax_sel</span> <span class="o">=</span> <span class="p">[</span><span class="n">imap</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ax_sel</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">ax_sel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sel</span><span class="p">[</span><span class="n">axis_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">ax_sel</span>

        <span class="c1"># Figure out the axes for the new container and</span>
        <span class="c1"># Apply the downselections to each axis index_map</span>
        <span class="n">output_axes</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">ax</span><span class="p">:</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">_apply_sel</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="n">ax</span><span class="p">],</span> <span class="n">ax_sel</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">ax_sel</span> <span class="ow">in</span> <span class="n">sel</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="c1"># Create the output container without initializing any datasets.</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">axes_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">attrs_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">skip_datasets</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">output_axes</span>
        <span class="p">)</span>
        <span class="n">copy_datasets_filter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">selection</span><span class="o">=</span><span class="n">sel</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>
</div>



<div class="viewcode-block" id="ReduceBase">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.ReduceBase">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ReduceBase</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply a weighted reduction operation across specific axes.</span>

<span class="sd">    This is non-functional without overriding the `reduction` method.</span>

<span class="sd">    There must be at least one axis not included in the reduction.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    axes : list</span>
<span class="sd">        Axis names to apply the reduction to</span>
<span class="sd">    dataset : str</span>
<span class="sd">        Dataset name to reduce.</span>
<span class="sd">    weighting : str</span>
<span class="sd">        Which type of weighting to use, if applicable. Options are &quot;none&quot;,</span>
<span class="sd">        &quot;masked&quot;, or &quot;weighted&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">axes</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
    <span class="n">weighting</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">enum</span><span class="p">([</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;masked&quot;</span><span class="p">,</span> <span class="s2">&quot;weighted&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">)</span>

    <span class="n">_op</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="ReduceBase.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.ReduceBase.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">ContainerPrototype</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ContainerPrototype</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Downselect and apply the reduction operation to the data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data</span>
<span class="sd">            Dataset to process.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out</span>
<span class="sd">            Dataset of same type as input with axes reduced. Any datasets</span>
<span class="sd">            which are not included in the reduction list will not be initialized,</span>
<span class="sd">            other than weights.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_output_container</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">)</span>

        <span class="c1"># Get the dataset</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">]</span>
        <span class="n">original_ax_id</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">distributed_axis</span>

        <span class="c1"># Get the axis indices to apply the operation over</span>
        <span class="n">ds_axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span>

        <span class="c1"># Get the new axis to distribute over</span>
        <span class="k">if</span> <span class="n">ds_axes</span><span class="p">[</span><span class="n">original_ax_id</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
            <span class="n">new_ax_id</span> <span class="o">=</span> <span class="n">original_ax_id</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax_priority</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">x</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">ds_axes</span><span class="p">))</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ax_priority</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Could not find a valid axis to redistribute. At least one &quot;</span>
                    <span class="s2">&quot;axis must be omitted from filtering.&quot;</span>
                <span class="p">)</span>
            <span class="c1"># Get the longest axis</span>
            <span class="n">new_ax_id</span> <span class="o">=</span> <span class="n">ds_axes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ax_priority</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">new_ax_name</span> <span class="o">=</span> <span class="n">ds_axes</span><span class="p">[</span><span class="n">new_ax_id</span><span class="p">]</span>

        <span class="c1"># Redistribute the dataset to the target axis</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="n">new_ax_id</span><span class="p">)</span>
        <span class="c1"># Redistribute the output container (group) to the target axis</span>
        <span class="c1"># Since this is a container, distribute based on axis name</span>
        <span class="c1"># rather than index</span>
        <span class="n">out</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="n">new_ax_name</span><span class="p">)</span>

        <span class="c1"># Get the weights</span>
        <span class="n">weight</span><span class="p">,</span> <span class="n">w_axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_weights</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># The weights should be distributed over the same axis as the array,</span>
            <span class="c1"># even if they don&#39;t share all the same axes</span>
            <span class="n">new_weight_ax</span> <span class="o">=</span> <span class="n">w_axes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">new_ax_name</span><span class="p">)</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">weight</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="n">new_weight_ax</span><span class="p">)</span>
            <span class="c1"># Insert a size 1 axis for each missing axis in the weights</span>
            <span class="n">wslc</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">w_axes</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">ds_axes</span><span class="p">]</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">weight</span><span class="o">.</span><span class="n">local_array</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">wslc</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ds</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">wslc</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Apply the reduction, ensuring that the weights have the correct dimension</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">ds</span><span class="o">.</span><span class="n">local_shape</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">apply_over</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">ds_axes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">ds_axes</span><span class="p">])</span>

        <span class="n">reduced</span><span class="p">,</span> <span class="n">reduced_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span><span class="p">(</span>
            <span class="n">ds</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:],</span> <span class="n">weight</span><span class="p">,</span> <span class="n">apply_over</span>
        <span class="p">)</span>

        <span class="c1"># Add the reduced data and redistribute the container back to the</span>
        <span class="c1"># original axis</span>
        <span class="n">out</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">reduced</span><span class="p">[:]</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;weight&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">wslc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">reduced_weight</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">owslc</span> <span class="o">=</span> <span class="p">[</span><span class="n">ws</span> <span class="k">if</span> <span class="n">ws</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">ws</span> <span class="ow">in</span> <span class="n">wslc</span><span class="p">]</span>
                <span class="n">out</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">reduced_weight</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">owslc</span><span class="p">)]</span>

        <span class="c1"># Redistribute bcak to the original axis, again using the axis name</span>
        <span class="n">out</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="n">ds_axes</span><span class="p">[</span><span class="n">original_ax_id</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">out</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">ContainerPrototype</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">list</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the weights to use for the reduction.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;weight&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span> <span class="o">!=</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;No weights available. Cannot use weighted or masked weighting.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;weight&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:],</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span>

        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_make_output_container</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">ContainerPrototype</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ContainerPrototype</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the output container.&quot;&quot;&quot;</span>
        <span class="c1"># For a collapsed axis, the meaning of the index map will depend on</span>
        <span class="c1"># the reduction being done, and can be meaningless. The first value</span>
        <span class="c1"># of the relevant index map is chosen as the default to provide</span>
        <span class="c1"># some meaning to the index map regardless of the reduction operation</span>
        <span class="c1"># or reduction axis involved</span>
        <span class="n">output_axes</span> <span class="o">=</span> <span class="p">{</span><span class="n">ax</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="n">ax</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">}</span>

        <span class="c1"># Create the output container without initializing any datasets.</span>
        <span class="c1"># Add some extra metadata about which axes were reduced and which</span>
        <span class="c1"># datasets are meaningful</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">axes_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">attrs_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">skip_datasets</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">output_axes</span>
        <span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;reduced&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">out</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;reduction_axes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;reduced_dataset&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span>
        <span class="n">out</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;reduction_op&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op</span>

        <span class="c1"># Initialize the weight dataset</span>
        <span class="k">if</span> <span class="s2">&quot;weight&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;vis_weight&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;vis_weight&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>

<div class="viewcode-block" id="ReduceBase.reduction">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.ReduceBase.reduction">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reduction</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">weight</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">tuple</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overwrite to implement the reductino operation.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>
</div>



<div class="viewcode-block" id="ReduceVar">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.ReduceVar">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ReduceVar</span><span class="p">(</span><span class="n">ReduceBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Take the weighted variance of a container.&quot;&quot;&quot;</span>

    <span class="n">_op</span> <span class="o">=</span> <span class="s2">&quot;variance&quot;</span>

<div class="viewcode-block" id="ReduceVar.reduction">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.ReduceVar.reduction">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reduction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply a weighted variance.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span> <span class="o">==</span> <span class="s2">&quot;masked&quot;</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="p">(</span><span class="n">weight</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">weight</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Calculate the inverted sum of the weights. This is used</span>
        <span class="c1"># more than once</span>
        <span class="n">ws</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">iws</span> <span class="o">=</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">ws</span><span class="p">)</span>
        <span class="c1"># Get the weighted mean</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight</span> <span class="o">*</span> <span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="n">iws</span>
        <span class="c1"># Get the weighted variance</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight</span> <span class="o">*</span> <span class="p">(</span><span class="n">arr</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="n">iws</span>

        <span class="k">return</span> <span class="n">v</span><span class="p">,</span> <span class="n">ws</span></div>
</div>



<div class="viewcode-block" id="ReduceChisq">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.ReduceChisq">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ReduceChisq</span><span class="p">(</span><span class="n">ReduceBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the chi-squared per degree of freedom.</span>

<span class="sd">    Assumes that the visibilities are uncorrelated noise</span>
<span class="sd">    whose inverse variance is given by the weight dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_op</span> <span class="o">=</span> <span class="s2">&quot;chisq_per_dof&quot;</span>

<div class="viewcode-block" id="ReduceChisq.reduction">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.ReduceChisq.reduction">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reduction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply a chi-squared calculation.&quot;&quot;&quot;</span>
        <span class="c1"># Get the total number of unmasked samples</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Calculate the inverted sum of the weights</span>
        <span class="n">iws</span> <span class="o">=</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="c1"># Get the weighted mean</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight</span> <span class="o">*</span> <span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="n">iws</span>

        <span class="c1"># Get the chi-squared per degree of freedom</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">weight</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">arr</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">v</span><span class="p">,</span> <span class="n">num</span></div>
</div>



<span class="k">class</span><span class="w"> </span><span class="nc">_InverseStackRedundancyWeights</span><span class="p">(</span><span class="n">ReduceBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Weights to undo the effect of redundancy averaging.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate baseline redundancy and return the inverse.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;stack&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;No &#39;stack&#39; axis in index map. Cannot calculate weights.&quot;</span>
            <span class="p">)</span>

        <span class="n">redundancy</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">calculate_redundancy</span><span class="p">(</span>
            <span class="n">data</span><span class="o">.</span><span class="n">input_flags</span><span class="p">[:],</span>
            <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">][:],</span>
            <span class="n">data</span><span class="o">.</span><span class="n">reverse_map</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">][</span><span class="s2">&quot;stack&quot;</span><span class="p">][:],</span>
            <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">][:]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">weight</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">redundancy</span><span class="o">**</span><span class="mi">2</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">weight</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span>


<div class="viewcode-block" id="ReduceChisqInverseRedundancy">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.ReduceChisqInverseRedundancy">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ReduceChisqInverseRedundancy</span><span class="p">(</span><span class="n">ReduceChisq</span><span class="p">,</span> <span class="n">_InverseStackRedundancyWeights</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the chi-squared per degree of freedom, undoing redundancy averaging.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="HPFTimeStream">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.HPFTimeStream">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">HPFTimeStream</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;High pass filter a timestream.</span>

<span class="sd">    This is done by solving for a low-pass filtered version of the timestream and then</span>
<span class="sd">    subtracting it from the original.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tau</span>
<span class="sd">        Timescale in seconds to filter out fluctuations below.</span>
<span class="sd">    pad</span>
<span class="sd">        Implicitly pad the timestream with this many multiples of tau worth of zeros.</span>
<span class="sd">        This is used to mitigate edge effects. The default is 2.</span>
<span class="sd">    window</span>
<span class="sd">        Use a Blackman window when determining the low-pass filtered timestream. When</span>
<span class="sd">        applied this approximately doubles the length of the timescale, which is only</span>
<span class="sd">        crudely corrected for.</span>
<span class="sd">    prior</span>
<span class="sd">        This should be approximately the size of the large scale fluctuations that we</span>
<span class="sd">        will use as a regulariser.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tau</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">pad</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">prior</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1e2</span><span class="p">)</span>

<div class="viewcode-block" id="HPFTimeStream.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.transform.html#draco.analysis.transform.HPFTimeStream.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tstream</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">TODContainer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">TODContainer</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;High pass filter a time stream.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tstream</span>
<span class="sd">            A TOD container that also implements DataWeightContainer.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filtered_tstream</span>
<span class="sd">            The high-pass filtered time stream.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tstream</span><span class="p">,</span> <span class="n">containers</span><span class="o">.</span><span class="n">DataWeightContainer</span><span class="p">):</span>
            <span class="c1"># NOTE: no python intersection type so need to do this for now</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Need a DataWeightContainers&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="o">!=</span> <span class="n">tstream</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;time&#39; is not the last axis of the dataset.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tstream</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">tstream</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data and weights must have the same shape.&quot;</span><span class="p">)</span>

        <span class="c1"># Distribute over the first axis</span>
        <span class="n">tstream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="n">tstream</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">tau</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span>

        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">tstream</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Samples are not regularly spaced. This might not work super well.&quot;</span>
            <span class="p">)</span>

        <span class="n">total_T</span> <span class="o">=</span> <span class="n">tstream</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">tstream</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">tau</span>

        <span class="c1"># Calculate the nearest integer multiple of modes based on the total length and</span>
        <span class="c1"># the timescale</span>
        <span class="n">nmodes</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">total_T</span> <span class="o">/</span> <span class="n">tau</span><span class="p">))</span>

        <span class="c1"># Calculate the conjugate fourier frequencies to use, we don&#39;t need to be in the</span>
        <span class="c1"># canonical order as we&#39;re going to calculate this exactly via matrices</span>
        <span class="n">t_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">nmodes</span><span class="p">,</span> <span class="n">nmodes</span><span class="p">)</span> <span class="o">/</span> <span class="n">total_T</span>

        <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">2.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">tstream</span><span class="o">.</span><span class="n">time</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">t_freq</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">:</span>
            <span class="n">F</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">blackman</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nmodes</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">Fh</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">dflat</span> <span class="o">=</span> <span class="n">tstream</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tstream</span><span class="o">.</span><span class="n">time</span><span class="p">))</span>
        <span class="n">wflat</span> <span class="o">=</span> <span class="n">tstream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tstream</span><span class="o">.</span><span class="n">time</span><span class="p">))</span>

        <span class="n">Si</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nmodes</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="o">**-</span><span class="mi">2</span>

        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dflat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">d</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">dflat</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">wflat</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

            <span class="n">wsum</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">wsum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span> <span class="o">/</span> <span class="n">wsum</span>

            <span class="c1"># dirty = Fh @ ((d - m) * w)</span>
            <span class="c1"># Ci = Fh @ (w[:, np.newaxis] * F)</span>
            <span class="n">d</span> <span class="o">-=</span> <span class="n">m</span>
            <span class="n">dirty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Fh</span><span class="p">,</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="n">w</span><span class="p">))</span>
            <span class="n">Ci</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Fh</span><span class="p">,</span> <span class="n">w</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">F</span><span class="p">)</span>
            <span class="n">Ci</span> <span class="o">+=</span> <span class="n">Si</span>

            <span class="n">f_lpf</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">Ci</span><span class="p">,</span> <span class="n">dirty</span><span class="p">,</span> <span class="n">assume_a</span><span class="o">=</span><span class="s2">&quot;pos&quot;</span><span class="p">)</span>

            <span class="c1"># As we know the result will be real, split up the matrix multiplication to</span>
            <span class="c1"># guarantee this</span>
            <span class="n">t_lpf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">f_lpf</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">f_lpf</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">-=</span> <span class="n">t_lpf</span>

        <span class="k">return</span> <span class="n">tstream</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016, Richard Shaw.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>