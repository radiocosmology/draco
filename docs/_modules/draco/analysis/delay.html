

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>draco.analysis.delay &mdash; draco 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=9edc463e" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            draco
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev.html">Development Guidelines</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">draco</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">draco.analysis.delay</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for draco.analysis.delay</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Delay space spectrum estimation and filtering.&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypeVar</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.linalg</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">la</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">caput</span><span class="w"> </span><span class="kn">import</span> <span class="n">config</span><span class="p">,</span> <span class="n">memdata</span><span class="p">,</span> <span class="n">mpiarray</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">caput.algorithms</span><span class="w"> </span><span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">random</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">caput.astro</span><span class="w"> </span><span class="kn">import</span> <span class="n">constants</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">caput.containers</span><span class="w"> </span><span class="kn">import</span> <span class="n">ContainerPrototype</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">caput.pipeline</span><span class="w"> </span><span class="kn">import</span> <span class="n">tasklib</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy.lib.recfunctions</span><span class="w"> </span><span class="kn">import</span> <span class="n">structured_to_unstructured</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">..core</span><span class="w"> </span><span class="kn">import</span> <span class="n">containers</span><span class="p">,</span> <span class="n">io</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..util</span><span class="w"> </span><span class="kn">import</span> <span class="n">filters</span><span class="p">,</span> <span class="n">tools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.delayopt</span><span class="w"> </span><span class="kn">import</span> <span class="n">delay_power_spectrum_maxpost</span>

<span class="c1"># A specific subclass of a FreqContainer</span>
<span class="n">FreqContainerType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;FreqContainerType&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">containers</span><span class="o">.</span><span class="n">FreqContainer</span><span class="p">)</span>


<span class="c1"># ---------------------</span>
<span class="c1"># Delay Filter Classes</span>
<span class="c1"># ---------------------</span>


<div class="viewcode-block" id="DelayFilter">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.DelayFilter">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DelayFilter</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Remove delays less than a given threshold.</span>

<span class="sd">    This is performed by projecting the data onto the null space that is orthogonal</span>
<span class="sd">    to any mode at low delays.</span>

<span class="sd">    Note that for this task to work best the zero entries in the weights dataset</span>
<span class="sd">    should factorize in frequency-time for each baseline. A mostly optimal masking</span>
<span class="sd">    can be generated using the `draco.analysis.flagging.MaskFreq` task.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    delay_cut : float</span>
<span class="sd">        Delay value to filter at in seconds.</span>
<span class="sd">    za_cut : float</span>
<span class="sd">        Sine of the maximum zenith angle included in baseline-dependent delay</span>
<span class="sd">        filtering. Default is 1 which corresponds to the horizon (ie: filters out all</span>
<span class="sd">        zenith angles). Setting to zero turns off baseline dependent cut.</span>
<span class="sd">    extra_cut : float</span>
<span class="sd">        Increase the delay threshold beyond the baseline dependent term.</span>
<span class="sd">    weight_tol : float</span>
<span class="sd">        Maximum weight kept in the masked data, as a fraction of the largest weight</span>
<span class="sd">        in the original dataset.</span>
<span class="sd">    telescope_orientation : one of (&#39;NS&#39;, &#39;EW&#39;, &#39;none&#39;)</span>
<span class="sd">        Determines if the baseline-dependent delay cut is based on the north-south</span>
<span class="sd">        component, the east-west component or the full baseline length. For</span>
<span class="sd">        cylindrical telescopes oriented in the NS direction (like CHIME) use &#39;NS&#39;.</span>
<span class="sd">        The default is &#39;NS&#39;.</span>
<span class="sd">    window : bool</span>
<span class="sd">        Apply the window function to the data when applying the filter.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The delay cut applied is `max(za_cut * baseline / c + extra_cut, delay_cut)`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">delay_cut</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="n">za_cut</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">extra_cut</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">weight_tol</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span>
    <span class="n">telescope_orientation</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">enum</span><span class="p">([</span><span class="s2">&quot;NS&quot;</span><span class="p">,</span> <span class="s2">&quot;EW&quot;</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;NS&quot;</span><span class="p">)</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="DelayFilter.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.DelayFilter.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">telescope</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the telescope needed to obtain baselines.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        telescope : TransitTelescope</span>
<span class="sd">            The telescope object to use</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">get_telescope</span><span class="p">(</span><span class="n">telescope</span><span class="p">)</span></div>


<div class="viewcode-block" id="DelayFilter.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.DelayFilter.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter out delays from a SiderealStream or TimeStream.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ss : containers.SiderealStream</span>
<span class="sd">            Data to filter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ss_filt : containers.SiderealStream</span>
<span class="sd">            Filtered dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span>

        <span class="n">ss</span><span class="o">.</span><span class="n">redistribute</span><span class="p">([</span><span class="s2">&quot;input&quot;</span><span class="p">,</span> <span class="s2">&quot;prod&quot;</span><span class="p">,</span> <span class="s2">&quot;stack&quot;</span><span class="p">])</span>

        <span class="n">freq</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">freq</span><span class="p">[:]</span>
        <span class="n">bandwidth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

        <span class="n">ssv</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="n">ssw</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

        <span class="n">ia</span><span class="p">,</span> <span class="n">ib</span> <span class="o">=</span> <span class="n">structured_to_unstructured</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">prodstack</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">baselines</span> <span class="o">=</span> <span class="n">tel</span><span class="o">.</span><span class="n">feedpositions</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span> <span class="o">-</span> <span class="n">tel</span><span class="o">.</span><span class="n">feedpositions</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">lbi</span><span class="p">,</span> <span class="n">bi</span> <span class="ow">in</span> <span class="n">ss</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">enumerate</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Select the baseline length to use</span>
            <span class="n">baseline</span> <span class="o">=</span> <span class="n">baselines</span><span class="p">[</span><span class="n">bi</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope_orientation</span> <span class="o">==</span> <span class="s2">&quot;NS&quot;</span><span class="p">:</span>
                <span class="n">baseline</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">baseline</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># Y baseline</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope_orientation</span> <span class="o">==</span> <span class="s2">&quot;EW&quot;</span><span class="p">:</span>
                <span class="n">baseline</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">baseline</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># X baseline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">baseline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">baseline</span><span class="p">)</span>  <span class="c1"># Norm</span>

            <span class="c1"># In micro seconds</span>
            <span class="n">baseline_delay_cut</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">za_cut</span> <span class="o">*</span> <span class="n">baseline</span> <span class="o">/</span> <span class="n">constants</span><span class="o">.</span><span class="n">c</span> <span class="o">*</span> <span class="mf">1e6</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra_cut</span>
            <span class="p">)</span>
            <span class="n">delay_cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">([</span><span class="n">baseline_delay_cut</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">delay_cut</span><span class="p">])</span>

            <span class="c1"># Calculate the number of samples needed to construct the delay null space.</span>
            <span class="c1"># `4 * tau_max * bandwidth` is the amount recommended in the DAYENU paper</span>
            <span class="c1"># and seems to work well here</span>
            <span class="n">number_cut</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">bandwidth</span> <span class="o">*</span> <span class="n">delay_cut</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>

            <span class="c1"># Flag frequencies and times with zero weight. This works much better if the</span>
            <span class="c1"># incoming weight can be factorized</span>
            <span class="n">f_samp</span> <span class="o">=</span> <span class="p">(</span><span class="n">ssw</span><span class="p">[:,</span> <span class="n">lbi</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">f_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">f_samp</span> <span class="o">==</span> <span class="n">f_samp</span><span class="o">.</span><span class="n">max</span><span class="p">())</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="n">t_samp</span> <span class="o">=</span> <span class="p">(</span><span class="n">ssw</span><span class="p">[:,</span> <span class="n">lbi</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">t_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_samp</span> <span class="o">==</span> <span class="n">t_samp</span><span class="o">.</span><span class="n">max</span><span class="p">())</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">NF</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">null_filter</span><span class="p">(</span>
                    <span class="n">freq</span><span class="p">,</span>
                    <span class="n">delay_cut</span><span class="p">,</span>
                    <span class="n">f_mask</span><span class="p">,</span>
                    <span class="n">num_modes</span><span class="o">=</span><span class="n">number_cut</span><span class="p">,</span>
                    <span class="n">window</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="n">la</span><span class="o">.</span><span class="n">LinAlgError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Failed to converge while processing baseline </span><span class="si">{</span><span class="n">bi</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

            <span class="n">ssv</span><span class="p">[:,</span> <span class="n">lbi</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">NF</span><span class="p">,</span> <span class="n">ssv</span><span class="p">[:,</span> <span class="n">lbi</span><span class="p">])</span>
            <span class="n">ssw</span><span class="p">[:,</span> <span class="n">lbi</span><span class="p">]</span> <span class="o">*=</span> <span class="n">f_mask</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">t_mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="n">ss</span></div>
</div>



<div class="viewcode-block" id="DelayFilterBase">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.DelayFilterBase">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DelayFilterBase</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Remove delays less than a given threshold.</span>

<span class="sd">    This is performed by projecting the data onto the null space that is orthogonal</span>
<span class="sd">    to any mode at low delays.</span>

<span class="sd">    Note that for this task to work best the zero entries in the weights dataset</span>
<span class="sd">    should factorize in frequency-time for each baseline. A mostly optimal masking</span>
<span class="sd">    can be generated using the `draco.analysis.flagging.MaskFreq` task.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    delay_cut : float</span>
<span class="sd">        Delay value to filter at in seconds.</span>
<span class="sd">    window : bool</span>
<span class="sd">        Apply the window function to the data when applying the filter.</span>
<span class="sd">    axis : str</span>
<span class="sd">        The main axis to iterate over. The delay cut can be varied for each element</span>
<span class="sd">        of this axis. If not set, a suitable default is picked for the container</span>
<span class="sd">        type.</span>
<span class="sd">    dataset : str</span>
<span class="sd">        Apply the delay filter to this dataset.  If not set, a suitable default</span>
<span class="sd">        is picked for the container type.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The delay cut applied is `max(za_cut * baseline / c + extra_cut, delay_cut)`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">delay_cut</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

<div class="viewcode-block" id="DelayFilterBase.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.DelayFilterBase.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">telescope</span><span class="p">:</span> <span class="n">io</span><span class="o">.</span><span class="n">TelescopeConvertible</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the telescope needed to obtain baselines.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        telescope</span>
<span class="sd">            The telescope object to use</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">get_telescope</span><span class="p">(</span><span class="n">telescope</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_delay_cut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">:</span> <span class="n">FreqContainerType</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the delay cut to use for this entry in microseconds.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ss</span>
<span class="sd">            The container we are processing.</span>
<span class="sd">        axis</span>
<span class="sd">            The axis we are looping over.</span>
<span class="sd">        ind : int</span>
<span class="sd">            The (global) index along that axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The delay cut in microseconds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">delay_cut</span>

<div class="viewcode-block" id="DelayFilterBase.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.DelayFilterBase.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">:</span> <span class="n">FreqContainerType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FreqContainerType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter out delays from a SiderealStream or TimeStream.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ss</span>
<span class="sd">            Data to filter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ss_filt</span>
<span class="sd">            Filtered dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">containers</span><span class="o">.</span><span class="n">FreqContainer</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Can only process FreqContainer instances. Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="n">_default_axis</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">containers</span><span class="o">.</span><span class="n">SiderealStream</span><span class="p">:</span> <span class="s2">&quot;stack&quot;</span><span class="p">,</span>
            <span class="n">containers</span><span class="o">.</span><span class="n">HybridVisMModes</span><span class="p">:</span> <span class="s2">&quot;m&quot;</span><span class="p">,</span>
            <span class="n">containers</span><span class="o">.</span><span class="n">RingMap</span><span class="p">:</span> <span class="s2">&quot;el&quot;</span><span class="p">,</span>
            <span class="n">containers</span><span class="o">.</span><span class="n">GridBeam</span><span class="p">:</span> <span class="s2">&quot;theta&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">_default_dataset</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">containers</span><span class="o">.</span><span class="n">SiderealStream</span><span class="p">:</span> <span class="s2">&quot;vis&quot;</span><span class="p">,</span>
            <span class="n">containers</span><span class="o">.</span><span class="n">HybridVisMModes</span><span class="p">:</span> <span class="s2">&quot;vis&quot;</span><span class="p">,</span>
            <span class="n">containers</span><span class="o">.</span><span class="n">RingMap</span><span class="p">:</span> <span class="s2">&quot;map&quot;</span><span class="p">,</span>
            <span class="n">containers</span><span class="o">.</span><span class="n">GridBeam</span><span class="p">:</span> <span class="s2">&quot;beam&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">_default_axis</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
                    <span class="n">axis</span> <span class="o">=</span> <span class="n">ax</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No default axis know for </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span><span class="si">}</span><span class="s2"> container.&quot;</span><span class="p">)</span>

        <span class="n">dset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="n">_default_dataset</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
                    <span class="n">dset</span> <span class="o">=</span> <span class="n">dataset</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No default dataset know for </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span><span class="si">}</span><span class="s2"> container.&quot;</span><span class="p">)</span>

        <span class="n">ss</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="n">freq</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">freq</span><span class="p">[:]</span>
        <span class="n">bandwidth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

        <span class="c1"># Get views of the relevant datasets, but make sure that the weights have the</span>
        <span class="c1"># same number of axes as the visibilities (inserting length-1 axes as needed)</span>
        <span class="n">ssv</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="n">dset</span><span class="p">][:]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="n">ssw</span> <span class="o">=</span> <span class="n">match_axes</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="n">dset</span><span class="p">],</span> <span class="n">ss</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

        <span class="n">dist_axis_pos</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="n">dset</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">freq_axis_pos</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="n">dset</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Once we have selected elements of dist_axis the location of freq_axis_pos may</span>
        <span class="c1"># be one lower</span>
        <span class="n">sel_freq_axis_pos</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">freq_axis_pos</span> <span class="k">if</span> <span class="n">freq_axis_pos</span> <span class="o">&lt;</span> <span class="n">dist_axis_pos</span> <span class="k">else</span> <span class="n">freq_axis_pos</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">lbi</span><span class="p">,</span> <span class="n">bi</span> <span class="ow">in</span> <span class="n">ss</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="n">dset</span><span class="p">][:]</span><span class="o">.</span><span class="n">enumerate</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">dist_axis_pos</span><span class="p">):</span>
            <span class="c1"># Extract the part of the array that we are processing, and</span>
            <span class="c1"># transpose/reshape to make a 2D array with frequency as axis=0</span>
            <span class="n">vis_local</span> <span class="o">=</span> <span class="n">_take_view</span><span class="p">(</span><span class="n">ssv</span><span class="p">,</span> <span class="n">lbi</span><span class="p">,</span> <span class="n">dist_axis_pos</span><span class="p">)</span>
            <span class="n">vis_2D</span> <span class="o">=</span> <span class="n">_move_front</span><span class="p">(</span><span class="n">vis_local</span><span class="p">,</span> <span class="n">sel_freq_axis_pos</span><span class="p">,</span> <span class="n">vis_local</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="n">weight_local</span> <span class="o">=</span> <span class="n">_take_view</span><span class="p">(</span><span class="n">ssw</span><span class="p">,</span> <span class="n">lbi</span><span class="p">,</span> <span class="n">dist_axis_pos</span><span class="p">)</span>
            <span class="n">weight_2D</span> <span class="o">=</span> <span class="n">_move_front</span><span class="p">(</span><span class="n">weight_local</span><span class="p">,</span> <span class="n">sel_freq_axis_pos</span><span class="p">,</span> <span class="n">weight_local</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="c1"># In micro seconds</span>
            <span class="n">delay_cut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delay_cut</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">bi</span><span class="p">)</span>

            <span class="c1"># Calculate the number of samples needed to construct the delay null space.</span>
            <span class="c1"># `4 * tau_max * bandwidth` is the amount recommended in the DAYENU paper</span>
            <span class="c1"># and seems to work well here</span>
            <span class="n">number_cut</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">bandwidth</span> <span class="o">*</span> <span class="n">delay_cut</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>

            <span class="c1"># Flag frequencies and times (or all other axes) with zero weight. This</span>
            <span class="c1"># works much better if the incoming weight can be factorized</span>
            <span class="n">f_samp</span> <span class="o">=</span> <span class="p">(</span><span class="n">weight_2D</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">f_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">f_samp</span> <span class="o">==</span> <span class="n">f_samp</span><span class="o">.</span><span class="n">max</span><span class="p">())</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="n">t_samp</span> <span class="o">=</span> <span class="p">(</span><span class="n">weight_2D</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">t_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_samp</span> <span class="o">==</span> <span class="n">t_samp</span><span class="o">.</span><span class="n">max</span><span class="p">())</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="c1"># This has occasionally failed to converge, catch this and output enough</span>
            <span class="c1"># info to debug after the fact</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">NF</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">null_filter</span><span class="p">(</span>
                    <span class="n">freq</span><span class="p">,</span>
                    <span class="n">delay_cut</span><span class="p">,</span>
                    <span class="n">f_mask</span><span class="p">,</span>
                    <span class="n">num_modes</span><span class="o">=</span><span class="n">number_cut</span><span class="p">,</span>
                    <span class="n">window</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="n">la</span><span class="o">.</span><span class="n">LinAlgError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Failed to converge while processing baseline </span><span class="si">{</span><span class="n">bi</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

            <span class="n">vis_local</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">_inv_move_front</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">NF</span><span class="p">,</span> <span class="n">vis_2D</span><span class="p">),</span> <span class="n">sel_freq_axis_pos</span><span class="p">,</span> <span class="n">vis_local</span><span class="o">.</span><span class="n">shape</span>
            <span class="p">)</span>
            <span class="n">weight_local</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">_inv_move_front</span><span class="p">(</span>
                <span class="n">f_mask</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">t_mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span>
                <span class="n">sel_freq_axis_pos</span><span class="p">,</span>
                <span class="n">weight_local</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">ss</span></div>
</div>



<span class="c1"># -----------------------------</span>
<span class="c1"># Delay Transform Base Classes</span>
<span class="c1"># -----------------------------</span>


<div class="viewcode-block" id="DelayTransformBase">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.DelayTransformBase">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DelayTransformBase</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for transforming from frequency to delay (non-functional).</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    freq_zero : float, optional</span>
<span class="sd">        The physical frequency (in MHz) of the *zero* channel. That is the DC</span>
<span class="sd">        channel coming out of the F-engine. If not specified, use the first</span>
<span class="sd">        frequency channel of the stream.</span>
<span class="sd">    freq_spacing : float, optional</span>
<span class="sd">        The spacing between the underlying channels (in MHz). This is conjugate</span>
<span class="sd">        to the length of a frame of time samples that is transformed. If not</span>
<span class="sd">        set, then use the smallest gap found between channels in the dataset.</span>
<span class="sd">    nfreq : int, optional</span>
<span class="sd">        The number of frequency channels in the full set produced by the</span>
<span class="sd">        F-engine. If not set, assume the last included frequency is the last of</span>
<span class="sd">        the full set (or is the penultimate if `skip_nyquist` is set).</span>
<span class="sd">    skip_nyquist : bool, optional</span>
<span class="sd">        Whether the Nyquist frequency is included in the data. This is `True` by</span>
<span class="sd">        default to align with the output of CASPER PFBs.</span>
<span class="sd">    apply_window : bool, optional</span>
<span class="sd">        Whether to apply apodisation to frequency axis. Default: True.</span>
<span class="sd">    window : window available in :func:`draco.util.tools.window_generalised()`, optional</span>
<span class="sd">        Apodisation to perform on frequency axis. Default: &#39;nuttall&#39;.</span>
<span class="sd">    complex_timedomain : bool, optional</span>
<span class="sd">        Whether to assume the original time samples that were channelized into a</span>
<span class="sd">        frequency spectrum were purely real (False) or complex (True). If True,</span>
<span class="sd">        `freq_zero`, `nfreq`, and `skip_nyquist` are ignored. Default: False.</span>
<span class="sd">    use_average_weights : bool, optional</span>
<span class="sd">        Use noise weights averaged over time samples. This means that only a single</span>
<span class="sd">        covariance matrix needs to be created for unique power spectrum (i.e., for</span>
<span class="sd">        each baseline), but it is only valid if the frequency masking is constant</span>
<span class="sd">        in time. Default: True.</span>
<span class="sd">    weight_boost : float, optional</span>
<span class="sd">        Multiply weights in the input container by this factor. This causes the task to</span>
<span class="sd">        assume the noise power in the data is `weight_boost` times lower, which is</span>
<span class="sd">        useful if you want the &quot;true&quot; noise to not be downweighted by the Wiener filter,</span>
<span class="sd">        or have it included in the Gibbs sampler. Default: 1.0.</span>
<span class="sd">    freq_frac</span>
<span class="sd">        The threshold for the fraction of time samples present in a frequency for it</span>
<span class="sd">        to be retained. Must be strictly greater than this value, so the default</span>
<span class="sd">        value 0, retains any channel with at least one sample. A value of 0.01 would</span>
<span class="sd">        retain any frequency that has &gt; 1% of time samples unmasked.</span>
<span class="sd">    time_frac</span>
<span class="sd">        The threshold for the fraction of frequency samples required to retain a</span>
<span class="sd">        time sample. Must be strictly greater than this value. The default value (-1)</span>
<span class="sd">        means that all time samples are kept. A value of 0.01 would keep any time</span>
<span class="sd">        sample with &gt;1% of frequencies unmasked.</span>
<span class="sd">    remove_mean</span>
<span class="sd">        Subtract the mean in time of each frequency channel. This is done after time</span>
<span class="sd">        samples are pruned by the `time_frac` threshold.</span>
<span class="sd">    scale_freq</span>
<span class="sd">        Scale each frequency by its standard deviation to flatten the fluctuations</span>
<span class="sd">        across the band. Applied before any apodisation is done.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">freq_zero</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">freq_spacing</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">nfreq</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">skip_nyquist</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">apply_window</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">enum</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="s2">&quot;uniform&quot;</span><span class="p">,</span>
            <span class="s2">&quot;hann&quot;</span><span class="p">,</span>
            <span class="s2">&quot;hanning&quot;</span><span class="p">,</span>
            <span class="s2">&quot;hamming&quot;</span><span class="p">,</span>
            <span class="s2">&quot;blackman&quot;</span><span class="p">,</span>
            <span class="s2">&quot;nuttall&quot;</span><span class="p">,</span>
            <span class="s2">&quot;blackman_nuttall&quot;</span><span class="p">,</span>
            <span class="s2">&quot;blackman_harris&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="n">default</span><span class="o">=</span><span class="s2">&quot;nuttall&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">complex_timedomain</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">use_average_weights</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">weight_boost</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>

    <span class="n">freq_frac</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">time_frac</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>

    <span class="n">remove_mean</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">scale_freq</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="DelayTransformBase.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.DelayTransformBase.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Estimate the delay spectrum or power spectrum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ss : `containers.FreqContainer`</span>
<span class="sd">            Data to transform. Must have a frequency axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out_cont : `containers.DelayTransform` or `containers.DelaySpectrum`</span>
<span class="sd">            Output delay spectrum or delay power spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">delays</span><span class="p">,</span> <span class="n">channel_ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_delays</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span>

        <span class="c1"># Get views of data and weights appropriate for the type of processing we&#39;re</span>
        <span class="c1"># doing.</span>
        <span class="n">data_view</span><span class="p">,</span> <span class="n">weight_view</span><span class="p">,</span> <span class="n">coord_axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_inputs</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span>

        <span class="c1"># Create the right output container</span>
        <span class="n">out_cont</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_output</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">delays</span><span class="p">,</span> <span class="n">coord_axes</span><span class="p">)</span>

        <span class="c1"># Save the frequency window as a container attribute.</span>
        <span class="c1"># This can be used to estimate effective bandwidth.</span>
        <span class="n">out_cont</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;window_los&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_window</span> <span class="k">else</span> <span class="s2">&quot;None&quot;</span>

        <span class="c1"># Evaluate frequency-&gt;delay transform. (self._evaluate take the empty output</span>
        <span class="c1"># container, fills it, and returns it)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate</span><span class="p">(</span><span class="n">data_view</span><span class="p">,</span> <span class="n">weight_view</span><span class="p">,</span> <span class="n">out_cont</span><span class="p">,</span> <span class="n">delays</span><span class="p">,</span> <span class="n">channel_ind</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_delays</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">FreqContainer</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">containers</span><span class="o">.</span><span class="n">FreqContainer</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the grid of delays.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ss</span>
<span class="sd">            A FreqContainer to determine the delays from.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        delays</span>
<span class="sd">            The delays that will be calculated.</span>
<span class="sd">        channel_ind</span>
<span class="sd">            The effective channel indices of the data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">containers</span><span class="o">.</span><span class="n">FreqContainer</span><span class="p">):</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">freq</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">ss</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">freq</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Could not find a frequency axis in the input.&quot;</span><span class="p">)</span>

        <span class="n">freq_zero</span> <span class="o">=</span> <span class="n">freq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_zero</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_zero</span>

        <span class="n">freq_spacing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_spacing</span>
        <span class="k">if</span> <span class="n">freq_spacing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">freq_spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">freq</span><span class="p">))</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

        <span class="n">nfreq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfreq</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">complex_timedomain</span><span class="p">:</span>
            <span class="n">nfreq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
            <span class="n">channel_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nfreq</span><span class="p">)</span>
            <span class="n">ndelay</span> <span class="o">=</span> <span class="n">nfreq</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">channel_ind</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">freq</span> <span class="o">-</span> <span class="n">freq_zero</span><span class="p">)</span> <span class="o">/</span> <span class="n">freq_spacing</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">nfreq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">nfreq</span> <span class="o">=</span> <span class="n">channel_ind</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip_nyquist</span><span class="p">:</span>
                    <span class="n">nfreq</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Assume each transformed frame was an even number of samples long</span>
            <span class="n">ndelay</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">nfreq</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Compute delays corresponding to output delay power spectrum (in us)</span>
        <span class="n">delays</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">ndelay</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">freq_spacing</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">delays</span><span class="p">,</span> <span class="n">channel_ind</span>

    <span class="c1"># NOTE: this not obviously the right level for this, but it&#39;s the only baseclass in</span>
    <span class="c1"># common to where it&#39;s used</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_cut_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">weight</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply cuts on the data and weights and returned modified versions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data</span>
<span class="sd">            An n-d array of the data. Frequency is the last axis, and the average axis</span>
<span class="sd">            the second last.</span>
<span class="sd">        weight</span>
<span class="sd">            A n-d array of the weights. Axes the same as the data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_data</span>
<span class="sd">            The new data with cuts applied and all-zero channels removed.</span>
<span class="sd">        new_weight</span>
<span class="sd">            The new weights with cuts applied and averaged over the `sample_axis` (i.e</span>
<span class="sd">            second last).</span>
<span class="sd">        non_zero_freq</span>
<span class="sd">            The selection of frequencies retained. A boolean array of shape N_freq that</span>
<span class="sd">            is true at indices of frequencies retained after applying the freq_frac cut.</span>
<span class="sd">        non_zero_time</span>
<span class="sd">            The selection of times retained. A boolean array of shape N_rime that is</span>
<span class="sd">            true at indices of time samples retained after applying the time_frac cut.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ntime</span><span class="p">,</span> <span class="n">nfreq</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>

        <span class="n">weight_mask</span> <span class="o">=</span> <span class="n">weight</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">weight_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">non_zero_time</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">weight_mask</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ntime</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_frac</span>
        <span class="p">)</span>

        <span class="c1"># Only calculate non-zero frequencies after masked</span>
        <span class="c1"># time samples have been removed</span>
        <span class="n">weight_mask</span> <span class="o">=</span> <span class="n">weight_mask</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">non_zero_time</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">non_zero_freq</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">weight_mask</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nfreq</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_frac</span>
        <span class="p">)</span>

        <span class="c1"># If there are no non-zero weighted entries skip</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">non_zero_freq</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">non_zero_time</span><span class="p">,</span> <span class="p">:][</span><span class="o">...</span><span class="p">,</span> <span class="n">non_zero_freq</span><span class="p">]</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">weight</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">non_zero_time</span><span class="p">,</span> <span class="p">:][</span><span class="o">...</span><span class="p">,</span> <span class="n">non_zero_freq</span><span class="p">]</span>

        <span class="c1"># Remove the mean from the data before estimating the spectrum</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_mean</span><span class="p">:</span>
            <span class="c1"># Do not apply this in place to make sure we don&#39;t modify</span>
            <span class="c1"># the input data</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># If there are no non-zero data entries skip</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Scale the frequencies by the typical fluctuation size, with a scaling to</span>
        <span class="c1"># obtain constant total power</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_freq</span><span class="p">:</span>
            <span class="n">dscl</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">data</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
                <span class="o">/</span> <span class="n">data</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">))[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">dscl</span><span class="p">)</span>

        <span class="c1"># Use the averaged weights across all time samples.</span>
        <span class="c1"># This is typically desired</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_average_weights</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">weight</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_boost</span>

        <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">non_zero_freq</span><span class="p">,</span> <span class="n">non_zero_time</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_prepare_inputs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">FreqContainer</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="p">,</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get relevant views of data and weights, and create output container.</span>

<span class="sd">        This implementation is blank, and must be overridden. The function must take</span>
<span class="sd">        a `containers.FreqContainer` and rearrange the data into an `MPIArray` packed as</span>
<span class="sd">        ``[coord, freq, sample]``, where we want to compute a separate delay spectrum</span>
<span class="sd">        for each value of `coord` (e.g. baseline, ringmap elevation), and `sample` is</span>
<span class="sd">        averaged over if we are computing a delay power spectrum. The weights must also</span>
<span class="sd">        be rearranged in the same way. Finally, the function must also return an empty</span>
<span class="sd">        container suitable to hold the final delay spectrum or power spectrum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ss</span>
<span class="sd">            Data to transform. Must have a frequency axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data_view</span>
<span class="sd">            Data to transform, reshaped as described above.</span>
<span class="sd">        weight_view</span>
<span class="sd">            Weights, reshaped in same way as data.</span>
<span class="sd">        coord_axes</span>
<span class="sd">            List of string names of the axes folded into `coord`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_view</span><span class="p">,</span> <span class="n">weight_view</span><span class="p">,</span> <span class="n">out_cont</span><span class="p">,</span> <span class="n">delays</span><span class="p">,</span> <span class="n">channel_ind</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Estimate the delay spectrum or power spectrum.</span>

<span class="sd">        This implementation is blank, and must be overridden. The function must take</span>
<span class="sd">        the outputs of `_prepare_inputs`, evaluate the delay spectrum or power spectrum,</span>
<span class="sd">        and return the appropriate container.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_view : `caput.mpiarray.MPIArray`</span>
<span class="sd">            Data to transform.</span>
<span class="sd">        weight_view : `caput.mpiarray.MPIArray`</span>
<span class="sd">            Weights corresponding to `data_view`.</span>
<span class="sd">        out_cont : `containers.DelayTransform` or `containers.DelaySpectrum`</span>
<span class="sd">            Container for output delay spectrum or power spectrum.</span>
<span class="sd">        delays</span>
<span class="sd">            The delays to evaluate at.</span>
<span class="sd">        channel_ind</span>
<span class="sd">            The indices of the available frequency channels in the full set of channels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out_cont : `containers.DelayTransform` or `containers.DelaySpectrum`</span>
<span class="sd">            Output delay spectrum or delay power spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_create_output</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ss</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">FreqContainer</span><span class="p">,</span>
        <span class="n">delays</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">coord_axes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ContainerPrototype</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a suitable output container.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ss</span>
<span class="sd">            The input container that we are using.</span>
<span class="sd">        delays</span>
<span class="sd">            The delays that we will calculate at.</span>
<span class="sd">        coord_axes</span>
<span class="sd">            The list of axes folded into the coord axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>



<div class="viewcode-block" id="GeneralInputContainerMixin">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.GeneralInputContainerMixin">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GeneralInputContainerMixin</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mixin for freq-&gt;delay transforms that collapse over several dataset axes.</span>

<span class="sd">    The delay spectrum or power spectrum output is indexed by a `baseline` axis. This</span>
<span class="sd">    axis is the composite axis of all the axes in the container except the frequency</span>
<span class="sd">    axis or the `sample_axis`. These constituent axes are included in the index map,</span>
<span class="sd">    and their order is given by the `baseline_axes` attribute.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    dataset : str, optional</span>
<span class="sd">        Calculate the delay spectrum of this dataset (e.g., &quot;vis&quot;, &quot;map&quot;, &quot;beam&quot;). If</span>
<span class="sd">        not set, assume the input is a `DataWeightContainer` and use the main data</span>
<span class="sd">        dataset.</span>
<span class="sd">    sample_axis : str</span>
<span class="sd">        Assume that every sample over this axis is drawn from the same power spectrum.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dataset</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">sample_axis</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_prepare_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get relevant views of data and weights, and create output container.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ss : `FreqContainer` and `DataWeightContainer` subclass.</span>
<span class="sd">            Data to transform. Must have a frequency axis, and a weight dataset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data_view : `caput.mpiarray.MPIArray`</span>
<span class="sd">            Data to transform, reshaped such that all axes other than frequency and</span>
<span class="sd">            `sample_axis` are compressed into the baseline axis.</span>
<span class="sd">        weight_view : `caput.mpiarray.MPIArray`</span>
<span class="sd">            Weights, reshaped in same way as data.</span>
<span class="sd">        out_cont : `containers.DelayTransform` or `containers.DelaySpectrum`</span>
<span class="sd">            Container for output delay spectrum or power spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ss</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ss</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Specified dataset to delay transform (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="si">}</span><span class="s2">) not in &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;container of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
            <span class="n">data_dset</span> <span class="o">=</span> <span class="n">ss</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data_dset</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">data</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sample_axis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ss</span><span class="o">.</span><span class="n">axes</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_axis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data_dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Specified sample axis (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_axis</span><span class="si">}</span><span class="s2">) not in &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;container of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Find the relevant axis positions</span>
        <span class="n">data_view</span><span class="p">,</span> <span class="n">bl_axes</span> <span class="o">=</span> <span class="n">flatten_axes</span><span class="p">(</span><span class="n">data_dset</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_axis</span><span class="p">,</span> <span class="s2">&quot;freq&quot;</span><span class="p">])</span>
        <span class="n">weight_view</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">flatten_axes</span><span class="p">(</span>
            <span class="n">ss</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_axis</span><span class="p">,</span> <span class="s2">&quot;freq&quot;</span><span class="p">],</span> <span class="n">match_dset</span><span class="o">=</span><span class="n">data_dset</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">data_view</span><span class="p">,</span> <span class="n">weight_view</span><span class="p">,</span> <span class="n">bl_axes</span></div>



<div class="viewcode-block" id="DelayPowerSpectrumContainerMixin">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.DelayPowerSpectrumContainerMixin">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DelayPowerSpectrumContainerMixin</span><span class="p">(</span><span class="n">GeneralInputContainerMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mixin for creating a delay power spectrum output container.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    nsamp : int</span>
<span class="sd">        Number of samples to compute for each power spectrum.</span>
<span class="sd">        Default is 1.</span>
<span class="sd">    save_samples : bool</span>
<span class="sd">        When using a sampling-based power spectrum estimator,</span>
<span class="sd">        save out every sample in the chain. Otherwise, only save</span>
<span class="sd">        the final power spectrum. Default is False.</span>
<span class="sd">    save_spectrum_mask : bool</span>
<span class="sd">        Save a mask which flags spectra which have significant error,</span>
<span class="sd">        as determined by the estimator. Default is False.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nsamp</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">save_samples</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">save_spectrum_mask</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_create_output</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ss</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">FreqContainer</span><span class="p">,</span>
        <span class="n">delays</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">coord_axes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ContainerPrototype</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the output container for the delay power spectrum.</span>

<span class="sd">        If `coord_axes` is a list of strings then it is assumed to be a list of the</span>
<span class="sd">        names of the folded axes. If it&#39;s an array then assume it is the actual axis</span>
<span class="sd">        definition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If only one axis is being collapsed, use that as the baseline axis definition,</span>
        <span class="c1"># otherwise just use integer indices</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord_axes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">bl</span> <span class="o">=</span> <span class="n">coord_axes</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord_axes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">bl</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="n">coord_axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="n">ax</span><span class="p">])</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">coord_axes</span><span class="p">])</span>

        <span class="c1"># Initialise the spectrum container</span>
        <span class="n">delay_spec</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">DelaySpectrum</span><span class="p">(</span>
            <span class="n">baseline</span><span class="o">=</span><span class="n">bl</span><span class="p">,</span>
            <span class="n">delay</span><span class="o">=</span><span class="n">delays</span><span class="p">,</span>
            <span class="n">sample</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamp</span><span class="p">,</span>
            <span class="n">attrs_from</span><span class="o">=</span><span class="n">ss</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">delay_spec</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;baseline&quot;</span><span class="p">)</span>
        <span class="n">delay_spec</span><span class="o">.</span><span class="n">spectrum</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Copy the index maps for all the flattened axes into the output container, and</span>
        <span class="c1"># write out their order into an attribute so we can reconstruct this easily</span>
        <span class="c1"># when loading in the spectrum</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord_axes</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">coord_axes</span><span class="p">:</span>
                <span class="n">delay_spec</span><span class="o">.</span><span class="n">create_index_map</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">ss</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="n">ax</span><span class="p">])</span>
            <span class="n">delay_spec</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;baseline_axes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord_axes</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_samples</span><span class="p">:</span>
            <span class="n">delay_spec</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;spectrum_samples&quot;</span><span class="p">)</span>

        <span class="c1"># Initialize a mask dataset to record the baselines for</span>
        <span class="c1"># which the estimator did/didn&#39;t converge.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_spectrum_mask</span><span class="p">:</span>
            <span class="n">delay_spec</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;spectrum_mask&quot;</span><span class="p">)</span>
            <span class="n">delay_spec</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;spectrum_mask&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Save the frequency axis of the input data as an attribute in the output</span>
        <span class="c1"># container</span>
        <span class="n">delay_spec</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">freq</span>

        <span class="k">return</span> <span class="n">delay_spec</span></div>



<div class="viewcode-block" id="DelaySpectrumContainerMixin">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.DelaySpectrumContainerMixin">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DelaySpectrumContainerMixin</span><span class="p">(</span><span class="n">GeneralInputContainerMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mixin for creating a delay transform output container.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    save_spectrum_mask : bool</span>
<span class="sd">        Save a mask which flags spectra which have significant error,</span>
<span class="sd">        as determined by the estimator. Default is False.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">save_spectrum_mask</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_create_output</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">FreqContainer</span><span class="p">,</span> <span class="n">delays</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">coord_axes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ContainerPrototype</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the output container for the delay transform.&quot;&quot;&quot;</span>
        <span class="c1"># Initialise the spectrum container</span>
        <span class="n">nbase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="n">ax</span><span class="p">])</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">coord_axes</span><span class="p">])</span>
        <span class="n">delay_spec</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">DelayTransform</span><span class="p">(</span>
            <span class="n">baseline</span><span class="o">=</span><span class="n">nbase</span><span class="p">,</span>
            <span class="n">sample</span><span class="o">=</span><span class="n">ss</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_axis</span><span class="p">],</span>
            <span class="n">delay</span><span class="o">=</span><span class="n">delays</span><span class="p">,</span>
            <span class="n">attrs_from</span><span class="o">=</span><span class="n">ss</span><span class="p">,</span>
            <span class="n">weight_boost</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight_boost</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">delay_spec</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;baseline&quot;</span><span class="p">)</span>
        <span class="n">delay_spec</span><span class="o">.</span><span class="n">spectrum</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Copy the index maps for all the flattened axes into the output container, and</span>
        <span class="c1"># write out their order into an attribute so we can reconstruct this easily</span>
        <span class="c1"># when loading in the spectrum</span>
        <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">coord_axes</span><span class="p">:</span>
            <span class="n">delay_spec</span><span class="o">.</span><span class="n">create_index_map</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">ss</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="n">ax</span><span class="p">])</span>
        <span class="n">delay_spec</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;baseline_axes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord_axes</span>

        <span class="c1"># Initialize a mask dataset to record flagged</span>
        <span class="c1"># samples and baselines.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_spectrum_mask</span><span class="p">:</span>
            <span class="n">delay_spec</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;spectrum_mask&quot;</span><span class="p">)</span>
            <span class="n">delay_spec</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;spectrum_mask&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Save the frequency axis of the input data as an attribute in the output</span>
        <span class="c1"># container</span>
        <span class="n">delay_spec</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">freq</span>

        <span class="k">return</span> <span class="n">delay_spec</span></div>



<span class="c1"># -------------------------------------</span>
<span class="c1"># Classes to compute a delay transform</span>
<span class="c1"># -------------------------------------</span>


<div class="viewcode-block" id="DelaySpectrumBase">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.DelaySpectrumBase">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DelaySpectrumBase</span><span class="p">(</span><span class="n">DelaySpectrumContainerMixin</span><span class="p">,</span> <span class="n">DelayTransformBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for delay spectrum estimation (non-functional).&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_view</span><span class="p">,</span> <span class="n">weight_view</span><span class="p">,</span> <span class="n">out_cont</span><span class="p">,</span> <span class="n">delays</span><span class="p">,</span> <span class="n">channel_ind</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Estimate the delay spectrum via inverse FFT.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_view : `caput.mpiarray.MPIArray`</span>
<span class="sd">            Data to transform.</span>
<span class="sd">        weight_view : `caput.mpiarray.MPIArray`</span>
<span class="sd">            Weights corresponding to `data_view`.</span>
<span class="sd">        out_cont : `containers.DelayTransform` or `containers.DelaySpectrum`</span>
<span class="sd">            Container for output delay spectrum or power spectrum.</span>
<span class="sd">        delays</span>
<span class="sd">            The delays to evaluate at.</span>
<span class="sd">        channel_ind</span>
<span class="sd">            The indices of the available frequency channels in the full set of channels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out_cont : `containers.DelaySpectrum`</span>
<span class="sd">            Output delay spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nbase</span> <span class="o">=</span> <span class="n">out_cont</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">global_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nbaselocal</span> <span class="o">=</span> <span class="n">out_cont</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">local_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ndelay</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">delays</span><span class="p">)</span>

        <span class="n">prior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_prior</span><span class="p">(</span><span class="n">nbase</span><span class="p">)</span>

        <span class="c1"># Iterate over the combined baseline axis</span>
        <span class="k">for</span> <span class="n">lbi</span><span class="p">,</span> <span class="n">bi</span> <span class="ow">in</span> <span class="n">out_cont</span><span class="o">.</span><span class="n">spectrum</span><span class="p">[:]</span><span class="o">.</span><span class="n">enumerate</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Estimating the delay transform of baseline </span><span class="si">{</span><span class="n">bi</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">nbaselocal</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">nbase</span><span class="si">}</span><span class="s2"> total).&quot;</span>
            <span class="p">)</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">data_view</span><span class="o">.</span><span class="n">local_array</span><span class="p">[</span><span class="n">lbi</span><span class="p">]</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">weight_view</span><span class="o">.</span><span class="n">local_array</span><span class="p">[</span><span class="n">lbi</span><span class="p">]</span>

            <span class="c1"># Apply data cuts</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cut_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Record this sample as bad</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_spectrum_mask</span><span class="p">:</span>
                    <span class="n">out_cont</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;spectrum_mask&quot;</span><span class="p">][</span><span class="n">bi</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">continue</span>

            <span class="n">data</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">nzf</span><span class="p">,</span> <span class="n">nzt</span> <span class="o">=</span> <span class="n">t</span>

            <span class="c1"># Estimate the delay transform using an estimator</span>
            <span class="n">y_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_estimator</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">prior</span><span class="p">[</span><span class="n">lbi</span><span class="p">],</span> <span class="n">ndelay</span><span class="p">,</span> <span class="n">channel_ind</span><span class="p">[</span><span class="n">nzf</span><span class="p">])</span>

            <span class="n">out_cont</span><span class="o">.</span><span class="n">spectrum</span><span class="p">[</span><span class="n">bi</span><span class="p">,</span> <span class="n">nzt</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_spec</span>

            <span class="c1"># Record missing samples in the spectrum mask</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_spectrum_mask</span><span class="p">:</span>
                <span class="n">out_cont</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;spectrum_mask&quot;</span><span class="p">][</span><span class="n">bi</span><span class="p">][</span><span class="o">~</span><span class="n">nzt</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">out_cont</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_prior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbase</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a power spectrum prior.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nbase : int</span>
<span class="sd">            Number of baselines</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        prior : list | np.ndarray</span>
<span class="sd">            Power spectrum prior.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">ndelay</span><span class="p">,</span> <span class="n">channel_ind</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use an estimator to calculate the delay spectrum.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dtransform : np.ndarray</span>
<span class="sd">            Estimated delay transform.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>



<div class="viewcode-block" id="DelaySpectrumFFT">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.DelaySpectrumFFT">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DelaySpectrumFFT</span><span class="p">(</span><span class="n">DelaySpectrumBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class to measure the delay spectrum of a general container via ifft.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_prior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbase</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a power spectrum prior.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">nbase</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">ndelay</span><span class="p">,</span> <span class="n">channel_ind</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use inverse FFT to calculate the delay transform of a data slice.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dtransform : np.ndarray</span>
<span class="sd">            Estimated delay transform.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y_spec</span> <span class="o">=</span> <span class="n">delay_spectrum_fft</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">ndelay</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_window</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">y_spec</span><span class="p">,</span> <span class="n">axes</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span></div>



<div class="viewcode-block" id="DelaySpectrumWienerFilter">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.DelaySpectrumWienerFilter">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DelaySpectrumWienerFilter</span><span class="p">(</span><span class="n">DelaySpectrumBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class to measure delay spectrum of general container via Wiener filtering.</span>

<span class="sd">    The spectrum is calculated by applying a Wiener filter to the input frequency</span>
<span class="sd">    spectrum, assuming an input model for the delay power spectrum of the signal and</span>
<span class="sd">    that the noise power is described by the weights of the input container. See</span>
<span class="sd">    https://arxiv.org/abs/2202.01242, Eq. A6 for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DelaySpectrumWienerFilter.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.DelaySpectrumWienerFilter.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dps</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the delay power spectrum to use as the signal covariance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dps : `containers.DelaySpectrum`</span>
<span class="sd">            Delay power spectrum for signal part of Wiener filter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="n">dps</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">setup</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_prior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbase</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a power spectrum prior.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dps</span><span class="o">.</span><span class="n">spectrum</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">ndelay</span><span class="p">,</span> <span class="n">channel_ind</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use a Wiener filter to calculate the delay transform of a data slice.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dtransform : np.ndarray</span>
<span class="sd">            Estimated delay transform.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y_spec</span> <span class="o">=</span> <span class="n">delay_spectrum_wiener_filter</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">S</span><span class="p">),</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">ndelay</span><span class="p">,</span>
            <span class="n">weight</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_window</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">fsel</span><span class="o">=</span><span class="n">channel_ind</span><span class="p">,</span>
            <span class="n">complex_timedomain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">complex_timedomain</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">y_spec</span><span class="p">,</span> <span class="n">axes</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span></div>



<div class="viewcode-block" id="DelaySpectrumWienerFilterIteratePS">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.DelaySpectrumWienerFilterIteratePS">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DelaySpectrumWienerFilterIteratePS</span><span class="p">(</span><span class="n">DelaySpectrumWienerFilter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class to estimate the delay spectrum using Wiener filtering.</span>

<span class="sd">    This class extends `DelaySpectrumWienerFilter` by allowing the</span>
<span class="sd">    delay power spectrum (`dps`) to be updated with each call to `process`</span>
<span class="sd">    instead of being fixed at `setup`.  The updated `dps` is used to apply</span>
<span class="sd">    the Wiener filter to the input frequency spectrum.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DelaySpectrumWienerFilterIteratePS.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.DelaySpectrumWienerFilterIteratePS.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">dps</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Estimate the delay spectrum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ss : `containers.FreqContainer`</span>
<span class="sd">            Data to transform. Must have a frequency axis.</span>
<span class="sd">        dps : `containers.DelaySpectrum`</span>
<span class="sd">            Delay power spectrum for signal part of Wiener filter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out_cont : `containers.DelayTransform` or `containers.DelaySpectrum`</span>
<span class="sd">            Output delay spectrum or delay power spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="n">dps</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span></div>
</div>



<span class="c1"># -------------------------------------------------------------</span>
<span class="c1"># Class to compute a delay power spectrum from a delay spectrum</span>
<span class="c1"># -------------------------------------------------------------</span>


<div class="viewcode-block" id="DelaySpectrumToPowerSpectrum">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.DelaySpectrumToPowerSpectrum">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DelaySpectrumToPowerSpectrum</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute a delay power spectrum from a delay spectrum.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="DelaySpectrumToPowerSpectrum.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.DelaySpectrumToPowerSpectrum.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dspec</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">DelayTransform</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">DelaySpectrum</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the delay power spectrum from a delay spectrum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dspec</span>
<span class="sd">            Delay spectrum container.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pspec</span>
<span class="sd">            Delay power spectrum container.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dspec</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;baseline&quot;</span><span class="p">)</span>

        <span class="c1"># Make the power spectrum container</span>
        <span class="n">pspec</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">DelaySpectrum</span><span class="p">(</span><span class="n">attrs_from</span><span class="o">=</span><span class="n">dspec</span><span class="p">,</span> <span class="n">axes_from</span><span class="o">=</span><span class="n">dspec</span><span class="p">)</span>
        <span class="n">pspec</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;baseline&quot;</span><span class="p">)</span>

        <span class="c1"># If a spectrum mask exists, use it</span>
        <span class="k">if</span> <span class="s2">&quot;spectrum_mask&quot;</span> <span class="ow">in</span> <span class="n">dspec</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">dspec</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;spectrum_mask&quot;</span><span class="p">][:]</span><span class="o">.</span><span class="n">local_array</span>
            <span class="n">w</span> <span class="o">=</span> <span class="o">~</span><span class="n">w</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="c1"># Also, add a spectrum mask to the power spectrum</span>
            <span class="n">pspec</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;spectrum_mask&quot;</span><span class="p">)</span>
            <span class="n">pspec</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;spectrum_mask&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">ps</span> <span class="o">=</span> <span class="n">pspec</span><span class="o">.</span><span class="n">spectrum</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">dspec</span><span class="o">.</span><span class="n">spectrum</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="n">ps</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>

        <span class="c1"># Check for NaNs and mask them. This happens if an entire slice</span>
        <span class="c1"># along the variance axis is masked, and should correspond</span>
        <span class="c1"># to bad baselines. Don&#39;t bother if no mask was used.</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span>
            <span class="n">ps</span><span class="p">[</span><span class="n">nans</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">pspec</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;spectrum_mask&quot;</span><span class="p">][:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">nans</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pspec</span></div>
</div>



<span class="c1"># ---------------------------------------------------</span>
<span class="c1"># Classes to directly compute a delay power spectrum</span>
<span class="c1"># ---------------------------------------------------</span>


<div class="viewcode-block" id="DelayPowerSpectrumBase">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.DelayPowerSpectrumBase">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DelayPowerSpectrumBase</span><span class="p">(</span><span class="n">DelayPowerSpectrumContainerMixin</span><span class="p">,</span> <span class="n">DelayTransformBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for delay power spectrum estimation (non-functional).&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_view</span><span class="p">,</span> <span class="n">weight_view</span><span class="p">,</span> <span class="n">out_cont</span><span class="p">,</span> <span class="n">delays</span><span class="p">,</span> <span class="n">channel_ind</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Estimate the delay spectrum or power spectrum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_view : `caput.mpiarray.MPIArray`</span>
<span class="sd">            Data to transform.</span>
<span class="sd">        weight_view : `caput.mpiarray.MPIArray`</span>
<span class="sd">            Weights corresponding to `data_view`.</span>
<span class="sd">        out_cont : `containers.DelayTransform` or `containers.DelaySpectrum`</span>
<span class="sd">            Container for output delay spectrum or power spectrum.</span>
<span class="sd">        delays</span>
<span class="sd">            The delays to evaluate at.</span>
<span class="sd">        channel_ind</span>
<span class="sd">            The indices of the available frequency channels in the full set of channels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out_cont : `containers.DelayTransform` or `containers.DelaySpectrum`</span>
<span class="sd">            Output delay spectrum or delay power spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nbase</span> <span class="o">=</span> <span class="n">out_cont</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">global_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nbaselocal</span> <span class="o">=</span> <span class="n">out_cont</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">local_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ndelay</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">delays</span><span class="p">)</span>

        <span class="c1"># Set initial conditions for delay power spectrum</span>
        <span class="n">prior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_prior</span><span class="p">(</span><span class="n">nbase</span><span class="p">,</span> <span class="n">ndelay</span><span class="p">,</span> <span class="n">delays</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Iterate over all baselines and use the Gibbs sampler to estimate the spectrum</span>
        <span class="k">for</span> <span class="n">lbi</span><span class="p">,</span> <span class="n">bi</span> <span class="ow">in</span> <span class="n">out_cont</span><span class="o">.</span><span class="n">spectrum</span><span class="p">[:]</span><span class="o">.</span><span class="n">enumerate</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Delay transforming baseline </span><span class="si">{</span><span class="n">bi</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">nbaselocal</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">nbase</span><span class="si">}</span><span class="s2"> total).&quot;</span>
            <span class="p">)</span>

            <span class="c1"># Get the local selections</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data_view</span><span class="o">.</span><span class="n">local_array</span><span class="p">[</span><span class="n">lbi</span><span class="p">]</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">weight_view</span><span class="o">.</span><span class="n">local_array</span><span class="p">[</span><span class="n">lbi</span><span class="p">]</span>

            <span class="c1"># Apply the cuts to the data</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cut_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Record this sample as bad</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_spectrum_mask</span><span class="p">:</span>
                    <span class="n">out_cont</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;spectrum_mask&quot;</span><span class="p">][</span><span class="n">bi</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">continue</span>

            <span class="n">data</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">nzf</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">t</span>

            <span class="n">spec</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">success</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_estimator</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">prior</span><span class="p">[</span><span class="n">lbi</span><span class="p">],</span> <span class="n">ndelay</span><span class="p">,</span> <span class="n">channel_ind</span><span class="p">[</span><span class="n">nzf</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># Save out the resulting spectrum, samples, and mask</span>
            <span class="n">out_cont</span><span class="o">.</span><span class="n">spectrum</span><span class="p">[</span><span class="n">bi</span><span class="p">]</span> <span class="o">=</span> <span class="n">spec</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_spectrum_mask</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">success</span><span class="p">:</span>
                <span class="n">out_cont</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;spectrum_mask&quot;</span><span class="p">][</span><span class="n">bi</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_samples</span><span class="p">:</span>
                <span class="n">nsamp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
                <span class="n">out_cont</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;spectrum_samples&quot;</span><span class="p">][:,</span> <span class="n">bi</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">out_cont</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;spectrum_samples&quot;</span><span class="p">][</span><span class="o">-</span><span class="n">nsamp</span><span class="p">:,</span> <span class="n">bi</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_spectrum_mask</span><span class="p">:</span>
            <span class="c1"># Record number of converged baselines for debugging info.</span>
            <span class="n">n_conv</span> <span class="o">=</span> <span class="n">nbase</span> <span class="o">-</span> <span class="n">out_cont</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;spectrum_mask&quot;</span><span class="p">][:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">allreduce</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n_conv</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">nbase</span><span class="si">}</span><span class="s2"> unflagged baselines.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out_cont</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_prior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbase</span><span class="p">,</span> <span class="n">ndelay</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get an initial estimate of the power spectrum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nbase : int</span>
<span class="sd">            Number of baselines.</span>
<span class="sd">        ndelay : int</span>
<span class="sd">            Number of delay samples.</span>
<span class="sd">        dtype : type | np.dtype | str</span>
<span class="sd">            Datatype for the sample.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">ndelay</span><span class="p">,</span> <span class="n">channel_ind</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use an estimator to calculate the power spectrum of a data slice.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spec : np.ndarray</span>
<span class="sd">            Estimated power spectrum</span>
<span class="sd">        samples : list[np.ndarray]</span>
<span class="sd">            Chain of samples. This can be length-one depending</span>
<span class="sd">            on the estimator</span>
<span class="sd">        success : bool</span>
<span class="sd">            Whether or not the estimator thinks the</span>
<span class="sd">            result is reasonable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>



<div class="viewcode-block" id="DelayPowerSpectrumGibbs">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.DelayPowerSpectrumGibbs">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DelayPowerSpectrumGibbs</span><span class="p">(</span><span class="n">DelayPowerSpectrumBase</span><span class="p">,</span> <span class="n">tasklib</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Use a Gibbs sampler to estimate the delay power spectrum.</span>

<span class="sd">    The spectrum returned is the median of the final half of the</span>
<span class="sd">    samples calulated.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    initial_amplitude : float, optional</span>
<span class="sd">        The Gibbs sampler will be initialized with a flat power spectrum with</span>
<span class="sd">        this amplitude. Default is 10.0</span>
<span class="sd">    median_frac : float, optional</span>
<span class="sd">        The returned power spectrum is the median of the last `median_frac`</span>
<span class="sd">        fraction of samples. Default is 0.5.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">initial_amplitude</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">10.0</span><span class="p">)</span>
    <span class="n">median_frac</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_prior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbase</span><span class="p">,</span> <span class="n">ndelay</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Start with a flat prior.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nbase</span><span class="p">,</span> <span class="n">ndelay</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_amplitude</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">ndelay</span><span class="p">,</span> <span class="n">channel_ind</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use a gibbs sampler to calculate a power spectrum.&quot;&quot;&quot;</span>
        <span class="n">samples</span><span class="p">,</span> <span class="n">success</span> <span class="o">=</span> <span class="n">delay_power_spectrum_gibbs</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">ndelay</span><span class="p">,</span>
            <span class="n">weight</span><span class="p">,</span>
            <span class="n">S</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_window</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">fsel</span><span class="o">=</span><span class="n">channel_ind</span><span class="p">,</span>
            <span class="n">niter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamp</span><span class="p">,</span>
            <span class="n">rng</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span>
            <span class="n">complex_timedomain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">complex_timedomain</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">nsamp_spec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamp</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">median_frac</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">samples</span><span class="p">:</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="o">-</span><span class="n">nsamp_spec</span><span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Estimator failed at the first sample. Set the spectrum</span>
            <span class="c1"># to the prior and flag it as bad</span>
            <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="n">S</span>

        <span class="k">return</span> <span class="n">spec</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">success</span></div>



<div class="viewcode-block" id="DelayPowerSpectrumNRML">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.DelayPowerSpectrumNRML">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DelayPowerSpectrumNRML</span><span class="p">(</span><span class="n">DelayPowerSpectrumBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Use a NRML method to estimate the delay power spectrum.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    maxpost_tol : float, optional</span>
<span class="sd">        The convergence tolerance used by scipy.optimize.minimize</span>
<span class="sd">        in the maximum likelihood estimator.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">maxpost_tol</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_prior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbase</span><span class="p">,</span> <span class="n">ndelay</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Start with a flat prior.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">nbase</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">ndelay</span><span class="p">,</span> <span class="n">channel_ind</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use a maximum likelihood to calculate a power spectrum.&quot;&quot;&quot;</span>
        <span class="n">samples</span><span class="p">,</span> <span class="n">success</span> <span class="o">=</span> <span class="n">delay_power_spectrum_maxpost</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">ndelay</span><span class="p">,</span>
            <span class="n">weight</span><span class="p">,</span>
            <span class="n">S</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_window</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">fsel</span><span class="o">=</span><span class="n">channel_ind</span><span class="p">,</span>
            <span class="n">maxiter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamp</span><span class="p">,</span>
            <span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">maxpost_tol</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">spec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">spec</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">success</span></div>



<div class="viewcode-block" id="DelayCrossPowerSpectrumEstimator">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.DelayCrossPowerSpectrumEstimator">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DelayCrossPowerSpectrumEstimator</span><span class="p">(</span>
    <span class="n">DelayPowerSpectrumGibbs</span><span class="p">,</span> <span class="n">tasklib</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomTask</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A delay cross power spectrum estimator.</span>

<span class="sd">    This takes multiple compatible `FreqContainer`s as inputs and will return a</span>
<span class="sd">    `DelayCrossSpectrum` container with the full pair-wise cross power spectrum.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_prepare_inputs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sslist</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">containers</span><span class="o">.</span><span class="n">FreqContainer</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sslist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No datasets passed.&quot;</span><span class="p">)</span>

        <span class="n">freq_ref</span> <span class="o">=</span> <span class="n">sslist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">freq</span>

        <span class="n">data_views</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">weight_views</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">coord_axes</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">sslist</span><span class="p">:</span>
            <span class="n">ss</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">freq</span> <span class="o">!=</span> <span class="n">freq_ref</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input containers must have the same frequencies.&quot;</span><span class="p">)</span>
            <span class="n">dv</span><span class="p">,</span> <span class="n">wv</span><span class="p">,</span> <span class="n">ca</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_prepare_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">coord_axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">coord_axes</span> <span class="o">==</span> <span class="n">ca</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Different axes found for the input containers.&quot;</span><span class="p">)</span>

            <span class="n">data_views</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dv</span><span class="p">)</span>
            <span class="n">weight_views</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wv</span><span class="p">)</span>
            <span class="n">coord_axes</span> <span class="o">=</span> <span class="n">ca</span>

        <span class="k">return</span> <span class="n">data_views</span><span class="p">,</span> <span class="n">weight_views</span><span class="p">,</span> <span class="n">coord_axes</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_create_output</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ss</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">containers</span><span class="o">.</span><span class="n">FreqContainer</span><span class="p">],</span>
        <span class="n">delays</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">coord_axes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ContainerPrototype</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the output container for the delay power spectrum.</span>

<span class="sd">        If `coord_axes` is a list of strings then it is assumed to be a list of the</span>
<span class="sd">        names of the folded axes. If it&#39;s an array then assume it is the actual axis</span>
<span class="sd">        definition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ssref</span> <span class="o">=</span> <span class="n">ss</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ndata</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span>

        <span class="c1"># If only one axis is being collapsed, use that as the baseline axis definition,</span>
        <span class="c1"># otherwise just use integer indices</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord_axes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">bl</span> <span class="o">=</span> <span class="n">ssref</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="n">coord_axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">ssref</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="n">ax</span><span class="p">])</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">coord_axes</span><span class="p">])</span>

        <span class="c1"># Initialise the spectrum container</span>
        <span class="n">delay_spec</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">DelayCrossSpectrum</span><span class="p">(</span>
            <span class="n">baseline</span><span class="o">=</span><span class="n">bl</span><span class="p">,</span>
            <span class="n">dataset</span><span class="o">=</span><span class="n">ndata</span><span class="p">,</span>
            <span class="n">delay</span><span class="o">=</span><span class="n">delays</span><span class="p">,</span>
            <span class="n">sample</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamp</span><span class="p">,</span>
            <span class="n">attrs_from</span><span class="o">=</span><span class="n">ssref</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">delay_spec</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;baseline&quot;</span><span class="p">)</span>
        <span class="n">delay_spec</span><span class="o">.</span><span class="n">spectrum</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Copy the index maps for all the flattened axes into the output container, and</span>
        <span class="c1"># write out their order into an attribute so we can reconstruct this easily</span>
        <span class="c1"># when loading in the spectrum</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord_axes</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">coord_axes</span><span class="p">:</span>
                <span class="n">delay_spec</span><span class="o">.</span><span class="n">create_index_map</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">ssref</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="n">ax</span><span class="p">])</span>
            <span class="n">delay_spec</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;baseline_axes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord_axes</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_samples</span><span class="p">:</span>
            <span class="n">delay_spec</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;spectrum_samples&quot;</span><span class="p">)</span>

        <span class="c1"># Save the frequency axis of the input data as an attribute in the output</span>
        <span class="c1"># container</span>
        <span class="n">delay_spec</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssref</span><span class="o">.</span><span class="n">freq</span>

        <span class="k">return</span> <span class="n">delay_spec</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_view</span><span class="p">,</span> <span class="n">weight_view</span><span class="p">,</span> <span class="n">out_cont</span><span class="p">,</span> <span class="n">delays</span><span class="p">,</span> <span class="n">channel_ind</span><span class="p">):</span>
        <span class="n">ndata</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_view</span><span class="p">)</span>
        <span class="n">ndelay</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">delays</span><span class="p">)</span>
        <span class="n">nbase</span> <span class="o">=</span> <span class="n">out_cont</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">initial_S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_prior</span><span class="p">(</span><span class="n">nbase</span><span class="p">,</span> <span class="n">ndelay</span><span class="p">,</span> <span class="n">delays</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">initial_S</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Expand the sample shape to match the number of datasets</span>
            <span class="n">initial_S</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">ndata</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="o">*</span> <span class="n">initial_S</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">initial_S</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">initial_S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ndata</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expected an initial sample with dimension 4 and </span><span class="si">{</span><span class="n">ndata</span><span class="si">}</span><span class="s2"> datasets. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Got sample with dimension </span><span class="si">{</span><span class="n">initial_S</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2"> and shape </span><span class="si">{</span><span class="n">initial_S</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Initialize the random number generator we&#39;ll use</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span>

        <span class="c1"># Iterate over all baselines and use the Gibbs sampler to estimate the spectrum</span>
        <span class="k">for</span> <span class="n">lbi</span><span class="p">,</span> <span class="n">bi</span> <span class="ow">in</span> <span class="n">out_cont</span><span class="o">.</span><span class="n">spectrum</span><span class="p">[:]</span><span class="o">.</span><span class="n">enumerate</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Delay transforming baseline </span><span class="si">{</span><span class="n">bi</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">nbase</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Get the local selections for all datasets and combine into a single array</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">d</span><span class="o">.</span><span class="n">local_array</span><span class="p">[</span><span class="n">lbi</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data_view</span><span class="p">])</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">w</span><span class="o">.</span><span class="n">local_array</span><span class="p">[</span><span class="n">lbi</span><span class="p">]</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">weight_view</span><span class="p">])</span>

            <span class="c1"># Apply the cuts to the data</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cut_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">nzf</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">t</span>

            <span class="n">spec</span> <span class="o">=</span> <span class="n">delay_spectrum_gibbs_cross</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">ndelay</span><span class="p">,</span>
                <span class="n">weight</span><span class="p">,</span>
                <span class="n">initial_S</span><span class="p">[</span><span class="n">lbi</span><span class="p">],</span>
                <span class="n">window</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_window</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">fsel</span><span class="o">=</span><span class="n">channel_ind</span><span class="p">[</span><span class="n">nzf</span><span class="p">],</span>
                <span class="n">niter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamp</span><span class="p">,</span>
                <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Take an average over the last half of the delay spectrum samples</span>
            <span class="c1"># (presuming that removes the burn-in)</span>
            <span class="n">spec_av</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">spec</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamp</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">out_cont</span><span class="o">.</span><span class="n">spectrum</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">spec_av</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_samples</span><span class="p">:</span>
                <span class="n">out_cont</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;spectrum_samples&quot;</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">spec</span>

        <span class="k">return</span> <span class="n">out_cont</span></div>



<span class="c1"># Raise a deprecation warning</span>
<div class="viewcode-block" id="DelayPowerSpectrumStokesIEstimator">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.DelayPowerSpectrumStokesIEstimator">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DelayPowerSpectrumStokesIEstimator</span><span class="p">(</span><span class="n">DelayPowerSpectrumGibbs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Deprecated.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="DelayPowerSpectrumStokesIEstimator.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.DelayPowerSpectrumStokesIEstimator.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">requires</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Raise a deprecation warnings.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">DeprecationWarning</span><span class="p">(</span>
            <span class="s2">&quot;`DelayPowerSpectrumStokesIEstimator` is deprecated. &quot;</span>
            <span class="s2">&quot;Use `draco.transform.StokesI` to generate Stokes I &quot;</span>
            <span class="s2">&quot;visibilities, then use `DelayPowerSpectrumGibbs` &quot;</span>
            <span class="s2">&quot;or `DelayPowerSpectrumNRML`.&quot;</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="DelayPowerSpectrumGeneralEstimator">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.DelayPowerSpectrumGeneralEstimator">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DelayPowerSpectrumGeneralEstimator</span><span class="p">(</span><span class="n">DelayPowerSpectrumGibbs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Deprecated.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="DelayPowerSpectrumGeneralEstimator.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.DelayPowerSpectrumGeneralEstimator.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">requires</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Raise a deprecation warnings.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">DeprecationWarning</span><span class="p">(</span>
            <span class="s2">&quot;`DelayPowerSpectrumGeneralEstimator` is deprecated. &quot;</span>
            <span class="s2">&quot;Use `DelayPowerSpectrumGibbs` or `DelayPowerSpectrumNRML`.&quot;</span>
        <span class="p">)</span></div>
</div>



<span class="c1"># -------------------------------------</span>
<span class="c1"># Functions to create Fourier matrices</span>
<span class="c1"># -------------------------------------</span>


<div class="viewcode-block" id="fourier_matrix_r2c">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.fourier_matrix_r2c">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fourier_matrix_r2c</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">fsel</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a Fourier matrix to represent a real to complex FFT.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : integer</span>
<span class="sd">        Length of timestream that we are transforming to. Must be even.</span>
<span class="sd">    fsel : array_like, optional</span>
<span class="sd">        Indexes of the frequency channels to include in the transformation</span>
<span class="sd">        matrix. By default, assume all channels.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Fr : np.ndarray</span>
<span class="sd">        An array performing the Fourier transform from a real time series to</span>
<span class="sd">        frequencies packed as alternating real and imaginary elements,</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fsel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fsel</span><span class="p">)</span>

    <span class="n">fa</span> <span class="o">=</span> <span class="n">fa</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="n">ta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

    <span class="n">Fr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="n">Fr</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">ta</span> <span class="o">*</span> <span class="n">fa</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">Fr</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">ta</span> <span class="o">*</span> <span class="n">fa</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Fr</span></div>



<div class="viewcode-block" id="fourier_matrix_c2r">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.fourier_matrix_c2r">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fourier_matrix_c2r</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">fsel</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a Fourier matrix to represent a complex to real FFT.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : integer</span>
<span class="sd">        Length of timestream that we are transforming to. Must be even.</span>
<span class="sd">    fsel : array_like, optional</span>
<span class="sd">        Indexes of the frequency channels to include in the transformation</span>
<span class="sd">        matrix. By default, assume all channels.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Fr : np.ndarray</span>
<span class="sd">        An array performing the Fourier transform from frequencies packed as</span>
<span class="sd">        alternating real and imaginary elements, to the real time series.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fsel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fsel</span><span class="p">)</span>

    <span class="n">fa</span> <span class="o">=</span> <span class="n">fa</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

    <span class="n">mul</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">fa</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">fa</span> <span class="o">==</span> <span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>

    <span class="n">ta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="n">Fr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">fa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="n">Fr</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">ta</span> <span class="o">*</span> <span class="n">fa</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">mul</span>
    <span class="n">Fr</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">ta</span> <span class="o">*</span> <span class="n">fa</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">mul</span>

    <span class="k">return</span> <span class="n">Fr</span></div>



<div class="viewcode-block" id="fourier_matrix_c2c">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.fourier_matrix_c2c">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fourier_matrix_c2c</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">fsel</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a Fourier matrix to represent a complex to complex FFT.</span>

<span class="sd">    These Fourier conventions match `numpy.fft.fft()`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : integer</span>
<span class="sd">        Length of timestream that we are transforming to.</span>
<span class="sd">    fsel : array_like, optional</span>
<span class="sd">        Indices of the frequency channels to include in the transformation</span>
<span class="sd">        matrix. By default, assume all channels.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    F : np.ndarray</span>
<span class="sd">        An array performing the Fourier transform from a complex time series to</span>
<span class="sd">        frequencies, with both input and output packed as alternating real and</span>
<span class="sd">        imaginary elements.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fsel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fsel</span><span class="p">)</span>

    <span class="n">fa</span> <span class="o">=</span> <span class="n">fa</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="n">ta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

    <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="n">arg</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">ta</span> <span class="o">*</span> <span class="n">fa</span> <span class="o">/</span> <span class="n">N</span>
    <span class="n">F</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="n">F</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">F</span></div>



<div class="viewcode-block" id="fourier_matrix">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.fourier_matrix">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fourier_matrix</span><span class="p">(</span><span class="n">N</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">fsel</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a Fourier matrix to represent a real to complex FFT.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : integer</span>
<span class="sd">        Length of timestream that we are transforming to. Must be even.</span>
<span class="sd">    fsel : array_like, optional</span>
<span class="sd">        Indexes of the frequency channels to include in the transformation</span>
<span class="sd">        matrix. By default, assume all channels.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Fr : np.ndarray</span>
<span class="sd">        An array performing the Fourier transform from a real time series to</span>
<span class="sd">        frequencies packed as alternating real and imaginary elements,</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fsel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fsel</span><span class="p">)</span>

    <span class="n">fa</span> <span class="o">=</span> <span class="n">fa</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="n">ta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">ta</span> <span class="o">*</span> <span class="n">fa</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_complex_to_alternating_real</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;View complex numbers as an array with alternating real and imaginary components.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : array_like</span>
<span class="sd">        Input array of complex numbers.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : array_like</span>
<span class="sd">        Output array of alternating real and imaginary components. These components are</span>
<span class="sd">        expanded along the last axis, such that if `array` has `N` complex elements in</span>
<span class="sd">        its last axis, `out` will have `2N` real elements.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_alternating_real_to_complex</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;View real numbers as complex, interpreted as alternating real and imag. components.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : array_like</span>
<span class="sd">        Input array of real numbers. Last axis must have even number of elements.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : array_like</span>
<span class="sd">        Output array of complex numbers, derived from compressing the last axis (if</span>
<span class="sd">        `array` has `N` real elements in the last axis, `out` will have `N/2` complex</span>
<span class="sd">        elements).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>


<span class="c1"># ----------------------------------------------------------------</span>
<span class="c1"># Implementation of delay transform and power spectrum algorithms</span>
<span class="c1"># ----------------------------------------------------------------</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_compute_delay_spectrum_inputs</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">Ni</span><span class="p">,</span> <span class="n">fsel</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">complex_timedomain</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute quantities needed for Gibbs sampling and/or Wiener filtering.</span>

<span class="sd">    These quantities are needed by both :func:`delay_power_spectrum_gibbs` and</span>
<span class="sd">    :func:`delay_spectrum_wiener_filter`, so we compute them in this separate routine.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">total_freq</span> <span class="o">=</span> <span class="n">N</span> <span class="k">if</span> <span class="n">complex_timedomain</span> <span class="k">else</span> <span class="n">N</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">fsel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fsel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">total_freq</span><span class="p">)</span>

    <span class="c1"># Construct the Fourier matrix</span>
    <span class="n">F</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">fourier_matrix_c2c</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">fsel</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">complex_timedomain</span>
        <span class="k">else</span> <span class="n">fourier_matrix_r2c</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">fsel</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Construct a view of the data with alternating real and imaginary parts</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">_complex_to_alternating_real</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Window the frequency data</span>
    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Construct the window function</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">fsel</span> <span class="o">/</span> <span class="n">total_freq</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">window_generalised</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Apply to the projection matrix and the data</span>
        <span class="n">F</span> <span class="o">*=</span> <span class="n">w</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">*=</span> <span class="n">w</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">complex_timedomain</span><span class="p">:</span>
        <span class="n">is_real_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">fsel</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">is_real_freq</span> <span class="o">=</span> <span class="p">(</span><span class="n">fsel</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">fsel</span> <span class="o">==</span> <span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Construct the Noise inverse array for the real and imaginary parts of the</span>
    <span class="c1"># frequency spectrum (taking into account that the zero and Nyquist frequencies are</span>
    <span class="c1"># strictly real if the delay spectrum is assumed to be real)</span>
    <span class="n">Ni_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Ni</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">Ni_r</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">is_real_freq</span><span class="p">,</span> <span class="n">Ni</span><span class="p">,</span> <span class="n">Ni</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">Ni_r</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">is_real_freq</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">Ni</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Create the transpose of the Fourier matrix weighted by the noise</span>
    <span class="c1"># (this is used multiple times)</span>
    <span class="n">FTNih</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">Ni_r</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">**</span> <span class="mf">0.5</span>
    <span class="n">FTNiF</span> <span class="o">=</span> <span class="n">FTNih</span> <span class="o">@</span> <span class="n">FTNih</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Pre-whiten the data to save doing it repeatedly</span>
    <span class="n">data</span> <span class="o">*=</span> <span class="n">Ni_r</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">**</span> <span class="mf">0.5</span>

    <span class="c1"># Return data and inverse-noise-weighted Fourier matrices</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">FTNih</span><span class="p">,</span> <span class="n">FTNiF</span>


<div class="viewcode-block" id="delay_power_spectrum_gibbs">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.delay_power_spectrum_gibbs">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">delay_power_spectrum_gibbs</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">N</span><span class="p">,</span>
    <span class="n">Ni</span><span class="p">,</span>
    <span class="n">initial_S</span><span class="p">,</span>
    <span class="n">window</span><span class="o">=</span><span class="s2">&quot;nuttall&quot;</span><span class="p">,</span>
    <span class="n">fsel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">niter</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
    <span class="n">rng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">complex_timedomain</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Estimate the delay power spectrum by Gibbs sampling.</span>

<span class="sd">    This routine estimates the spectrum at the `N` delay samples conjugate to</span>
<span class="sd">    an input frequency spectrum with ``N/2 + 1`` channels (if the delay spectrum is</span>
<span class="sd">    assumed real) or `N` channels (if the delay spectrum is assumed complex).</span>
<span class="sd">    A subset of these channels can be specified using the `fsel` argument.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.ndarray[:, freq]</span>
<span class="sd">        Data to estimate the delay spectrum of.</span>
<span class="sd">    N : int</span>
<span class="sd">        The length of the output delay spectrum. There are assumed to be `N/2 + 1`</span>
<span class="sd">        total frequency channels if assuming a real delay spectrum, or `N` channels</span>
<span class="sd">        for a complex delay spectrum.</span>
<span class="sd">    Ni : np.ndarray[freq]</span>
<span class="sd">        Inverse noise variance.</span>
<span class="sd">    initial_S : np.ndarray[delay]</span>
<span class="sd">        The initial delay power spectrum guess.</span>
<span class="sd">    window : one of {&#39;nuttall&#39;, &#39;blackman_nuttall&#39;, &#39;blackman_harris&#39;, None}, optional</span>
<span class="sd">        Apply an apodisation function. Default: &#39;nuttall&#39;.</span>
<span class="sd">    fsel : np.ndarray[freq], optional</span>
<span class="sd">        Indices of channels that we have data at. By default assume all channels.</span>
<span class="sd">    niter : int, optional</span>
<span class="sd">        Number of Gibbs samples to generate.</span>
<span class="sd">    rng : np.random.Generator, optional</span>
<span class="sd">        A generator to use to produce the random samples.</span>
<span class="sd">    complex_timedomain : bool, optional</span>
<span class="sd">        If True, assume input data arose from a complex timestream. If False, assume</span>
<span class="sd">        input data arose from a real timestream, such that the first and last frequency</span>
<span class="sd">        channels have purely real values. Default: False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    spec : list</span>
<span class="sd">        List of spectrum samples.</span>
<span class="sd">    success : bool</span>
<span class="sd">        True if the chain completed successfully.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get reference to RNG</span>
    <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>

    <span class="n">spec</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Pre-whiten and apply frequency window to data, and compute F^dagger N^{-1/2}</span>
    <span class="c1"># and F^dagger N^{-1} F</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">FTNih</span><span class="p">,</span> <span class="n">FTNiF</span> <span class="o">=</span> <span class="n">_compute_delay_spectrum_inputs</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">Ni</span><span class="p">,</span> <span class="n">fsel</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">complex_timedomain</span>
    <span class="p">)</span>

    <span class="c1"># Set the initial guess for the delay power spectrum.</span>
    <span class="n">S_samp</span> <span class="o">=</span> <span class="n">initial_S</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_draw_signal_sample_f</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
        <span class="c1"># Draw a random sample of the signal (delay spectrum) assuming a Gaussian model</span>
        <span class="c1"># with a given delay power spectrum `S`. Do this using the perturbed Wiener</span>
        <span class="c1"># filter approach</span>

        <span class="c1"># This method is generally faster unless there are very few frequencies</span>

        <span class="n">Si</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

        <span class="c1"># Construct the Wiener covariance</span>
        <span class="k">if</span> <span class="n">complex_timedomain</span><span class="p">:</span>
            <span class="c1"># If delay spectrum is complex, extend S to correspond to the individual</span>
            <span class="c1"># real and imaginary components of the delay spectrum, each of which have</span>
            <span class="c1"># power spectrum equal to 0.5 times the power spectrum of the complex</span>
            <span class="c1"># delay spectrum, if the statistics are circularly symmetric</span>
            <span class="c1"># Multply by 2 here since we&#39;ve already inverted S</span>
            <span class="n">Si</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">Si</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># This is faster than creating the full diagonal Si matrix</span>
        <span class="n">Ci</span> <span class="o">=</span> <span class="n">FTNiF</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ii-&gt;i&quot;</span><span class="p">,</span> <span class="n">Ci</span><span class="p">)[:]</span> <span class="o">+=</span> <span class="n">Si</span>
        <span class="c1"># Use a cholesky solve which is probably the fastest option here</span>
        <span class="n">CiL</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">cho_factor</span><span class="p">(</span><span class="n">Ci</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite_a</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Draw random vectors that form the perturbations</span>
        <span class="k">if</span> <span class="n">complex_timedomain</span><span class="p">:</span>
            <span class="c1"># If delay spectrum is complex, draw for real and imaginary components</span>
            <span class="c1"># separately</span>
            <span class="n">w1</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w1</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">w2</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># Construct the random signal sample by forming a perturbed vector and</span>
        <span class="c1"># then doing a matrix solve</span>
        <span class="c1"># Try to re-use existing arrays as much as possible</span>
        <span class="n">w2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">w2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">w2</span><span class="p">)</span>
        <span class="n">w1Sih</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">w1</span><span class="p">,</span> <span class="p">(</span><span class="n">Si</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">w1</span><span class="p">)</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">w1Sih</span><span class="p">,</span> <span class="p">(</span><span class="n">FTNih</span> <span class="o">@</span> <span class="n">w2d</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="n">w1Sih</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">la</span><span class="o">.</span><span class="n">cho_solve</span><span class="p">(</span><span class="n">CiL</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite_b</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_draw_signal_sample_t</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
        <span class="c1"># This method is fastest if the number of delays is significantly</span>
        <span class="c1"># larger than the number of frequencies.</span>

        <span class="n">Sh</span> <span class="o">=</span> <span class="n">S</span><span class="o">**</span><span class="mf">0.5</span>

        <span class="c1"># Construct various dependent matrices</span>
        <span class="k">if</span> <span class="n">complex_timedomain</span><span class="p">:</span>
            <span class="c1"># If delay spectrum is complex, extend S to correspond to the individual</span>
            <span class="c1"># real and imaginary components of the delay spectrum, each of which have</span>
            <span class="c1"># power spectrum equal to 0.5 times the power spectrum of the complex</span>
            <span class="c1"># delay spectrum, if the statistics are circularly symmetric</span>
            <span class="n">Sh</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">Sh</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Draw random vectors that form the perturbations</span>
        <span class="k">if</span> <span class="n">complex_timedomain</span><span class="p">:</span>
            <span class="c1"># If delay spectrum is complex, draw for real and imaginary components</span>
            <span class="c1"># separately</span>
            <span class="n">w1</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w1</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">w2</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">Rt</span> <span class="o">=</span> <span class="n">FTNih</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">Rt</span> <span class="o">*=</span> <span class="n">Sh</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">Rt</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>

        <span class="c1"># Perform the solve step (rather than explicitly using the inverse)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">w2</span><span class="p">,</span> <span class="n">R</span> <span class="o">@</span> <span class="n">w1</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">w2</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">+=</span> <span class="n">data</span>

        <span class="n">Ci</span> <span class="o">=</span> <span class="n">R</span> <span class="o">@</span> <span class="n">Rt</span>
        <span class="c1"># Add an identity</span>
        <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ii-&gt;i&quot;</span><span class="p">,</span> <span class="n">Ci</span><span class="p">)[:]</span> <span class="o">+=</span> <span class="mf">1.0</span>

        <span class="n">CiL</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">cho_factor</span><span class="p">(</span><span class="n">Ci</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite_a</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">cho_solve</span><span class="p">(</span><span class="n">CiL</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite_b</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Sh</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="p">((</span><span class="n">Rt</span> <span class="o">@</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">w1</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_draw_ps_sample</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="c1"># Draw a random delay power spectrum sample assuming the signal</span>
        <span class="c1"># is Gaussian and we have a flat prior on the power spectrum.</span>
        <span class="c1"># This means drawing from a inverse chi^2.</span>

        <span class="n">S_hat</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">complex_timedomain</span><span class="p">:</span>
            <span class="c1"># If delay spectrum is complex, combine real and imaginary components</span>
            <span class="c1"># stored in d, such that variance below is variance of complex spectrum</span>
            <span class="c1"># It&#39;s computationally faster to do this operation after taking</span>
            <span class="c1"># tje variance since it&#39;s a significantly smaller array, and we&#39;re using</span>
            <span class="c1"># a real/complex alternating float view of the complex dara</span>
            <span class="n">S_hat</span> <span class="o">=</span> <span class="n">S_hat</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">S_hat</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">chi2</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">chisquare</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">S_hat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">S_hat</span> <span class="o">*</span> <span class="n">df</span> <span class="o">/</span> <span class="n">chi2</span>

    <span class="c1"># Select the method to use for the signal sample based on how many frequencies</span>
    <span class="c1"># versus delays there are</span>
    <span class="n">_draw_signal_sample</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">_draw_signal_sample_f</span> <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fsel</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span> <span class="k">else</span> <span class="n">_draw_signal_sample_t</span>
    <span class="p">)</span>

    <span class="c1"># Perform the Gibbs sampling iteration for a given number of loops and</span>
    <span class="c1"># return the power spectrum output of them.</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">d_samp</span> <span class="o">=</span> <span class="n">_draw_signal_sample</span><span class="p">(</span><span class="n">S_samp</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
            <span class="c1"># Covariance is not positive-definite (is this expected?)</span>
            <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">break</span>

        <span class="n">S_samp</span> <span class="o">=</span> <span class="n">_draw_ps_sample</span><span class="p">(</span><span class="n">d_samp</span><span class="p">)</span>

        <span class="n">spec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S_samp</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">spec</span><span class="p">,</span> <span class="n">success</span></div>



<div class="viewcode-block" id="delay_spectrum_gibbs_cross">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.delay_spectrum_gibbs_cross">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">delay_spectrum_gibbs_cross</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">N</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">Ni</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">initial_S</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;nuttall&quot;</span><span class="p">,</span>
    <span class="n">fsel</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">niter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
    <span class="n">rng</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">Generator</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Estimate the delay power spectrum by Gibbs sampling.</span>

<span class="sd">    This routine estimates the spectrum at the `N` delay samples conjugate to</span>
<span class="sd">    an input frequency spectrum with ``N/2 + 1`` channels (if the delay spectrum is</span>
<span class="sd">    assumed real) or `N` channels (if the delay spectrum is assumed complex).</span>
<span class="sd">    A subset of these channels can be specified using the `fsel` argument.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data</span>
<span class="sd">        A 3D array of [dataset, sample, freq].  The delay cross-power spectrum of these</span>
<span class="sd">        will be calculated.</span>
<span class="sd">    N</span>
<span class="sd">        The length of the output delay spectrum. There are assumed to be `N/2 + 1`</span>
<span class="sd">        total frequency channels if assuming a real delay spectrum, or `N` channels</span>
<span class="sd">        for a complex delay spectrum.</span>
<span class="sd">    Ni</span>
<span class="sd">        Inverse noise variance as a 3D [dataset, sample, freq] array.</span>
<span class="sd">    initial_S</span>
<span class="sd">        The initial delay cross-power spectrum guess. A 3D array of [data1, data2,</span>
<span class="sd">        delay].</span>
<span class="sd">    window : one of {&#39;nuttall&#39;, &#39;blackman_nuttall&#39;, &#39;blackman_harris&#39;, None}, optional</span>
<span class="sd">        Apply an apodisation function. Default: &#39;nuttall&#39;.</span>
<span class="sd">    fsel</span>
<span class="sd">        Indices of channels that we have data at. By default assume all channels.</span>
<span class="sd">    niter</span>
<span class="sd">        Number of Gibbs samples to generate.</span>
<span class="sd">    rng</span>
<span class="sd">        A generator to use to produce the random samples.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    spec : list</span>
<span class="sd">        List of cross-power spectrum samples.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get reference to RNG</span>

    <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>

    <span class="n">spec</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">nd</span><span class="p">,</span> <span class="n">nsamp</span><span class="p">,</span> <span class="n">Nf</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">if</span> <span class="n">fsel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fsel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Nf</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">fsel</span><span class="p">)</span> <span class="o">!=</span> <span class="n">Nf</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Length of frequency selection must match frequencies passed. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">fsel</span><span class="p">)</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Construct the Fourier matrix</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">fourier_matrix</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">fsel</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">nd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need at least one set of data&quot;</span><span class="p">)</span>

    <span class="c1"># We want the sample axis to be last</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Window the frequency data</span>
    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Construct the window function</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">fsel</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">N</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">window_generalised</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>

        <span class="c1"># Apply to the projection matrix and the data</span>
        <span class="n">F</span> <span class="o">*=</span> <span class="n">w</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">*=</span> <span class="n">w</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="c1"># Create the transpose of the Fourier matrix weighted by the noise</span>
    <span class="c1"># (this is used multiple times)</span>
    <span class="c1"># This is packed as a single freq -&gt; delay projection per dataset</span>
    <span class="n">FTNih</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">Ni</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">**</span> <span class="mf">0.5</span>

    <span class="c1"># This should be an array for each dataset i of F_i^H N_i^{-1} F_i</span>
    <span class="n">FTNiF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nd</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">):</span>
        <span class="n">FTNiF</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">FTNih</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">@</span> <span class="n">FTNih</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>

    <span class="c1"># Pre-whiten the data to save doing it repeatedly</span>
    <span class="n">data</span> <span class="o">*=</span> <span class="n">Ni</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">**</span> <span class="mf">0.5</span>

    <span class="c1"># Set the initial guess for the delay power spectrum.</span>
    <span class="n">S_samp</span> <span class="o">=</span> <span class="n">initial_S</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_draw_signal_sample_f</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
        <span class="c1"># Draw a random sample of the signal (delay spectrum) assuming a Gaussian model</span>
        <span class="c1"># with a given delay power spectrum `S`. Do this using the perturbed Wiener</span>
        <span class="c1"># filter approach</span>

        <span class="c1"># This method is fastest if the number of frequencies is larger than the number</span>
        <span class="c1"># of delays we are solving for. Typically this isn&#39;t true, so we probably want</span>
        <span class="c1"># `_draw_signal_sample_t`</span>

        <span class="n">Si</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
        <span class="n">Sh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="n">nd</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">S</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">inv</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">S</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ii</span><span class="p">])</span>
            <span class="n">Si</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv</span>
            <span class="n">Sh</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">S</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ii</span><span class="p">],</span> <span class="n">lower</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">Ci</span> <span class="o">=</span> <span class="n">FTNiF</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">):</span>
                <span class="n">Ci</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Si</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">])</span>

        <span class="n">w1</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">standard_complex_normal</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="n">nsamp</span><span class="p">),</span> <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>
        <span class="n">w2</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">standard_complex_normal</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>

        <span class="c1"># Construct the random signal sample by forming a perturbed vector and</span>
        <span class="c1"># then doing a matrix solve</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">FTNih</span> <span class="o">@</span> <span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="n">w2</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">w1s</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">solve_triangular</span><span class="p">(</span>
                <span class="n">Sh</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                <span class="n">w1</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                <span class="n">overwrite_b</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">lower</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">y</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">+=</span> <span class="n">w1s</span>
            <span class="c1"># NOTE: Other combinations that you might think would work don&#39;t appear to</span>
            <span class="c1"># be stable. Don&#39;t try these:</span>
            <span class="c1"># y[:, ii] += Si[:, :, ii] @ Sh[:, :, ii] @ w1[:, ii]</span>
            <span class="c1"># y[:, ii] += Shi[:, :, ii] @ w1[:, ii]</span>

        <span class="n">cf</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">cho_factor</span><span class="p">(</span>
            <span class="n">Ci</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nd</span> <span class="o">*</span> <span class="n">N</span><span class="p">,</span> <span class="n">nd</span> <span class="o">*</span> <span class="n">N</span><span class="p">),</span>
            <span class="n">overwrite_a</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">la</span><span class="o">.</span><span class="n">cho_solve</span><span class="p">(</span>
            <span class="n">cf</span><span class="p">,</span>
            <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nd</span> <span class="o">*</span> <span class="n">N</span><span class="p">,</span> <span class="n">nsamp</span><span class="p">),</span>
            <span class="n">overwrite_b</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">nsamp</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_draw_signal_sample_t</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
        <span class="c1"># This method is fastest if the number of delays is larger than the number of</span>
        <span class="c1"># frequencies. This is usually the regime we are in.</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Drawing samples in the time basis not yet written.&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_draw_ps_sample</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="c1"># Draw a random delay power spectrum sample assuming the signal is Gaussian and</span>
        <span class="c1"># we have a flat prior on the power spectrum.</span>
        <span class="c1"># This means drawing from a inverse chi^2.</span>

        <span class="c1"># Estimate the sample covariance</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nd</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">S</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">d</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">],</span> <span class="n">bias</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Then in place draw a sample of the true covariance from the posterior which</span>
        <span class="c1"># is an inverse Wishart</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">Si</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">S</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ii</span><span class="p">])</span>
            <span class="n">Si_samp</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">complex_wishart</span><span class="p">(</span><span class="n">Si</span><span class="p">,</span> <span class="n">nsamp</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span> <span class="o">/</span> <span class="n">nsamp</span>
            <span class="n">S</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">Si_samp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">S</span>

    <span class="c1"># Select the method to use for the signal sample based on how many frequencies</span>
    <span class="c1"># versus delays there are. At the moment only the _f method is implemented.</span>
    <span class="n">_draw_signal_sample</span> <span class="o">=</span> <span class="n">_draw_signal_sample_f</span>

    <span class="c1"># Perform the Gibbs sampling iteration for a given number of loops and</span>
    <span class="c1"># return the power spectrum output of them.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
            <span class="n">d_samp</span> <span class="o">=</span> <span class="n">_draw_signal_sample</span><span class="p">(</span><span class="n">S_samp</span><span class="p">)</span>
            <span class="n">S_samp</span> <span class="o">=</span> <span class="n">_draw_ps_sample</span><span class="p">(</span><span class="n">d_samp</span><span class="p">)</span>

            <span class="n">spec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S_samp</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">la</span><span class="o">.</span><span class="n">LinAlgError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Exiting earlier as singular&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

    <span class="k">return</span> <span class="n">spec</span></div>



<div class="viewcode-block" id="delay_spectrum_fft">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.delay_spectrum_fft">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">delay_spectrum_fft</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s2">&quot;nuttall&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Estimate the delay transform from an input frequency spectrum by IFFT.</span>

<span class="sd">    This routine makes no attempt to account for data masking, and only</span>
<span class="sd">    supports complex to complex fft.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.ndarray[nsample, freq]</span>
<span class="sd">        Data to estimate the delay spectrum of.</span>
<span class="sd">    N : int</span>
<span class="sd">        The length of the output delay spectrum. There are assumed to be `N/2 + 1`</span>
<span class="sd">        total frequency channels if assuming a real delay spectrum, or `N` channels</span>
<span class="sd">        for a complex delay spectrum.</span>
<span class="sd">    window : one of {&#39;nuttall&#39;, &#39;blackman_nuttall&#39;, &#39;blackman_harris&#39;, None}, optional</span>
<span class="sd">        Apply an apodisation function. Default: &#39;nuttall&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y_spec : np.ndarray[nsample, ndelay]</span>
<span class="sd">        Delay spectrum for each element of the `sample` axis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">window_generalised</span><span class="p">(</span><span class="n">wx</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">*=</span> <span class="n">window</span>

    <span class="k">return</span> <span class="n">fft</span><span class="o">.</span><span class="n">fftw</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axes</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span></div>



<div class="viewcode-block" id="delay_spectrum_wiener_filter">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.delay_spectrum_wiener_filter">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">delay_spectrum_wiener_filter</span><span class="p">(</span>
    <span class="n">delay_PS</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">Ni</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s2">&quot;nuttall&quot;</span><span class="p">,</span> <span class="n">fsel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">complex_timedomain</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Estimate the delay spectrum from an input frequency spectrum by Wiener filtering.</span>

<span class="sd">    This routine estimates the spectrum at the `N` delay samples conjugate to</span>
<span class="sd">    an input frequency spectrum with ``N/2 + 1`` channels (if the delay spectrum is</span>
<span class="sd">    assumed real) or `N` channels (if the delay spectrum is assumed complex).</span>
<span class="sd">    A subset of these channels can be specified using the `fsel` argument.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    delay_PS : np.ndarray[ndelay]</span>
<span class="sd">        Delay power spectrum to use for the signal covariance in the Wiener filter.</span>
<span class="sd">    data : np.ndarray[nsample, freq]</span>
<span class="sd">        Data to estimate the delay spectrum of.</span>
<span class="sd">    N : int</span>
<span class="sd">        The length of the output delay spectrum. There are assumed to be `N/2 + 1`</span>
<span class="sd">        total frequency channels if assuming a real delay spectrum, or `N` channels</span>
<span class="sd">        for a complex delay spectrum.</span>
<span class="sd">    Ni : np.ndarray[freq]</span>
<span class="sd">        Inverse noise variance.</span>
<span class="sd">    fsel : np.ndarray[freq], optional</span>
<span class="sd">        Indices of channels that we have data at. By default assume all channels.</span>
<span class="sd">    window : one of {&#39;nuttall&#39;, &#39;blackman_nuttall&#39;, &#39;blackman_harris&#39;, None}, optional</span>
<span class="sd">        Apply an apodisation function. Default: &#39;nuttall&#39;.</span>
<span class="sd">    complex_timedomain : bool, optional</span>
<span class="sd">        If True, assume input data arose from a complex timestream. If False, assume</span>
<span class="sd">        input data arose from a real timestream, such that the first and last frequency</span>
<span class="sd">        channels have purely real values. Default: False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y_spec : np.ndarray[nsample, ndelay]</span>
<span class="sd">        Delay spectrum for each element of the `sample` axis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Pre-whiten and apply frequency window to data, and compute F^dagger N^{-1/2}</span>
    <span class="c1"># and F^dagger N^{-1} F</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">FTNih</span><span class="p">,</span> <span class="n">FTNiF</span> <span class="o">=</span> <span class="n">_compute_delay_spectrum_inputs</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">Ni</span><span class="p">,</span> <span class="n">fsel</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">complex_timedomain</span>
    <span class="p">)</span>

    <span class="c1"># Apply F^dagger N^{-1/2} to input frequency spectrum</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">FTNih</span> <span class="o">@</span> <span class="n">data</span>

    <span class="c1"># Get the inverse signal variance</span>
    <span class="n">Si</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">delay_PS</span><span class="p">)</span>

    <span class="c1"># Construct the Wiener covariance</span>
    <span class="k">if</span> <span class="n">complex_timedomain</span><span class="p">:</span>
        <span class="c1"># If delay spectrum is complex, extend delay_PS to correspond to the individual</span>
        <span class="c1"># real and imaginary components of the delay spectrum, each of which have</span>
        <span class="c1"># power spectrum equal to 0.5 times the power spectrum of the complex</span>
        <span class="c1"># delay spectrum, if the statistics are circularly symmetric</span>
        <span class="n">Si</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">Si</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Add the inverse signal component</span>
    <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ii-&gt;i&quot;</span><span class="p">,</span> <span class="n">FTNiF</span><span class="p">)[:]</span> <span class="o">+=</span> <span class="n">Si</span>
    <span class="c1"># Do a cholesky decomposition of the covariance.</span>
    <span class="c1"># This solve is pretty much always faster than a</span>
    <span class="c1"># standard one</span>
    <span class="n">CiL</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">cho_factor</span><span class="p">(</span><span class="n">FTNiF</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># Solve the linear equation for the Wiener-filtered spectrum,</span>
    <span class="c1"># and transpose to [sample_axis, delay]</span>
    <span class="n">y_spec</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">cho_solve</span><span class="p">(</span><span class="n">CiL</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="n">complex_timedomain</span><span class="p">:</span>
        <span class="n">y_spec</span> <span class="o">=</span> <span class="n">_alternating_real_to_complex</span><span class="p">(</span><span class="n">y_spec</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">y_spec</span></div>



<span class="c1"># ----------------------------------------</span>
<span class="c1"># Helper functions for array manipulation</span>
<span class="c1"># ----------------------------------------</span>


<div class="viewcode-block" id="match_axes">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.match_axes">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">match_axes</span><span class="p">(</span><span class="n">dset1</span><span class="p">,</span> <span class="n">dset2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make sure that dset2 has the same set of axes as dset1.</span>

<span class="sd">    Sometimes the weights are missing axes (usually where the entries would all be</span>
<span class="sd">    the same), we need to map these into one another and expand the weights to the</span>
<span class="sd">    same size as the visibilities. This assumes that the vis/weight axes are in the</span>
<span class="sd">    same order when present</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dset1</span>
<span class="sd">        The dataset with more axes.</span>
<span class="sd">    dset2</span>
<span class="sd">        The dataset with a subset of axes. For the moment these are assumed to be in</span>
<span class="sd">        the same order.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dset2_view</span>
<span class="sd">        A view of dset2 with length-1 axes inserted to match the axes missing from</span>
<span class="sd">        dset1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">axes1</span> <span class="o">=</span> <span class="n">dset1</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span>
    <span class="n">axes2</span> <span class="o">=</span> <span class="n">dset2</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span>
    <span class="n">bcast_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes2</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dset2</span><span class="p">[:][</span><span class="n">bcast_slice</span><span class="p">]</span></div>



<div class="viewcode-block" id="flatten_axes">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.delay.html#draco.analysis.delay.flatten_axes">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">flatten_axes</span><span class="p">(</span>
    <span class="n">dset</span><span class="p">:</span> <span class="n">memdata</span><span class="o">.</span><span class="n">MemDatasetDistributed</span><span class="p">,</span>
    <span class="n">axes_to_keep</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">match_dset</span><span class="p">:</span> <span class="n">memdata</span><span class="o">.</span><span class="n">MemDatasetDistributed</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Move the specified axes of the dataset to the back, and flatten all others.</span>

<span class="sd">    Optionally this will add length-1 axes to match the axes of another dataset.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dset</span>
<span class="sd">        The dataset to reshape.</span>
<span class="sd">    axes_to_keep</span>
<span class="sd">        The names of the axes to keep.</span>
<span class="sd">    match_dset</span>
<span class="sd">        An optional dataset to match the shape of.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    flat_array</span>
<span class="sd">        The MPIArray representing the re-arranged dataset. Distributed along the</span>
<span class="sd">        flattened axis.</span>
<span class="sd">    flat_axes</span>
<span class="sd">        The names of the flattened axes from slowest to fastest varying.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find the relevant axis positions</span>
    <span class="n">data_axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span>

    <span class="c1"># Check that the requested datasets actually exist</span>
    <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes_to_keep</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data_axes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Specified </span><span class="si">{</span><span class="n">axis</span><span class="si">=}</span><span class="s2"> not present in dataset.&quot;</span><span class="p">)</span>

    <span class="c1"># If specified, add extra axes to match the shape of the given dataset</span>
    <span class="k">if</span> <span class="n">match_dset</span> <span class="ow">and</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">match_dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]):</span>
        <span class="n">dset_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">match_dset</span><span class="p">[:])</span>
        <span class="n">dset_full</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">match_axes</span><span class="p">(</span><span class="n">match_dset</span><span class="p">,</span> <span class="n">dset</span><span class="p">)</span>

    <span class="n">axes_ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_axes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes_to_keep</span><span class="p">]</span>

    <span class="c1"># Get an MPIArray and make sure it is distributed along one of the preserved axes</span>
    <span class="n">data_array</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[:]</span>
    <span class="k">if</span> <span class="n">data_array</span><span class="o">.</span><span class="n">axis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes_ind</span><span class="p">:</span>
        <span class="n">data_array</span> <span class="o">=</span> <span class="n">data_array</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="n">axes_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Create a view of the dataset with the relevant axes at the back,</span>
    <span class="c1"># and all others moved to the front (retaining their relative order)</span>
    <span class="n">other_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_axes</span><span class="p">))</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes_ind</span><span class="p">]</span>
    <span class="n">data_array</span> <span class="o">=</span> <span class="n">data_array</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">other_axes</span> <span class="o">+</span> <span class="n">axes_ind</span><span class="p">)</span>

    <span class="c1"># Get the explicit shape of the axes that will remain, but set the distributed one</span>
    <span class="c1"># to None (as will be needed for MPIArray.reshape)</span>
    <span class="n">remaining_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data_array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">remaining_shape</span><span class="p">[</span><span class="n">data_array</span><span class="o">.</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">new_ax_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">remaining_shape</span><span class="p">[:</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">axes_ind</span><span class="p">)])</span>
    <span class="n">remaining_shape</span> <span class="o">=</span> <span class="n">remaining_shape</span><span class="p">[</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">axes_ind</span><span class="p">)</span> <span class="p">:]</span>

    <span class="c1"># Reshape the MPIArray, and redistribute over the flattened axis</span>
    <span class="n">data_array</span> <span class="o">=</span> <span class="n">data_array</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">new_ax_len</span><span class="p">,</span> <span class="o">*</span><span class="n">remaining_shape</span><span class="p">))</span>
    <span class="n">data_array</span> <span class="o">=</span> <span class="n">data_array</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">other_axes_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_axes</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">other_axes</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">data_array</span><span class="p">,</span> <span class="n">other_axes_names</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_move_front</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="c1"># Move the specified axis to the front and flatten to give a 2D array</span>
    <span class="n">new_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_inv_move_front</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="c1"># Move the first axis back to it&#39;s original position and return the original shape,</span>
    <span class="c1"># i.e. reverse the above operation</span>
    <span class="n">rshape</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="o">*</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">],</span> <span class="o">*</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:])</span>
    <span class="n">new_arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rshape</span><span class="p">)</span>
    <span class="n">new_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">new_arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_take_view</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="c1"># Like np.take but returns a view (instead of a copy), but only supports a scalar</span>
    <span class="c1"># index</span>
    <span class="n">sl</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="n">axis</span>
    <span class="k">return</span> <span class="n">arr</span><span class="p">[(</span><span class="o">*</span><span class="n">sl</span><span class="p">,</span> <span class="n">ind</span><span class="p">)]</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016, Richard Shaw.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>