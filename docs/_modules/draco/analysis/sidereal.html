

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>draco.analysis.sidereal &mdash; draco 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            draco
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev.html">Development Guidelines</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">draco</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">draco.analysis.sidereal</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for draco.analysis.sidereal</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Take timestream data and regridding it into sidereal days which can be stacked.</span>

<span class="sd">Usage</span>
<span class="sd">=====</span>

<span class="sd">Generally you would want to use these tasks together. Sending time stream data</span>
<span class="sd">into  :class:`SiderealGrouper`, then feeding that into</span>
<span class="sd">:class:`SiderealRegridder` to grid onto each sidereal day, and then into</span>
<span class="sd">:class:`SiderealStacker` if you want to combine the different days.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">inspect</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.linalg</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">la</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">caput</span><span class="w"> </span><span class="kn">import</span> <span class="n">config</span><span class="p">,</span> <span class="n">mpiarray</span><span class="p">,</span> <span class="n">tod</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cora.util</span><span class="w"> </span><span class="kn">import</span> <span class="n">units</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">..core</span><span class="w"> </span><span class="kn">import</span> <span class="n">containers</span><span class="p">,</span> <span class="n">io</span><span class="p">,</span> <span class="n">task</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..util</span><span class="w"> </span><span class="kn">import</span> <span class="n">gaussian_process</span><span class="p">,</span> <span class="n">regrid</span><span class="p">,</span> <span class="n">tools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.interpolate</span><span class="w"> </span><span class="kn">import</span> <span class="n">_inv_move_front</span><span class="p">,</span> <span class="n">_move_front</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">LanczosRegridder</span>


<div class="viewcode-block" id="SiderealGrouper">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.sidereal.html#draco.analysis.sidereal.SiderealGrouper">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SiderealGrouper</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Group individual timestreams together into whole Sidereal days.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    padding : float</span>
<span class="sd">        Extra amount of a sidereal day to pad each timestream by. Useful for</span>
<span class="sd">        getting rid of interpolation artifacts.</span>
<span class="sd">    offset : float</span>
<span class="sd">        Time in seconds to subtract before determining the LSD.  Useful if the</span>
<span class="sd">        desired output is not a full sideral stream, but rather a narrow window</span>
<span class="sd">        around source transits on different sideral days.  In that case, one</span>
<span class="sd">        should set this quantity to `240 * (source_ra - 180)`.</span>
<span class="sd">    min_day_length : float</span>
<span class="sd">        Require at least this fraction of a full sidereal day to process.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">padding</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">min_day_length</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.10</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_timestream_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_lsd</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="SiderealGrouper.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.sidereal.html#draco.analysis.sidereal.SiderealGrouper.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">manager</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the local observers position.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        manager : :class:`~caput.time.Observer`</span>
<span class="sd">            An Observer object holding the geographic location of the telescope.</span>
<span class="sd">            Note that :class:`~drift.core.TransitTelescope` instances are also</span>
<span class="sd">            Observers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Need an observer object holding the geographic location of the telescope.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observer</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">get_telescope</span><span class="p">(</span><span class="n">manager</span><span class="p">)</span></div>


<div class="viewcode-block" id="SiderealGrouper.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.sidereal.html#draco.analysis.sidereal.SiderealGrouper.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tstream</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load in each sidereal day.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tstream : containers.TimeStream</span>
<span class="sd">            Timestream to group together.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ts : containers.TimeStream or None</span>
<span class="sd">            Returns the timestream of each sidereal day when we have received</span>
<span class="sd">            the last file, otherwise returns :obj:`None`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This is the start and the end of the LSDs of the file only if padding</span>
        <span class="c1"># is chosen to be 0 (default). If padding is set to some value then &#39;lsd_start&#39;</span>
        <span class="c1"># will actually correspond to the start of of the requested time frame (incl</span>
        <span class="c1"># padding)</span>
        <span class="n">lsd_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">observer</span><span class="o">.</span><span class="n">unix_to_lsd</span><span class="p">(</span><span class="n">tstream</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">lsd_end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">observer</span><span class="o">.</span><span class="n">unix_to_lsd</span><span class="p">(</span><span class="n">tstream</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># If current_lsd is None then this is the first time we&#39;ve run</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_lsd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_lsd</span> <span class="o">=</span> <span class="n">lsd_start</span>

        <span class="c1"># If this file started during the current lsd add it onto the list</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_lsd</span> <span class="o">==</span> <span class="n">lsd_start</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_timestream_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tstream</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Adding file into group for LSD:</span><span class="si">%i</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">lsd_start</span><span class="p">)</span>

        <span class="c1"># If this file ends during a later LSD then we need to process the</span>
        <span class="c1"># current list and restart the system</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_lsd</span> <span class="o">&lt;</span> <span class="n">lsd_end</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Concatenating files for LSD:</span><span class="si">%i</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_lsd</span><span class="p">)</span>

            <span class="c1"># Combine timestreams into a single container for the whole day this</span>
            <span class="c1"># could get returned as None if there wasn&#39;t enough data</span>
            <span class="n">tstream_all</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_current_lsd</span><span class="p">()</span>

            <span class="c1"># Reset list and current LSD for the new file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_timestream_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">tstream</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_lsd</span> <span class="o">=</span> <span class="n">lsd_end</span>

            <span class="k">return</span> <span class="n">tstream_all</span>

        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="SiderealGrouper.process_finish">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.sidereal.html#draco.analysis.sidereal.SiderealGrouper.process_finish">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process_finish</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the final sidereal day.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ts : containers.TimeStream or None</span>
<span class="sd">            Returns the timestream of the final sidereal day if it&#39;s long</span>
<span class="sd">            enough, otherwise returns :obj:`None`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If we are here there is no more data coming, we just need to process any remaining data</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_current_lsd</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timestream_list</span> <span class="k">else</span> <span class="kc">None</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_process_current_lsd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Combine the current set of files into a timestream</span>

        <span class="n">lsd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_lsd</span>

        <span class="c1"># Calculate the length of data in this current LSD</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observer</span><span class="o">.</span><span class="n">unix_to_lsd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_timestream_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observer</span><span class="o">.</span><span class="n">unix_to_lsd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_timestream_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">day_length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">lsd</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">lsd</span><span class="p">)</span>

        <span class="c1"># If the amount of data for this day is too small, then just skip</span>
        <span class="k">if</span> <span class="n">day_length</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_day_length</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Constructing LSD:</span><span class="si">%i</span><span class="s2"> [</span><span class="si">%i</span><span class="s2"> files]&quot;</span><span class="p">,</span> <span class="n">lsd</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_timestream_list</span><span class="p">))</span>

        <span class="c1"># Construct the combined timestream</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">tod</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_timestream_list</span><span class="p">)</span>

        <span class="c1"># Add attributes for the LSD and a tag for labelling saved files</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;lsd_</span><span class="si">{</span><span class="n">lsd</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lsd</span>

        <span class="c1"># Clear the timestream list since these days have already been processed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timestream_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="n">ts</span></div>



<div class="viewcode-block" id="SiderealRegridder">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.sidereal.html#draco.analysis.sidereal.SiderealRegridder">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SiderealRegridder</span><span class="p">(</span><span class="n">LanczosRegridder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Take a sidereal days worth of data, and put onto a regular grid.</span>

<span class="sd">    Uses a maximum-likelihood inverse of a Lanczos interpolation to do the</span>
<span class="sd">    regridding. This gives a reasonably local regridding, that is pretty well</span>
<span class="sd">    behaved in m-space.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    down_mix: bool</span>
<span class="sd">        Down mix the visibility prior to interpolation using the fringe rate</span>
<span class="sd">        of a source at zenith.  This is un-done after the interpolation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">down_mix</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="SiderealRegridder.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.sidereal.html#draco.analysis.sidereal.SiderealRegridder.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Regrid the sidereal day.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : containers.TimeStream | containers.SiderealStream</span>
<span class="sd">            Timestream data for the day (must have a `LSD` attribute).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sdata : containers.SiderealStream</span>
<span class="sd">            The regularly gridded sidereal timestream.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Regridding LSD:</span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;lsd&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Redistribute if needed too</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Fetch which LSD this is to set bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Get the source samples, depending on the input type</span>
        <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
            <span class="c1"># Convert data timestamps into LSDs</span>
            <span class="n">source_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observer</span><span class="o">.</span><span class="n">unix_to_lsd</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;ra&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
            <span class="c1"># Convert data ra samples into LSDs</span>
            <span class="n">source_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">ra</span> <span class="o">/</span> <span class="mf">360.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid input data container </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="s2">&quot;Expected container with a `time` or an `ra` axis.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># This regridder only supports visibilities and their</span>
        <span class="c1"># corresponding weights. Make sure this is logged.</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;vis&quot;</span><span class="p">,</span> <span class="s2">&quot;vis_weight&quot;</span><span class="p">}:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Skipping dataset `</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">` - only `vis` and `vis_weight` are supported.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Get view of data</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">vis_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="c1"># Mix down</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">down_mix</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Downmixing before regridding.&quot;</span><span class="p">)</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_bounds</span><span class="p">]</span>
            <span class="n">phase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_phase</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">prodstack</span><span class="p">,</span> <span class="n">source_samples</span><span class="p">)</span>
            <span class="n">vis_data</span> <span class="o">*=</span> <span class="n">phase</span>

        <span class="c1"># perform regridding</span>
        <span class="n">new_grid</span><span class="p">,</span> <span class="n">sts</span><span class="p">,</span> <span class="n">ni</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_regrid</span><span class="p">(</span><span class="n">vis_data</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">source_samples</span><span class="p">)</span>

        <span class="c1"># Mix back up</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">down_mix</span><span class="p">:</span>
            <span class="n">phase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_phase</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">prodstack</span><span class="p">,</span> <span class="n">new_grid</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
            <span class="n">sts</span> <span class="o">*=</span> <span class="n">phase</span>
            <span class="n">ni</span> <span class="o">*=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ni</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Wait here for all processes to be done</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>

        <span class="c1"># FYI this whole process creates an extra copy of the sidereal stack.</span>
        <span class="c1"># This could probably be optimised out with a little work.</span>
        <span class="n">sdata</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealStream</span><span class="p">(</span>
            <span class="n">attrs_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">axes_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">ra</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span>
        <span class="p">)</span>
        <span class="n">sdata</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
        <span class="n">sdata</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">sts</span>
        <span class="n">sdata</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">ni</span>
        <span class="n">sdata</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span>
        <span class="n">sdata</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;lsd_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="si">:</span><span class="s2">.0f</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">return</span> <span class="n">sdata</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="n">lsd</span><span class="p">):</span>
        <span class="c1"># Determine if any baselines contains masked feeds</span>
        <span class="c1"># These baselines will be flagged since they do not</span>
        <span class="c1"># have valid baseline distances.</span>
        <span class="n">aa</span><span class="p">,</span> <span class="n">bb</span> <span class="o">=</span> <span class="n">prod</span><span class="p">[</span><span class="s2">&quot;input_a&quot;</span><span class="p">],</span> <span class="n">prod</span><span class="p">[</span><span class="s2">&quot;input_b&quot;</span><span class="p">]</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observer</span><span class="o">.</span><span class="n">feedmask</span><span class="p">[(</span><span class="n">aa</span><span class="p">,</span> <span class="n">bb</span><span class="p">)]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span>
        <span class="p">]</span>

        <span class="c1"># Calculate the fringe rate assuming that ha = 0.0 and dec = lat</span>
        <span class="n">lmbda</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span> <span class="p">(</span><span class="n">freq</span> <span class="o">*</span> <span class="mf">1e6</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observer</span><span class="o">.</span><span class="n">baselines</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">lmbda</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="n">omega</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">u</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observer</span><span class="o">.</span><span class="n">latitude</span><span class="p">))</span>

        <span class="c1"># Calculate the local sidereal angle</span>
        <span class="n">dphi</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">lsd</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">lsd</span><span class="p">))</span>

        <span class="c1"># Construct a complex sinusoid whose frequency</span>
        <span class="c1"># is equal to each baselines fringe rate</span>
        <span class="k">return</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
            <span class="o">-</span><span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">omega</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">dphi</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="SiderealRegridderGP">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.sidereal.html#draco.analysis.sidereal.SiderealRegridderGP">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SiderealRegridderGP</span><span class="p">(</span><span class="n">SiderealRegridder</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Regrid onto the sidereal day using Gaussian Process Regression.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    mask_cutoff : float</span>
<span class="sd">        Absolute distance (in number of samples) from `n`\th nearest input</span>
<span class="sd">        sample to keep interpolated output samples. Default is 1.7.</span>
<span class="sd">    mask_cutoff_partition : int</span>
<span class="sd">        Propagate `mask_cutoff` to `n`\th closest sample, where `n` is</span>
<span class="sd">        zero-indexed. This value is given as an input to `np.partition`.</span>
<span class="sd">        Default is 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mask_cutoff</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.7</span><span class="p">)</span>
    <span class="n">mask_cutoff_partition</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_regrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
        <span class="c1"># Create a regular grid, padded at either end to supress interpolation issues</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_width</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">pad</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">+</span> <span class="n">pad</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span>

        <span class="c1"># Remove the csd offset in the source samples. This is</span>
        <span class="c1"># required for the kernels to be properly normalized.</span>
        <span class="n">times</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span>

        <span class="c1"># Reshape the vis and weight arrays, moving frequency and</span>
        <span class="c1"># time-like axes to the front and flattening remaining axes</span>
        <span class="c1"># NOTE: at the moment, this just supports regridding visibilities</span>
        <span class="c1"># and weights, and it doesn&#39;t support `HybridVisStream` axes. The</span>
        <span class="c1"># latter should be fairly straightforward to add, wheras it would</span>
        <span class="c1"># take some thought to support additional datasets (`dirty_beam`,</span>
        <span class="c1"># `filter`, etc...).</span>
        <span class="n">vx</span> <span class="o">=</span> <span class="n">_move_front</span><span class="p">(</span><span class="n">vis</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">vis</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">wx</span> <span class="o">=</span> <span class="n">_move_front</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">weight</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># Define the kernel parameters</span>
        <span class="n">kernel_spec</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;matern&quot;</span><span class="p">,</span>
            <span class="s2">&quot;width&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_width</span><span class="p">,</span>
            <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
            <span class="s2">&quot;nu&quot;</span><span class="p">:</span> <span class="mf">2.5</span><span class="p">,</span>
            <span class="s2">&quot;epsilon&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># Resample</span>
        <span class="n">vout</span><span class="p">,</span> <span class="n">wout</span> <span class="o">=</span> <span class="n">gaussian_process</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span>
            <span class="n">vx</span><span class="p">,</span>
            <span class="n">wx</span><span class="p">,</span>
            <span class="n">xi</span><span class="o">=</span><span class="n">times</span><span class="p">,</span>
            <span class="n">xo</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span>
            <span class="n">cutoff_dist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_cutoff</span><span class="p">,</span>
            <span class="n">cutoff_partition</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_cutoff_partition</span><span class="p">,</span>
            <span class="n">kernel_spec</span><span class="o">=</span><span class="n">kernel_spec</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Move the arrays back to the correct shape and trim padding</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">pad</span><span class="p">:</span><span class="o">-</span><span class="n">pad</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">vout</span> <span class="o">=</span> <span class="n">_inv_move_front</span><span class="p">(</span>
            <span class="n">vout</span><span class="p">[:,</span> <span class="n">pad</span><span class="p">:</span><span class="o">-</span><span class="n">pad</span><span class="p">],</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">*</span><span class="n">vis</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">wout</span> <span class="o">=</span> <span class="n">_inv_move_front</span><span class="p">(</span>
            <span class="n">wout</span><span class="p">[:,</span> <span class="n">pad</span><span class="p">:</span><span class="o">-</span><span class="n">pad</span><span class="p">],</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">*</span><span class="n">weight</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">grid</span><span class="p">,</span> <span class="n">vout</span><span class="p">,</span> <span class="n">wout</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_search_nearest</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xeval</span><span class="p">):</span>
    <span class="n">index_next</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xeval</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

    <span class="n">index_previous</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">index_next</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">index_next</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">index_next</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xeval</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">index_previous</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xeval</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">index_next</span><span class="p">]),</span>
        <span class="n">index_previous</span><span class="p">,</span>
        <span class="n">index_next</span><span class="p">,</span>
    <span class="p">)</span>


<div class="viewcode-block" id="SiderealRegridderNearest">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.sidereal.html#draco.analysis.sidereal.SiderealRegridderNearest">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SiderealRegridderNearest</span><span class="p">(</span><span class="n">SiderealRegridder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Regrid onto the sidereal day using nearest neighbor interpolation.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_regrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">lsd</span><span class="p">):</span>
        <span class="c1"># Create a regular grid</span>
        <span class="n">interp_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span>
        <span class="n">interp_grid</span> <span class="o">=</span> <span class="n">interp_grid</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span>

        <span class="c1"># Find the data points that are closest to the fixed points on the grid</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">_search_nearest</span><span class="p">(</span><span class="n">lsd</span><span class="p">,</span> <span class="n">interp_grid</span><span class="p">)</span>

        <span class="n">interp_vis</span> <span class="o">=</span> <span class="n">vis</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span>
        <span class="n">interp_weight</span> <span class="o">=</span> <span class="n">weight</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span>

        <span class="c1"># Flag the re-gridded data if the nearest neighbor was more than one</span>
        <span class="c1"># sample spacing away.  This can occur if the input data does not have</span>
        <span class="c1"># complete sidereal coverage.</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">lsd</span><span class="p">)))</span>
        <span class="n">distant</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lsd</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">-</span> <span class="n">interp_grid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">)</span>
        <span class="n">interp_weight</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">distant</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">return</span> <span class="n">interp_grid</span><span class="p">,</span> <span class="n">interp_vis</span><span class="p">,</span> <span class="n">interp_weight</span></div>



<div class="viewcode-block" id="SiderealRegridderLinear">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.sidereal.html#draco.analysis.sidereal.SiderealRegridderLinear">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SiderealRegridderLinear</span><span class="p">(</span><span class="n">SiderealRegridder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Regrid onto the sidereal day using linear interpolation.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_regrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">lsd</span><span class="p">):</span>
        <span class="c1"># Create a regular grid</span>
        <span class="n">interp_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span>
        <span class="n">interp_grid</span> <span class="o">=</span> <span class="n">interp_grid</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span>

        <span class="c1"># Find the data points that lie on either side of each point in the fixed grid</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">lsd</span><span class="p">,</span> <span class="n">interp_grid</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

        <span class="n">ind1</span> <span class="o">=</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">ind2</span> <span class="o">=</span> <span class="n">index</span>

        <span class="c1"># If the fixed grid is outside the range covered by the data,</span>
        <span class="c1"># then we will extrapolate and later flag as bad.</span>
        <span class="n">below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">ind1</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">below</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ind1</span><span class="p">[</span><span class="n">below</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ind2</span><span class="p">[</span><span class="n">below</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">above</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">ind2</span> <span class="o">==</span> <span class="n">lsd</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">above</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ind1</span><span class="p">[</span><span class="n">above</span><span class="p">]</span> <span class="o">=</span> <span class="n">lsd</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">2</span>
            <span class="n">ind2</span><span class="p">[</span><span class="n">above</span><span class="p">]</span> <span class="o">=</span> <span class="n">lsd</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># If the closest data points to the fixed grid point are more than one</span>
        <span class="c1"># sample spacing away, then we will later flag that data as bad.</span>
        <span class="c1"># This will occur if the input data does not cover the full sidereal day.</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">lsd</span><span class="p">)))</span>
        <span class="n">distant</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lsd</span><span class="p">[</span><span class="n">ind1</span><span class="p">]</span> <span class="o">-</span> <span class="n">interp_grid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">)</span>
            <span class="o">|</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lsd</span><span class="p">[</span><span class="n">ind2</span><span class="p">]</span> <span class="o">-</span> <span class="n">interp_grid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Calculate the coefficients for the linear interpolation</span>
        <span class="n">dx1</span> <span class="o">=</span> <span class="n">interp_grid</span> <span class="o">-</span> <span class="n">lsd</span><span class="p">[</span><span class="n">ind1</span><span class="p">]</span>
        <span class="n">dx2</span> <span class="o">=</span> <span class="n">lsd</span><span class="p">[</span><span class="n">ind2</span><span class="p">]</span> <span class="o">-</span> <span class="n">interp_grid</span>

        <span class="n">norm</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">dx1</span> <span class="o">+</span> <span class="n">dx2</span><span class="p">)</span>
        <span class="n">coeff1</span> <span class="o">=</span> <span class="n">dx2</span> <span class="o">*</span> <span class="n">norm</span>
        <span class="n">coeff2</span> <span class="o">=</span> <span class="n">dx1</span> <span class="o">*</span> <span class="n">norm</span>

        <span class="c1"># Initialize the output arrays</span>
        <span class="n">shp</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">vis</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>

        <span class="n">interp_vis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">vis</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">interp_weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">weight</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Loop over frequencies to reduce memory usage</span>
        <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">shp</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">fvis</span> <span class="o">=</span> <span class="n">vis</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span>
            <span class="n">fweight</span> <span class="o">=</span> <span class="n">weight</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span>

            <span class="c1"># Consider the data valid if it has nonzero weight</span>
            <span class="n">fflag</span> <span class="o">=</span> <span class="n">fweight</span> <span class="o">&gt;</span> <span class="mf">0.0</span>

            <span class="c1"># Determine the variance from the inverse weight</span>
            <span class="n">fvar</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">fweight</span><span class="p">)</span>

            <span class="c1"># Require both data points to be valid for the interpolated value to be valid</span>
            <span class="n">finterp_flag</span> <span class="o">=</span> <span class="n">fflag</span><span class="p">[:,</span> <span class="n">ind1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">fflag</span><span class="p">[:,</span> <span class="n">ind2</span><span class="p">]</span>

            <span class="c1"># Interpolate the visibilities and propagate the weights</span>
            <span class="n">interp_vis</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff1</span> <span class="o">*</span> <span class="n">fvis</span><span class="p">[:,</span> <span class="n">ind1</span><span class="p">]</span> <span class="o">+</span> <span class="n">coeff2</span> <span class="o">*</span> <span class="n">fvis</span><span class="p">[:,</span> <span class="n">ind2</span><span class="p">]</span>

            <span class="n">interp_weight</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span>
                <span class="n">coeff1</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fvar</span><span class="p">[:,</span> <span class="n">ind1</span><span class="p">]</span> <span class="o">+</span> <span class="n">coeff2</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fvar</span><span class="p">[:,</span> <span class="n">ind2</span><span class="p">]</span>
            <span class="p">)</span> <span class="o">*</span> <span class="n">finterp_flag</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># Flag as bad any values that were extrapolated or that used distant points</span>
        <span class="n">interp_weight</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">below</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">interp_weight</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">above</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">interp_weight</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">distant</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">return</span> <span class="n">interp_grid</span><span class="p">,</span> <span class="n">interp_vis</span><span class="p">,</span> <span class="n">interp_weight</span></div>



<div class="viewcode-block" id="SiderealRegridderCubic">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.sidereal.html#draco.analysis.sidereal.SiderealRegridderCubic">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SiderealRegridderCubic</span><span class="p">(</span><span class="n">SiderealRegridder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Regrid onto the sidereal day using cubic Hermite spline interpolation.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_regrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">lsd</span><span class="p">):</span>
        <span class="c1"># Create a regular grid</span>
        <span class="n">interp_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span>
        <span class="n">interp_grid</span> <span class="o">=</span> <span class="n">interp_grid</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span>

        <span class="c1"># Find the data point just after each point on the fixed grid</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">lsd</span><span class="p">,</span> <span class="n">interp_grid</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

        <span class="c1"># Find the 4 data points that will be used to interpolate</span>
        <span class="c1"># each point on the fixed grid</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">index</span> <span class="o">+</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>

        <span class="c1"># If the fixed grid is outside the range covered by the data,</span>
        <span class="c1"># then we will extrapolate and later flag as bad</span>
        <span class="n">below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">below</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">above</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">lsd</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">above</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">lsd</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># If the closest data points to the fixed grid point are more than one</span>
        <span class="c1"># sample spacing away, then we will later flag that data as bad.</span>
        <span class="c1"># This will occur if the input data does not cover the full sidereal day.</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">lsd</span><span class="p">)))</span>
        <span class="n">distant</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">interp_grid</span> <span class="o">-</span> <span class="n">lsd</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">delta</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Calculate the coefficients for the interpolation</span>
        <span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="n">interp_grid</span> <span class="o">-</span> <span class="n">lsd</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span>
            <span class="n">lsd</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">-</span> <span class="n">lsd</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="p">)</span>

        <span class="n">coeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span> <span class="o">*</span> <span class="p">((</span><span class="mi">2</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">u</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>
        <span class="n">coeff</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span> <span class="o">*</span> <span class="p">((</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">u</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">coeff</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">coeff</span> <span class="o">*=</span> <span class="mf">0.5</span>

        <span class="c1"># Initialize the output arrays</span>
        <span class="n">shp</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">vis</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>

        <span class="n">interp_vis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">vis</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">interp_weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">weight</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Loop over frequencies to reduce memory usage</span>
        <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">shp</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">fvis</span> <span class="o">=</span> <span class="n">vis</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span>
            <span class="n">fweight</span> <span class="o">=</span> <span class="n">weight</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span>

            <span class="c1"># Consider the data valid if it has nonzero weight</span>
            <span class="n">fflag</span> <span class="o">=</span> <span class="n">fweight</span> <span class="o">&gt;</span> <span class="mf">0.0</span>

            <span class="c1"># Determine the variance from the inverse weight</span>
            <span class="n">fvar</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">fweight</span><span class="p">)</span>

            <span class="c1"># Interpolate the visibilities and propagate the weights</span>
            <span class="n">finterp_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shp</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">finterp_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shp</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">weight</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">cc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">coeff</span><span class="p">):</span>
                <span class="n">finterp_flag</span> <span class="o">&amp;=</span> <span class="n">fflag</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">]</span>
                <span class="n">finterp_var</span> <span class="o">+=</span> <span class="n">cc</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fvar</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">]</span>

                <span class="n">interp_vis</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cc</span> <span class="o">*</span> <span class="n">fvis</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">]</span>

            <span class="c1"># Invert the accumulated variances to get the weight</span>
            <span class="c1"># Require all data points are valid for the interpolated value to be valid</span>
            <span class="n">interp_weight</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">finterp_var</span><span class="p">)</span> <span class="o">*</span> <span class="n">finterp_flag</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
            <span class="p">)</span>

        <span class="c1"># Flag as bad any values that were extrapolated or that used distant points</span>
        <span class="n">interp_weight</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">below</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">interp_weight</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">above</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">interp_weight</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">distant</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">return</span> <span class="n">interp_grid</span><span class="p">,</span> <span class="n">interp_vis</span><span class="p">,</span> <span class="n">interp_weight</span></div>



<div class="viewcode-block" id="SiderealRebinner">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.sidereal.html#draco.analysis.sidereal.SiderealRebinner">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SiderealRebinner</span><span class="p">(</span><span class="n">SiderealRegridder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Regrid a sidereal day of data using a binning method.</span>

<span class="sd">    Assign a fraction of each time sample to the nearest RA bin based</span>
<span class="sd">    on the propotion of the time bin that overlaps the RA bin.</span>

<span class="sd">    Tracks the weighted effective centre of RA bin so that a centring</span>
<span class="sd">    correction can be applied afterwards. A correction option is</span>
<span class="sd">    implemented in `RebinGradientCorrection`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    weight: str (default: &quot;inverse_variance&quot;)</span>
<span class="sd">        The weighting to use in the stack.  Either `uniform` or `inverse_variance`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">weight</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">enum</span><span class="p">([</span><span class="s2">&quot;uniform&quot;</span><span class="p">,</span> <span class="s2">&quot;inverse_variance&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;inverse_variance&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="SiderealRebinner.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.sidereal.html#draco.analysis.sidereal.SiderealRebinner.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rebin the sidereal day.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : containers.TimeStream | containers.SiderealStream | containers.HybridVisStream</span>
<span class="sd">            Timestream data for the day (must have a `LSD` attribute).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sdata : containers.SiderealStream | containers.HybridVisStream</span>
<span class="sd">            The regularly gridded sidereal timestream.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">scipy.sparse</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ss</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Rebinning LSD </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;lsd&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.0f</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="si">}</span><span class="s2"> weighting.&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Determine output container based on input container</span>
        <span class="n">container_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">containers</span><span class="o">.</span><span class="n">TimeStream</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealStream</span><span class="p">,</span>
            <span class="n">containers</span><span class="o">.</span><span class="n">SiderealStream</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealStream</span><span class="p">,</span>
            <span class="n">containers</span><span class="o">.</span><span class="n">HybridVisStream</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">HybridVisStream</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># We need to be able to check for subclasses in the container map</span>
        <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getmro</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
            <span class="n">OutputContainer</span> <span class="o">=</span> <span class="n">container_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">OutputContainer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">OutputContainer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;No valid container mapping.</span><span class="se">\n</span><span class="s2">Got </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="vm">__class__</span><span class="si">}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Mappings exist for </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">container_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Redistribute if needed too</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Fetch which LSD this is to set bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Convert data timestamps into LSDs</span>
        <span class="k">if</span> <span class="s2">&quot;ra&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
            <span class="n">timestamp_lsd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">ra</span> <span class="o">/</span> <span class="mf">360.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">timestamp_lsd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observer</span><span class="o">.</span><span class="n">unix_to_lsd</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>

        <span class="c1"># Create the output container</span>
        <span class="n">sdata</span> <span class="o">=</span> <span class="n">OutputContainer</span><span class="p">(</span><span class="n">ra</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">axes_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">attrs_from</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># Initialize any missing datasets</span>
        <span class="n">alt_dspec</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">contains_covariance</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sdata</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
                <span class="n">alt_dspec</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span>
                <span class="n">sdata</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="s2">&quot;freq_cov&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
                    <span class="n">contains_covariance</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">sdata</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;effective_ra&quot;</span><span class="p">)</span>
        <span class="n">sdata</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;nsample&quot;</span><span class="p">)</span>

        <span class="n">sdata</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Get view of data</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">vis_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">alt_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">name</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="n">name</span><span class="p">][:]</span><span class="o">.</span><span class="n">local_array</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">alt_dspec</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="c1"># Get the median time sample width</span>
        <span class="n">width_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">timestamp_lsd</span><span class="p">)))</span>
        <span class="c1"># Create the regular grid of RA samples</span>
        <span class="n">target_lsd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Create the rebinning matrix</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">regrid</span><span class="o">.</span><span class="n">rebin_matrix</span><span class="p">(</span><span class="n">timestamp_lsd</span><span class="p">,</span> <span class="n">target_lsd</span><span class="p">,</span> <span class="n">width_t</span><span class="o">=</span><span class="n">width_t</span><span class="p">)</span>
        <span class="n">Rt</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">csr_array</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="c1"># The square is used to calculate rebinned weights</span>
        <span class="n">Rtsq</span> <span class="o">=</span> <span class="n">Rt</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># dereference arrays before loop</span>
        <span class="n">sera</span> <span class="o">=</span> <span class="n">sdata</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;effective_ra&quot;</span><span class="p">][:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">ssw</span> <span class="o">=</span> <span class="n">sdata</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">ssv</span> <span class="o">=</span> <span class="n">sdata</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">ssn</span> <span class="o">=</span> <span class="n">sdata</span><span class="o">.</span><span class="n">nsample</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">salt</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">sdata</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="n">name</span><span class="p">][:]</span><span class="o">.</span><span class="n">local_array</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">alt_dspec</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>

        <span class="n">vax</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">][:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">lookup</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">nn</span> <span class="k">for</span> <span class="n">nn</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vax</span><span class="p">)}</span>

        <span class="c1"># If the input data product contains a freq-freq covariance matrix,</span>
        <span class="c1"># then we will need access to the weight dataset for all frequencies.</span>
        <span class="k">if</span> <span class="n">contains_covariance</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
                <span class="n">weight_all</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">allgather</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">weight_all</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">allgather</span><span class="p">()</span>

        <span class="c1"># Loop over all but the last two axes.</span>
        <span class="c1"># For an input TimeStream, this will be a loop over freq.</span>
        <span class="c1"># For an input HybridVisStream, this will be a loop over (pol, freq, ew).</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="o">*</span><span class="n">vis_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]):</span>

            <span class="n">w</span> <span class="o">=</span> <span class="n">weight</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">m</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">w</span>

            <span class="c1"># Normalisation for rebinned datasets</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">w</span> <span class="o">@</span> <span class="n">Rt</span><span class="p">)</span>

            <span class="c1"># Weighted rebin of the visibilities</span>
            <span class="n">ssv</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span> <span class="o">*</span> <span class="p">((</span><span class="n">vis_data</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span> <span class="o">@</span> <span class="n">Rt</span><span class="p">)</span>

            <span class="c1"># Count number of samples</span>
            <span class="n">ssn</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span> <span class="o">@</span> <span class="n">Rt</span>

            <span class="c1"># Compute factors needed for the covariance calculation</span>
            <span class="k">if</span> <span class="n">contains_covariance</span><span class="p">:</span>
                <span class="n">iall</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="n">ii</span> <span class="k">if</span> <span class="n">ax</span> <span class="o">!=</span> <span class="s2">&quot;freq&quot;</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">vax</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">wall</span> <span class="o">=</span> <span class="n">weight_all</span><span class="p">[</span><span class="n">iall</span><span class="p">]</span>
                <span class="n">nall</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">wall</span> <span class="o">@</span> <span class="n">Rt</span><span class="p">)</span>

            <span class="c1"># Weighted rebin of other datasets</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">alt_dspec</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">aind</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">ind</span><span class="p">[</span><span class="n">lookup</span><span class="p">[</span><span class="n">ax</span><span class="p">]]</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">lookup</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
                    <span class="p">]</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="s2">&quot;freq_cov&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
                    <span class="n">salt</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">aind</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">norm</span> <span class="o">*</span> <span class="n">nall</span> <span class="o">*</span> <span class="p">((</span><span class="n">alt_data</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">aind</span><span class="p">]</span> <span class="o">*</span> <span class="n">w</span> <span class="o">*</span> <span class="n">wall</span><span class="p">)</span> <span class="o">@</span> <span class="n">Rtsq</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">salt</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">aind</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span> <span class="o">*</span> <span class="p">((</span><span class="n">alt_data</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">aind</span><span class="p">]</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span> <span class="o">@</span> <span class="n">Rt</span><span class="p">)</span>

            <span class="c1"># Weighted rebin of the effective RA</span>
            <span class="n">effective_lsd</span> <span class="o">=</span> <span class="n">norm</span> <span class="o">*</span> <span class="p">((</span><span class="n">timestamp_lsd</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span> <span class="o">@</span> <span class="n">Rt</span><span class="p">)</span>
            <span class="n">sera</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="mi">360</span> <span class="o">*</span> <span class="p">(</span><span class="n">effective_lsd</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>

            <span class="c1"># Rebin the weights</span>
            <span class="n">rvar</span> <span class="o">=</span> <span class="n">v</span> <span class="o">@</span> <span class="n">Rtsq</span>
            <span class="n">ssw</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">norm</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">rvar</span><span class="p">)</span>

            <span class="c1"># Correct the effective ra where weights are zero. This</span>
            <span class="c1"># is required to avoid discontinuities</span>
            <span class="n">imask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">ssw</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">sera</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">imask</span><span class="p">]</span> <span class="o">=</span> <span class="n">sdata</span><span class="o">.</span><span class="n">ra</span><span class="p">[</span><span class="n">imask</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">return</span> <span class="n">sdata</span></div>
</div>



<div class="viewcode-block" id="RebinGradientCorrection">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.sidereal.html#draco.analysis.sidereal.RebinGradientCorrection">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RebinGradientCorrection</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply a linear gradient correction to shift RA samples to bin centres.</span>

<span class="sd">    Requires a sidereal day with full sidereal coverage to calculate a local</span>
<span class="sd">    gradient for each RA bin. The dataset value at the RA bin centre is</span>
<span class="sd">    interpolated based on the local gradient and difference between bin centre</span>
<span class="sd">    and effective bin centre.</span>

<span class="sd">    If the rebinned dataset has full sidereal coverage, it can be used to</span>
<span class="sd">    create the gradient.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RebinGradientCorrection.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.sidereal.html#draco.analysis.sidereal.RebinGradientCorrection.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sstream_ref</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealStream</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Provide the dataset to use in the gradient calculation.</span>

<span class="sd">        This dataset must have complete sidereal coverage.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sstream_ref</span>
<span class="sd">            Reference SiderealStream</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sstream_ref</span> <span class="o">=</span> <span class="n">sstream_ref</span></div>


<div class="viewcode-block" id="RebinGradientCorrection.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.sidereal.html#draco.analysis.sidereal.RebinGradientCorrection.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sstream</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealStream</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealStream</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply the gradient correction to the input dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sstream</span>
<span class="sd">            sidereal day to apply a correction to</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sstream</span>
<span class="sd">            Input sidereal day with gradient correction applied, if needed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sstream_ref</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
        <span class="n">sstream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Allows a normal sidereal stream to pass through this task.</span>
        <span class="c1"># Helpful for creating generic configs</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">era</span> <span class="o">=</span> <span class="n">sstream</span><span class="o">.</span><span class="n">effective_ra</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Dataset of type (</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">sstream</span><span class="p">)</span><span class="si">}</span><span class="s2">) does not have an effective &quot;</span>
                <span class="s2">&quot;ra dataset. No correction will be applied.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">sstream</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># If the reference dataset has an effective ra dataset, use this</span>
            <span class="c1"># when calculating the gradient. This could be true if the reference</span>
            <span class="c1"># and target datasets are the same</span>
            <span class="n">ref_ra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sstream_ref</span><span class="o">.</span><span class="n">effective_ra</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># Use fixed ra, which should be regularly sampled</span>
            <span class="n">ref_ra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sstream_ref</span><span class="o">.</span><span class="n">ra</span>

        <span class="n">vis</span> <span class="o">=</span> <span class="n">sstream</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">sstream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="n">ref_vis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sstream_ref</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">ref_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sstream_ref</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="c1"># Iterate over frequencies and baselines for memory</span>
        <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">vis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1"># Skip if entirely masked already</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">weight</span><span class="p">[</span><span class="n">fi</span><span class="p">]):</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">vi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">vis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="c1"># Skip if entire baseline is masked</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">weight</span><span class="p">[</span><span class="n">fi</span><span class="p">,</span> <span class="n">vi</span><span class="p">]):</span>
                    <span class="k">continue</span>

                <span class="c1"># Depends on whether the effective ra has baseline dependence</span>
                <span class="n">rra</span> <span class="o">=</span> <span class="n">ref_ra</span><span class="p">[</span><span class="n">fi</span><span class="p">,</span> <span class="n">vi</span><span class="p">]</span> <span class="k">if</span> <span class="n">ref_ra</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">ref_ra</span>
                <span class="c1"># Calculate the vis gradient at the reference RA points</span>
                <span class="n">ref_mask</span> <span class="o">=</span> <span class="n">ref_weight</span><span class="p">[</span><span class="n">fi</span><span class="p">,</span> <span class="n">vi</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span>
                <span class="n">grad</span><span class="p">,</span> <span class="n">ref_mask</span> <span class="o">=</span> <span class="n">regrid</span><span class="o">.</span><span class="n">grad_1d</span><span class="p">(</span>
                    <span class="n">ref_vis</span><span class="p">[</span><span class="n">fi</span><span class="p">,</span> <span class="n">vi</span><span class="p">],</span> <span class="n">rra</span><span class="p">,</span> <span class="n">ref_mask</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="mf">360.0</span>
                <span class="p">)</span>

                <span class="c1"># Apply the correction to estimate the sample value at the</span>
                <span class="c1"># RA bin centre. Ensure that values that are masked in the</span>
                <span class="c1"># original dataset do not get shifted if the reference</span>
                <span class="c1"># dataset has a different mask</span>
                <span class="n">sel</span> <span class="o">=</span> <span class="n">weight</span><span class="p">[</span><span class="n">fi</span><span class="p">,</span> <span class="n">vi</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span>
                <span class="n">vis</span><span class="p">[</span><span class="n">fi</span><span class="p">,</span> <span class="n">vi</span><span class="p">]</span> <span class="o">-=</span> <span class="n">grad</span> <span class="o">*</span> <span class="n">sel</span> <span class="o">*</span> <span class="p">(</span><span class="n">era</span><span class="p">[</span><span class="n">fi</span><span class="p">,</span> <span class="n">vi</span><span class="p">]</span> <span class="o">-</span> <span class="n">sstream</span><span class="o">.</span><span class="n">ra</span><span class="p">)</span>
                <span class="c1"># Keep track of the time mask being applied</span>
                <span class="n">weight</span><span class="p">[</span><span class="n">fi</span><span class="p">,</span> <span class="n">vi</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="o">~</span><span class="n">ref_mask</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">weight</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Delete the effective ra dataset since it is not needed anymore</span>
        <span class="k">del</span> <span class="n">sstream</span><span class="p">[</span><span class="s2">&quot;effective_ra&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">sstream</span></div>
</div>



<div class="viewcode-block" id="SiderealStacker">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.sidereal.html#draco.analysis.sidereal.SiderealStacker">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SiderealStacker</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Take in a set of sidereal days, and stack them up.</span>

<span class="sd">    Also computes the variance over sideral days using an</span>
<span class="sd">    algorithm that updates the sum of square differences from</span>
<span class="sd">    the current mean, which is less prone to numerical issues.</span>
<span class="sd">    See West, D.H.D. (1979). https://doi.org/10.1145/359146.359153.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    tag : str (default: &quot;stack&quot;)</span>
<span class="sd">        The tag to give the stack.</span>
<span class="sd">    weight: str (default: &quot;inverse_variance&quot;)</span>
<span class="sd">        The weighting to use in the stack.</span>
<span class="sd">        Either `uniform` or `inverse_variance`.</span>
<span class="sd">    with_sample_variance : bool (default: False)</span>
<span class="sd">        Add a dataset containing the sample variance</span>
<span class="sd">        of the visibilities over sidereal days to the</span>
<span class="sd">        sidereal stack.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">stack</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">tag</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;stack&quot;</span><span class="p">)</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">enum</span><span class="p">([</span><span class="s2">&quot;uniform&quot;</span><span class="p">,</span> <span class="s2">&quot;inverse_variance&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;inverse_variance&quot;</span><span class="p">)</span>
    <span class="n">with_sample_variance</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="SiderealStacker.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.sidereal.html#draco.analysis.sidereal.SiderealStacker.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sdata</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Stack up sidereal days.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sdata : containers.SiderealStream</span>
<span class="sd">            Individual sidereal day to add to stack.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that the input container is of the correct type</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sdata</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;type(sdata) (=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">sdata</span><span class="p">)</span><span class="si">}</span><span class="s2">) does not match &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;type(stack) (=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">)</span><span class="si">}</span><span class="s2">).&quot;</span>
            <span class="p">)</span>

        <span class="n">sdata</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;ra&quot;</span><span class="p">)</span>

        <span class="c1"># Get the LSD (or CSD) label out of the input&#39;s attributes.</span>
        <span class="c1"># If there is no label, use a placeholder.</span>
        <span class="k">if</span> <span class="s2">&quot;lsd&quot;</span> <span class="ow">in</span> <span class="n">sdata</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="n">input_lsd</span> <span class="o">=</span> <span class="n">sdata</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="s2">&quot;csd&quot;</span> <span class="ow">in</span> <span class="n">sdata</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="n">input_lsd</span> <span class="o">=</span> <span class="n">sdata</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;csd&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">input_lsd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">input_lsd</span> <span class="o">=</span> <span class="n">_ensure_list</span><span class="p">(</span><span class="n">input_lsd</span><span class="p">)</span>

        <span class="c1"># If this is our first sidereal day, then initialize the</span>
        <span class="c1"># container that will hold the stack.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">sdata</span><span class="p">)</span>

            <span class="c1"># Add stack-specific datasets</span>
            <span class="k">if</span> <span class="s2">&quot;nsample&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;nsample&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_sample_variance</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="s2">&quot;sample_variance&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">datasets</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;sample_variance&quot;</span><span class="p">)</span>

            <span class="c1"># Create a slice into the weight dataset that will allow it</span>
            <span class="c1"># to be broadcasted against the vis dataset.</span>
            <span class="n">wax</span> <span class="o">=</span> <span class="n">sdata</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">weight_slice</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weight_slice</span><span class="p">[</span><span class="s2">&quot;vis&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_slice_to_broadcast</span><span class="p">(</span>
                <span class="n">wax</span><span class="p">,</span> <span class="n">sdata</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># Initialize any missing datasets, which will include effective_ra.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">additional_datasets</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="n">sdata</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Creating </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> dataset in the sidereal stack.&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">additional_datasets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

                    <span class="c1"># Create a slice into the weight dataset that will allow it</span>
                    <span class="c1"># to be broadcasted against the additional dataset.</span>
                    <span class="n">wslc1</span> <span class="o">=</span> <span class="n">get_slice_to_broadcast</span><span class="p">(</span><span class="n">wax</span><span class="p">,</span> <span class="n">dataset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span>

                    <span class="k">if</span> <span class="s2">&quot;freq_cov&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
                        <span class="n">wslc2</span> <span class="o">=</span> <span class="n">get_slice_to_broadcast</span><span class="p">(</span><span class="n">wax</span><span class="p">,</span> <span class="n">sdata</span><span class="o">.</span><span class="n">swapped_freq_cov_axis</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">weight_slice</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">wslc1</span><span class="p">,</span> <span class="n">wslc2</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">weight_slice</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">wslc1</span>

            <span class="c1"># Now that we have all datasets, redistribute over frequency.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;ra&quot;</span><span class="p">)</span>

            <span class="c1"># Initialize all datasets to zero.</span>
            <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">lsd_list</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Keep track of the sum of squared weights</span>
            <span class="c1"># to perform Bessel&#39;s correction at the end.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_sample_variance</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sum_coeff_sq</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_shape</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">comm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="c1"># Accumulate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding LSD </span><span class="si">{</span><span class="n">input_lsd</span><span class="si">}</span><span class="s2"> to stack with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="si">}</span><span class="s2"> weighting.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lsd_list</span> <span class="o">+=</span> <span class="n">input_lsd</span>

        <span class="c1"># Extract weight dataset</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">sdata</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span>

        <span class="c1"># Determine if the input sidereal stream is itself a stack over days</span>
        <span class="k">if</span> <span class="s2">&quot;nsample&quot;</span> <span class="ow">in</span> <span class="n">sdata</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
            <span class="c1"># The input sidereal stream is already a stack</span>
            <span class="c1"># over multiple sidereal days. Use the nsample</span>
            <span class="c1"># dataset as the weight for the uniform case.</span>
            <span class="c1"># Make sure to also zero any samples whose weight</span>
            <span class="c1"># is zero in case other tasks did not also zero</span>
            <span class="c1"># the nsample dataset.</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">sdata</span><span class="o">.</span><span class="n">nsample</span><span class="p">[:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">weight</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The input sidereal stream contains a single</span>
            <span class="c1"># sidereal day. Use a boolean array that</span>
            <span class="c1"># indicates a non-zero weight dataset as</span>
            <span class="c1"># the weight for the uniform case.</span>
            <span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="n">weight</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">nsample</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Accumulate the total number of samples.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">nsample</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">count</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="n">count</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">coeff</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
            <span class="n">sum_coeff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">nsample</span><span class="p">[:]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="n">weight</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">weight</span>
            <span class="n">sum_coeff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span>

        <span class="c1"># Calculate weighted difference between the new data and the current mean.</span>
        <span class="n">wslc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_slice</span><span class="p">[</span><span class="s2">&quot;vis&quot;</span><span class="p">]</span>

        <span class="n">delta_before</span> <span class="o">=</span> <span class="n">coeff</span><span class="p">[</span><span class="n">wslc</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">sdata</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">vis</span><span class="p">[:])</span>
        <span class="n">inv_sum_coeff</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">sum_coeff</span><span class="p">)</span>

        <span class="c1"># Update the mean.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">delta_before</span> <span class="o">*</span> <span class="n">inv_sum_coeff</span><span class="p">[</span><span class="n">wslc</span><span class="p">]</span>

        <span class="c1"># Update any additional datasets.  Note this will include the effective_ra.</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">additional_datasets</span><span class="p">:</span>
            <span class="n">wslc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_slice</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="s2">&quot;freq_cov&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="n">name</span><span class="p">][:]</span> <span class="o">+=</span> <span class="n">coeff</span><span class="p">[</span><span class="n">wslc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">coeff</span><span class="p">[</span><span class="n">wslc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">*</span> <span class="n">sdata</span><span class="p">[</span><span class="n">name</span><span class="p">][:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">coeff</span><span class="p">[</span><span class="n">wslc</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">sdata</span><span class="p">[</span><span class="n">name</span><span class="p">][:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="n">name</span><span class="p">][:])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="n">name</span><span class="p">][:]</span> <span class="o">+=</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">inv_sum_coeff</span><span class="p">[</span><span class="n">wslc</span><span class="p">]</span>

        <span class="c1"># The calculations below are only required if the sample variance was requested</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_sample_variance</span><span class="p">:</span>
            <span class="c1"># Accumulate the sum of squared coefficients.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sum_coeff_sq</span> <span class="o">+=</span> <span class="n">coeff</span><span class="o">**</span><span class="mi">2</span>

            <span class="c1"># Calculate the difference between the new data and the updated mean.</span>
            <span class="n">delta_after</span> <span class="o">=</span> <span class="n">sdata</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span>

            <span class="c1"># Update the sample variance.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">sample_variance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">delta_before</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">delta_after</span><span class="o">.</span><span class="n">real</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">sample_variance</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">delta_before</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">delta_after</span><span class="o">.</span><span class="n">imag</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">sample_variance</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">delta_before</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">delta_after</span><span class="o">.</span><span class="n">imag</span></div>


<div class="viewcode-block" id="SiderealStacker.process_finish">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.sidereal.html#draco.analysis.sidereal.SiderealStacker.process_finish">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process_finish</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Normalize the stack and return the result.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        stack : containers.SiderealStream</span>
<span class="sd">            Stack of sidereal days.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lsd_list</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
            <span class="c1"># For uniform weighting, normalize the accumulated variances by the total</span>
            <span class="c1"># number of samples squared and then invert to finalize stack.weight.</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">nsample</span><span class="p">[:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">weight</span><span class="p">[:])</span> <span class="o">*</span> <span class="n">norm</span><span class="o">**</span><span class="mi">2</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For inverse variance weighting the stack.weight dataset is finalized,</span>
            <span class="c1"># no additional normalization is required.</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span>

        <span class="c1"># Apply the inverse squared norm factor to any dataset that is a</span>
        <span class="c1"># freq-freq covariance</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">additional_datasets</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;freq_cov&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
                <span class="n">wslc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_slice</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="n">name</span><span class="p">][:]</span> <span class="o">*=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span>
                    <span class="n">norm</span><span class="p">[</span><span class="n">wslc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">norm</span><span class="p">[</span><span class="n">wslc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="p">)</span>

        <span class="c1"># We need to normalize the sample variance by the sum of coefficients.</span>
        <span class="c1"># Can be found in the stack.nsample dataset for uniform case</span>
        <span class="c1"># or the stack.weight dataset for inverse variance case.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_sample_variance</span><span class="p">:</span>

            <span class="c1"># Perform Bessel&#39;s correction.  In the case of</span>
            <span class="c1"># uniform  weighting, norm will be equal to nsample - 1.</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">norm</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum_coeff_sq</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>

            <span class="c1"># Normalize the sample variance.</span>
            <span class="n">wslc</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_slice</span><span class="p">[</span><span class="s2">&quot;vis&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">sample_variance</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">nsample</span><span class="p">[:]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">norm</span><span class="p">),</span> <span class="mf">0.0</span>
            <span class="p">)[</span><span class="n">wslc</span><span class="p">]</span>

        <span class="c1"># Now redistribute back over frequency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># For samples where there is no data, the effective ra should</span>
        <span class="c1"># be the same as the grid ra</span>
        <span class="k">if</span> <span class="s2">&quot;effective_ra&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
            <span class="n">era</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">effective_ra</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

            <span class="c1"># Broadcast the RA array to match the shape of a single frequency,</span>
            <span class="c1"># allowing us to select grid ra values with a 2D mask</span>
            <span class="n">grid_ra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">ra</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">era</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],))</span>

            <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">era</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">weight</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span>
                <span class="n">era</span><span class="p">[</span><span class="n">fi</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid_ra</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span></div>
</div>



<div class="viewcode-block" id="SiderealStackerMatch">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.sidereal.html#draco.analysis.sidereal.SiderealStackerMatch">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SiderealStackerMatch</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Take in a set of sidereal days, and stack them up.</span>

<span class="sd">    This treats the time average of each input sidereal stream as an extra source of</span>
<span class="sd">    noise and uses a Wiener filter approach to consistent stack the individual streams</span>
<span class="sd">    together while accounting for their distinct coverage in RA. In practice this is</span>
<span class="sd">    used for co-adding stacks with different sidereal coverage while marginalising out</span>
<span class="sd">    the effects of the different cross talk contributions that each input stream may</span>
<span class="sd">    have.</span>

<span class="sd">    There is no uniquely correct solution for the sidereal average (or m=0 mode) of the</span>
<span class="sd">    output stream. This task fixes this unknown mode by setting the *median* of each 24</span>
<span class="sd">    hour period to zero. Note this is not the same as setting the m=0 mode to be zero.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tag : str</span>
<span class="sd">        The tag to give the stack.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">stack</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">lsd_list</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">tag</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;stack&quot;</span><span class="p">)</span>

    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="SiderealStackerMatch.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.sidereal.html#draco.analysis.sidereal.SiderealStackerMatch.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sdata</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Stack up sidereal days.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sdata : containers.SiderealStream</span>
<span class="sd">            Individual sidereal day to stack up.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that the input container is of the correct type</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sdata</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;type(sdata) (=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">sdata</span><span class="p">)</span><span class="si">}</span><span class="s2">) does not match &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;type(stack) (=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">)</span><span class="si">}</span><span class="s2">).&quot;</span>
            <span class="p">)</span>

        <span class="n">sdata</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting new stack.&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">sdata</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

            <span class="c1"># Initialise all datasets to zero</span>
            <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">ds</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ni_s</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">(</span><span class="n">sdata</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sdata</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">comm</span><span class="o">=</span><span class="n">sdata</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Vm</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lsd_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">label</span> <span class="o">=</span> <span class="n">sdata</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;stream_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2"> to stack.&quot;</span><span class="p">)</span>

        <span class="c1"># Get an estimate of the noise inverse for each time and freq in the file.</span>
        <span class="c1"># Average over baselines as we don&#39;t have the memory</span>
        <span class="n">Ni_d</span> <span class="o">=</span> <span class="n">sdata</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Calculate the trace of the inverse noise covariance for each frequency</span>
        <span class="n">tr_Ni</span> <span class="o">=</span> <span class="n">Ni_d</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Calculate the projection vector v</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">Ni_d</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">tr_Ni</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="o">**</span> <span class="mf">0.5</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">sdata</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span>

        <span class="c1"># Calculate and store the dirty map in the stack container</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="n">d</span> <span class="o">*</span> <span class="n">Ni_d</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="c1"># - v[:, np.newaxis, :] * np.dot(sdata.vis[:], v.T)[..., np.newaxis]</span>
            <span class="o">-</span> <span class="n">v</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">d</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Propagate the transformation into the weights, but for the moment we need to</span>
        <span class="c1"># store the variance. We don&#39;t propagate the change coming from matching the</span>
        <span class="c1"># means, as it is small, and the effects are primarily on the off-diagonal</span>
        <span class="c1"># covariance entries that we don&#39;t store anyway</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">sdata</span><span class="o">.</span><span class="n">weight</span><span class="p">[:])</span> <span class="o">*</span> <span class="n">Ni_d</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="p">)</span>

        <span class="c1"># Accumulate the total inverse noise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ni_s</span> <span class="o">+=</span> <span class="n">Ni_d</span>

        <span class="c1"># We need to keep the projection vector until the end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Vm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;effective_ra&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
            <span class="c1"># Track the effective ra bin centres. We&#39;re using the averaged</span>
            <span class="c1"># weights here, so this generally isn&#39;t optimal</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">Ni_d</span> <span class="o">*</span> <span class="p">(</span><span class="n">sdata</span><span class="o">.</span><span class="n">effective_ra</span><span class="p">[:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">effective_ra</span><span class="p">[:])</span>
            <span class="c1"># Update the mean effective ra using the mean of the normalized weights</span>
            <span class="n">sum_weight</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">weight</span><span class="p">[:])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ni_s</span><span class="o">**</span><span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">effective_ra</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span>
                <span class="n">sum_weight</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Get the LSD label out of the data (resort to using a CSD if it&#39;s</span>
        <span class="c1"># present). If there&#39;s no label just use a place holder and stack</span>
        <span class="c1"># anyway.</span>
        <span class="k">if</span> <span class="s2">&quot;lsd&quot;</span> <span class="ow">in</span> <span class="n">sdata</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="n">input_lsd</span> <span class="o">=</span> <span class="n">sdata</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="s2">&quot;csd&quot;</span> <span class="ow">in</span> <span class="n">sdata</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="n">input_lsd</span> <span class="o">=</span> <span class="n">sdata</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;csd&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">input_lsd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lsd_list</span> <span class="o">+=</span> <span class="n">_ensure_list</span><span class="p">(</span><span class="n">input_lsd</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="SiderealStackerMatch.process_finish">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.sidereal.html#draco.analysis.sidereal.SiderealStackerMatch.process_finish">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process_finish</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct and emit sidereal stack.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        stack : containers.SiderealStream</span>
<span class="sd">            Stack of sidereal days.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag</span>

        <span class="n">Va</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Vm</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Dereference for efficiency to avoid MPI calls in the loop</span>
        <span class="n">sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">sw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="c1"># Loop over all frequencies to do the deconvolution. The loop is done because</span>
        <span class="c1"># of the difficulty mapping the operations we would want to do into what numpy</span>
        <span class="c1"># allows</span>
        <span class="k">for</span> <span class="n">lfi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">Ni_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ni_s</span><span class="o">.</span><span class="n">local_array</span><span class="p">[</span><span class="n">lfi</span><span class="p">]</span>
            <span class="n">N_s</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">Ni_s</span><span class="p">)</span>
            <span class="n">V</span> <span class="o">=</span> <span class="n">Va</span><span class="p">[</span><span class="n">lfi</span><span class="p">]</span> <span class="o">*</span> <span class="n">N_s</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

            <span class="c1"># Note, need to use a pseudo-inverse in here as there is a singular mode</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">Ni_s</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">V</span><span class="p">),</span>
                <span class="n">rcond</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Perform the deconvolution step</span>
            <span class="n">sv</span><span class="p">[</span><span class="n">lfi</span><span class="p">]</span> <span class="o">=</span> <span class="n">sv</span><span class="p">[</span><span class="n">lfi</span><span class="p">]</span> <span class="o">*</span> <span class="n">N_s</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sv</span><span class="p">[</span><span class="n">lfi</span><span class="p">],</span> <span class="n">V</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

            <span class="c1"># Normalise the weights</span>
            <span class="n">sw</span><span class="p">[</span><span class="n">lfi</span><span class="p">]</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">sw</span><span class="p">[</span><span class="n">lfi</span><span class="p">])</span> <span class="o">*</span> <span class="n">Ni_s</span><span class="o">**</span><span class="mi">2</span>

        <span class="c1"># Remove the full day median to set a well defined normalisation, otherwise the</span>
        <span class="c1"># mean is undefined</span>
        <span class="n">stack_median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">sv</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">sv</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span><span class="n">j</span>
        <span class="n">sv</span> <span class="o">-=</span> <span class="n">stack_median</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="c1"># Set the full LSD list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lsd_list</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span></div>
</div>



<div class="viewcode-block" id="get_slice_to_broadcast">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.sidereal.html#draco.analysis.sidereal.get_slice_to_broadcast">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_slice_to_broadcast</span><span class="p">(</span><span class="n">weight_axis</span><span class="p">,</span> <span class="n">dataset_axis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a slice that will broadcast the weights against some other dataset.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    weight_axis : list of str</span>
<span class="sd">        Names of the axes in the weights.</span>
<span class="sd">    dataset_axis : list of str</span>
<span class="sd">        Names of the axes in the dataset.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    slc : list containing either slice(None) or None</span>
<span class="sd">        Slice that when applied to the weights will make them broadcastable</span>
<span class="sd">        against the other dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The number of dimensions in the weights must be equal or less than</span>
    <span class="c1"># the number of dimensions in the dataset.</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">weight_axis</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset_axis</span><span class="p">)</span>

    <span class="c1"># The weights cannot have any additional axes that are not present in the dataset.</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">wax</span> <span class="ow">in</span> <span class="n">dataset_axis</span> <span class="k">for</span> <span class="n">wax</span> <span class="ow">in</span> <span class="n">weight_axis</span><span class="p">)</span>

    <span class="c1"># The axes that are shared between the weights and the other dataset</span>
    <span class="c1"># must be in the same order.</span>
    <span class="n">common_axis</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">dataset_axis</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">weight_axis</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">wax</span> <span class="o">==</span> <span class="n">dax</span> <span class="k">for</span> <span class="n">wax</span><span class="p">,</span> <span class="n">dax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">weight_axis</span><span class="p">,</span> <span class="n">common_axis</span><span class="p">))</span>

    <span class="c1"># If all checks passed, then return the slice to broadcast.</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">weight_axis</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">dataset_axis</span><span class="p">])</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_ensure_list</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">y</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016, Richard Shaw.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>