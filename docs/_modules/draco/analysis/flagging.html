

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>draco.analysis.flagging &mdash; draco 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=9edc463e" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            draco
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev.html">Development Guidelines</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">draco</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">draco.analysis.flagging</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for draco.analysis.flagging</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Tasks for flagging out bad or unwanted data.</span>

<span class="sd">This includes data quality flagging on timestream data; sun excision on sidereal</span>
<span class="sd">data; and pre-map making flagging on m-modes.</span>

<span class="sd">The convention for flagging/masking is `True` for contaminated samples that should</span>
<span class="sd">be excluded and `False` for clean samples.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">ClassVar</span><span class="p">,</span> <span class="n">overload</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">npt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">caput</span><span class="w"> </span><span class="kn">import</span> <span class="n">config</span><span class="p">,</span> <span class="n">mpiarray</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">caput.algorithms</span><span class="w"> </span><span class="kn">import</span> <span class="n">fft</span> <span class="k">as</span> <span class="n">cfft</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">caput.algorithms</span><span class="w"> </span><span class="kn">import</span> <span class="n">median</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">caput.astro</span><span class="w"> </span><span class="kn">import</span> <span class="n">constants</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">caput.containers</span><span class="w"> </span><span class="kn">import</span> <span class="n">ContainerPrototype</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">caput.pipeline</span><span class="w"> </span><span class="kn">import</span> <span class="n">tasklib</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.signal</span><span class="w"> </span><span class="kn">import</span> <span class="n">convolve</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.distance</span><span class="w"> </span><span class="kn">import</span> <span class="n">cdist</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">skimage.filters</span><span class="w"> </span><span class="kn">import</span> <span class="n">apply_hysteresis_threshold</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">..analysis</span><span class="w"> </span><span class="kn">import</span> <span class="n">transform</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..analysis.sidereal</span><span class="w"> </span><span class="kn">import</span> <span class="n">_search_nearest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..core</span><span class="w"> </span><span class="kn">import</span> <span class="n">containers</span><span class="p">,</span> <span class="n">io</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..util</span><span class="w"> </span><span class="kn">import</span> <span class="n">filters</span><span class="p">,</span> <span class="n">rfi</span><span class="p">,</span> <span class="n">tools</span>


<div class="viewcode-block" id="DayMask">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.DayMask">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DayMask</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Crudely simulate a masking out of the daytime data.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    start, end : float</span>
<span class="sd">        Start and end of masked out region.</span>
<span class="sd">    width : float</span>
<span class="sd">        Use a smooth transition of given width between the fully masked and</span>
<span class="sd">        unmasked data. This is interior to the region marked by start and end.</span>
<span class="sd">    zero_data : bool, optional</span>
<span class="sd">        Zero the data in addition to modifying the noise weights</span>
<span class="sd">        (default is True).</span>
<span class="sd">    remove_average : bool, optional</span>
<span class="sd">        Estimate and remove the mean level from each visibilty. This estimate</span>
<span class="sd">        does not use data from the masked region.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">90.0</span><span class="p">)</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">270.0</span><span class="p">)</span>

    <span class="n">width</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">60.0</span><span class="p">)</span>

    <span class="n">zero_data</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">remove_average</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="DayMask.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.DayMask.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sstream</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply a day time mask.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sstream : containers.SiderealStream</span>
<span class="sd">            Unmasked sidereal stack.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mstream : containers.SiderealStream</span>
<span class="sd">            Masked sidereal stream.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sstream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">ra_shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">sstream</span><span class="o">.</span><span class="n">ra</span><span class="p">[:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="o">%</span> <span class="mf">360.0</span>
        <span class="n">end_shift</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="o">%</span> <span class="mf">360.0</span>

        <span class="c1"># Crudely mask the on and off regions</span>
        <span class="n">mask_bool</span> <span class="o">=</span> <span class="n">ra_shift</span> <span class="o">&gt;</span> <span class="n">end_shift</span>

        <span class="c1"># Put in the transition at the start of the day</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">ra_shift</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span>
            <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">ra_shift</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">))),</span>
            <span class="n">mask_bool</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Put the transition at the end of the day</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">ra_shift</span> <span class="o">&gt;</span> <span class="n">end_shift</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">ra_shift</span> <span class="o">&lt;=</span> <span class="n">end_shift</span><span class="p">),</span>
            <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">((</span><span class="n">ra_shift</span> <span class="o">-</span> <span class="n">end_shift</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">))),</span>
            <span class="n">mask</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_average</span><span class="p">:</span>
            <span class="c1"># Estimate the mean level from unmasked data</span>
            <span class="n">nanvis</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">sstream</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span>
                <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_bool</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="p">)</span>
            <span class="n">average</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">nanvis</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">sstream</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span> <span class="o">-=</span> <span class="n">average</span>

        <span class="c1"># Apply the mask to the data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">zero_data</span><span class="p">:</span>
            <span class="n">sstream</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">mask</span>

        <span class="c1"># Modify the noise weights</span>
        <span class="n">sstream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">mask</span><span class="o">**</span><span class="mi">2</span>

        <span class="k">return</span> <span class="n">sstream</span></div>
</div>



<div class="viewcode-block" id="MaskMModeData">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.MaskMModeData">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MaskMModeData</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mask out mmode data ahead of map making.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    auto_correlations : bool</span>
<span class="sd">        Exclude auto correlations if set (default=False).</span>
<span class="sd">    m_zero : bool</span>
<span class="sd">        Ignore the m=0 mode (default=False).</span>
<span class="sd">    positive_m : bool</span>
<span class="sd">        Include positive m-modes (default=True).</span>
<span class="sd">    negative_m : bool</span>
<span class="sd">        Include negative m-modes (default=True).</span>
<span class="sd">    mask_low_m : int, optional</span>
<span class="sd">        If set, mask out m&#39;s lower than this threshold.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">auto_correlations</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">m_zero</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">positive_m</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">negative_m</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">mask_low_m</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

<div class="viewcode-block" id="MaskMModeData.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.MaskMModeData.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mmodes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mask out unwanted datain the m-modes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mmodes : containers.MModes</span>
<span class="sd">            Mmode container to mask</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mmodes : containers.MModes</span>
<span class="sd">            Same object as input with masking applied</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mmodes</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">mw</span> <span class="o">=</span> <span class="n">mmodes</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span>

        <span class="c1"># Exclude auto correlations if set</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">auto_correlations</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">pi</span><span class="p">,</span> <span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="n">fj</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mmodes</span><span class="o">.</span><span class="n">prodstack</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">fi</span> <span class="o">==</span> <span class="n">fj</span><span class="p">:</span>
                    <span class="n">mw</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">pi</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Apply m based masks</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_zero</span><span class="p">:</span>
            <span class="n">mw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">positive_m</span><span class="p">:</span>
            <span class="n">mw</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">negative_m</span><span class="p">:</span>
            <span class="n">mw</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_low_m</span><span class="p">:</span>
            <span class="n">mw</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_low_m</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">return</span> <span class="n">mmodes</span></div>
</div>



<div class="viewcode-block" id="MaskBaselines">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.MaskBaselines">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MaskBaselines</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mask out baselines from a dataset.</span>

<span class="sd">    This task may produce output with shared datasets. Be warned that</span>
<span class="sd">    this can produce unexpected outputs if not properly taken into</span>
<span class="sd">    account.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    mask_long_ns : float, optional</span>
<span class="sd">        Mask out baselines longer than a given distance in the N/S direction.</span>
<span class="sd">    mask_short : float, optional</span>
<span class="sd">        Mask out baselines shorter than a given distance.</span>
<span class="sd">    mask_short_ew : float, optional</span>
<span class="sd">        Mask out baselines shorter then a given distance in the East-West</span>
<span class="sd">        direction. Useful for masking out intra-cylinder baselines for</span>
<span class="sd">        North-South oriented cylindrical telescopes.</span>
<span class="sd">    mask_short_ns : float, optional</span>
<span class="sd">        Mask out baselines shorter then a given distance in the North-South</span>
<span class="sd">        direction.</span>
<span class="sd">    mask_pol : list of str, optional</span>
<span class="sd">        List of polarisation products to mask. Each entry should be a string</span>
<span class="sd">        of length 2, e.g. [&quot;XX&quot;, &quot;YY&quot;].</span>
<span class="sd">    missing_threshold : float, optional</span>
<span class="sd">        Mask any baseline that is missing more than this fraction of samples. This is</span>
<span class="sd">        measured relative to other baselines.</span>
<span class="sd">    zero_data : bool, optional</span>
<span class="sd">        Zero the data in addition to modifying the noise weights</span>
<span class="sd">        (default is False).</span>
<span class="sd">    share : {&quot;all&quot;, &quot;none&quot;, &quot;vis&quot;}</span>
<span class="sd">        Which datasets should we share with the input. If &quot;none&quot; we create a</span>
<span class="sd">        full copy of the data, if &quot;vis&quot; we create a copy only of the modified</span>
<span class="sd">        weight dataset and the unmodified vis dataset is shared, if &quot;all&quot; we</span>
<span class="sd">        modify in place and return the input container.</span>
<span class="sd">    combine_method: {&quot;and&quot;, &quot;or&quot;}</span>
<span class="sd">        Method to combine different flagging criteria. If &quot;or&quot;, a baseline is</span>
<span class="sd">        flagged if any of the criteria are met. If &quot;and&quot;, all criteria must be met.</span>
<span class="sd">        Default is &quot;or&quot;.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mask_long_ns</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">mask_short</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">mask_short_ew</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">mask_short_ns</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="n">mask_pol</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="n">weight_threshold</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">missing_threshold</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="n">zero_data</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">share</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">enum</span><span class="p">([</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;vis&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>

    <span class="n">combine_method</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">enum</span><span class="p">([</span><span class="s2">&quot;and&quot;</span><span class="p">,</span> <span class="s2">&quot;or&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;or&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="MaskBaselines.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.MaskBaselines.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">telescope</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the telescope model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        telescope : TransitTelescope</span>
<span class="sd">            The telescope object to use</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">get_telescope</span><span class="p">(</span><span class="n">telescope</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">zero_data</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">share</span> <span class="o">==</span> <span class="s2">&quot;vis&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t zero the visibilities if they are shared.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="MaskBaselines.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.MaskBaselines.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply the mask to data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ss : SiderealStream or TimeStream</span>
<span class="sd">            Data to mask. Applied in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">mpi4py</span><span class="w"> </span><span class="kn">import</span> <span class="n">MPI</span>

        <span class="n">ss</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">baselines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">baselines</span>

        <span class="c1"># Get the method used to combine the mask and initialise the masking</span>
        <span class="c1"># array accordingly. True indicates a flagged sample.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_method</span> <span class="o">==</span> <span class="s2">&quot;or&quot;</span><span class="p">:</span>
            <span class="n">combine_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_method</span> <span class="o">==</span> <span class="s2">&quot;and&quot;</span><span class="p">:</span>
            <span class="n">combine_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown combine_method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">combine_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_long_ns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">long_ns_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">baselines</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_long_ns</span>
            <span class="n">combine_func</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">long_ns_mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_short</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">short_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">baselines</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_short</span>
            <span class="n">combine_func</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">short_mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_short_ew</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">short_ew_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">baselines</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_short_ew</span>
            <span class="n">combine_func</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">short_ew_mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_short_ns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">short_ns_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">baselines</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_short_ns</span>
            <span class="n">combine_func</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">short_ns_mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Get the sum of the weights over frequencies</span>
            <span class="n">weight_sum_local</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">weight_sum_tot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">weight_sum_local</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Allreduce</span><span class="p">(</span><span class="n">weight_sum_local</span><span class="p">,</span> <span class="n">weight_sum_tot</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">SUM</span><span class="p">)</span>

            <span class="c1"># Retain only baselines with average weights larger than the threshold</span>
            <span class="n">combine_func</span><span class="p">(</span>
                <span class="n">mask</span><span class="p">,</span>
                <span class="n">weight_sum_tot</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_threshold</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">freq</span><span class="p">),</span>
                <span class="n">out</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Get the total number of samples for each baseline accumulated onto each</span>
            <span class="c1"># rank</span>
            <span class="n">nsamp_local</span> <span class="o">=</span> <span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">nsamp_tot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">nsamp_local</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Allreduce</span><span class="p">(</span><span class="n">nsamp_local</span><span class="p">,</span> <span class="n">nsamp_tot</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">SUM</span><span class="p">)</span>

            <span class="c1"># Mask out baselines with more that `missing_threshold` samples missing</span>
            <span class="n">baseline_missing_ratio</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">nsamp_tot</span> <span class="o">/</span> <span class="n">nsamp_tot</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">combine_func</span><span class="p">(</span>
                <span class="n">mask</span><span class="p">,</span>
                <span class="n">baseline_missing_ratio</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_threshold</span><span class="p">,</span>
                <span class="n">out</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_pol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">polarisation</span><span class="p">)[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">uniquepairs</span>
            <span class="p">]</span>
            <span class="n">pols</span> <span class="o">=</span> <span class="n">pols</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">pols</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_pol</span><span class="p">:</span>
                <span class="n">combine_func</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="n">pols</span> <span class="o">==</span> <span class="n">p</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">share</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">ssc</span> <span class="o">=</span> <span class="n">ss</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">share</span> <span class="o">==</span> <span class="s2">&quot;vis&quot;</span><span class="p">:</span>
            <span class="n">ssc</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">shared</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;vis&quot;</span><span class="p">,))</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># self.share == &quot;none&quot;</span>
            <span class="n">ssc</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Apply the mask to the weight</span>
        <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span>
            <span class="n">ssc</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">ssc</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="p">)</span>

        <span class="c1"># Apply the mask to the data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">zero_data</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span>
                <span class="n">ssc</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">ssc</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">ssc</span></div>
</div>



<div class="viewcode-block" id="FindBeamformedOutliers">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.FindBeamformedOutliers">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FindBeamformedOutliers</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Identify beamformed visibilities that deviate from our expectation for noise.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    nsigma : float</span>
<span class="sd">        Beamformed visibilities whose magnitude is greater than nsigma times</span>
<span class="sd">        the expected standard deviation of the noise, given by sqrt(1 / weight),</span>
<span class="sd">        will be masked.</span>
<span class="sd">    window : list of int</span>
<span class="sd">        If provided, the outlier mask will be extended to cover neighboring pixels.</span>
<span class="sd">        This list provides the number of pixels in each dimension that a single</span>
<span class="sd">        outlier will mask.  Only supported for RingMap containers, where the list</span>
<span class="sd">        should be length 2 with [nra, nel], and FormedBeamHA containers, where the list</span>
<span class="sd">        should be length 1 with [nha,].</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nsigma</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

<div class="viewcode-block" id="FindBeamformedOutliers.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.FindBeamformedOutliers.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a mask that indicates outlier beamformed visibilities.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : FormedBeam, FormedBeamHA, or RingMap</span>
<span class="sd">            Beamformed visibilities.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : FormedBeamMask, FormedBeamHAMask, or RingMapMask</span>
<span class="sd">            Container with a boolean mask where True indicates</span>
<span class="sd">            outlier beamformed visibilities.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">class_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">containers</span><span class="o">.</span><span class="n">FormedBeam</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;beam&quot;</span><span class="p">,</span> <span class="n">containers</span><span class="o">.</span><span class="n">FormedBeamMask</span><span class="p">),</span>
            <span class="n">containers</span><span class="o">.</span><span class="n">FormedBeamHA</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;beam&quot;</span><span class="p">,</span> <span class="n">containers</span><span class="o">.</span><span class="n">FormedBeamHAMask</span><span class="p">),</span>
            <span class="n">containers</span><span class="o">.</span><span class="n">RingMap</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;map&quot;</span><span class="p">,</span> <span class="n">containers</span><span class="o">.</span><span class="n">RingMapMask</span><span class="p">),</span>
        <span class="p">}</span>

        <span class="n">dataset</span><span class="p">,</span> <span class="n">out_cont</span> <span class="o">=</span> <span class="n">class_dict</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="vm">__class__</span><span class="p">]</span>

        <span class="c1"># Redistribute data over frequency</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Make sure the weight dataset has the same</span>
        <span class="c1"># number of dimensions as the visibility dataset.</span>
        <span class="n">axes1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span>
        <span class="n">axes2</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span>

        <span class="n">bcast_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes2</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes1</span><span class="p">)</span>
        <span class="n">axes_collapse</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ii</span> <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes1</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes2</span><span class="p">)</span>

        <span class="c1"># Calculate the expected standard deviation based on weights dataset</span>
        <span class="n">inv_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:][</span><span class="n">bcast_slice</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span>

        <span class="c1"># Standardize the beamformed visibilities</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">dataset</span><span class="p">][:]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_sigma</span><span class="p">)</span>

        <span class="c1"># Mask outliers</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">ratio</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsigma</span>

        <span class="k">if</span> <span class="n">axes_collapse</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axes_collapse</span><span class="p">)</span>

        <span class="c1"># Apply a smoothing operation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ndim_smooth</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">)</span>
            <span class="n">ndim_iter</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">ndim_smooth</span>
            <span class="n">shp</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ndim_iter</span><span class="p">]</span>

            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">axes2</span><span class="p">[</span><span class="n">ndim_iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ww</span><span class="p">]</span><span class="si">}</span><span class="s2"> [</span><span class="si">{</span><span class="n">win</span><span class="si">}</span><span class="s2">]&quot;</span>
                    <span class="k">for</span> <span class="n">ww</span><span class="p">,</span> <span class="n">win</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Extending mask along: axis [num extended] = </span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">th</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">kernel</span><span class="o">.</span><span class="n">size</span>

            <span class="c1"># Loop over the dimensions that are not being convolved</span>
            <span class="c1"># to prevent memory errors due to intermediate products</span>
            <span class="c1"># created by scipy&#39;s convolve.</span>
            <span class="n">mask_extended</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="o">*</span><span class="n">shp</span><span class="p">):</span>
                <span class="n">mask_extended</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">convolve</span><span class="p">(</span>
                        <span class="n">mask</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
                        <span class="n">kernel</span><span class="p">,</span>
                        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;same&quot;</span><span class="p">,</span>
                        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="o">&gt;</span> <span class="n">th</span>
                <span class="p">)</span>

            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask_extended</span>

        <span class="c1"># Save the mask to a separate container</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out_cont</span><span class="p">(</span>
            <span class="n">axes_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">attrs_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">distributed</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">distributed</span><span class="p">,</span>
            <span class="n">comm</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">mask</span>

        <span class="k">return</span> <span class="n">out</span></div>
</div>



<div class="viewcode-block" id="MaskBadGains">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.MaskBadGains">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MaskBadGains</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get a mask of regions with bad gain.</span>

<span class="sd">    Assumes that bad gains are set to 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">threshold</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">threshold_tol</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>

<div class="viewcode-block" id="MaskBadGains.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.MaskBadGains.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a time-freq mask.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : :class:`andata.Corrdata` or :class:`ContainerPrototype` with a `gain` dataset</span>
<span class="sd">            Data containing the gains to be flagged. Must have a `gain` dataset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask : RFIMask container</span>
<span class="sd">            Time-freq mask</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure data is distributed in frequency</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Boolean mask where gains are bad across all baselines.</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
            <span class="n">data</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold_tol</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span><span class="o">.</span><span class="n">allgather</span><span class="p">()</span>

        <span class="n">mask_cont</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">RFIMask</span><span class="p">(</span><span class="n">axes_from</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
        <span class="n">mask_cont</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">mask</span>

        <span class="k">return</span> <span class="n">mask_cont</span></div>
</div>



<div class="viewcode-block" id="MaskBeamformedWeights">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.MaskBeamformedWeights">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MaskBeamformedWeights</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mask beamformed visibilities with anomalously large weights before stacking.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    nmed : float</span>
<span class="sd">        Any weight that is more than `nmed` times the median weight</span>
<span class="sd">        over all objects and frequencies will be set to zero.</span>
<span class="sd">        Default is 8.0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nmed</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">8.0</span><span class="p">)</span>

<div class="viewcode-block" id="MaskBeamformedWeights.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.MaskBeamformedWeights.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mask large weights.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : FormedBeam</span>
<span class="sd">            Beamformed visibilities.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : FormedBeam</span>
<span class="sd">            The input container with the weight dataset set to zero</span>
<span class="sd">            if the weights exceed the threshold.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">caput.util</span><span class="w"> </span><span class="kn">import</span> <span class="n">mpitools</span>

        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;object_id&quot;</span><span class="p">)</span>

        <span class="n">npol</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pol</span><span class="o">.</span><span class="n">size</span>
        <span class="n">med_weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">npol</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npol</span><span class="p">):</span>
            <span class="n">wlocal</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:,</span> <span class="n">pp</span><span class="p">]</span>
            <span class="n">wglobal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">wlocal</span><span class="o">.</span><span class="n">global_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">wlocal</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="n">mpitools</span><span class="o">.</span><span class="n">gather_local</span><span class="p">(</span>
                <span class="n">wglobal</span><span class="p">,</span> <span class="n">wlocal</span><span class="p">,</span> <span class="n">wlocal</span><span class="o">.</span><span class="n">local_offset</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">comm</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">med_weight</span><span class="p">[</span><span class="n">pp</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">wglobal</span><span class="p">[</span><span class="n">wglobal</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Median weight for Pol </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">pol</span><span class="p">[</span><span class="n">pp</span><span class="p">]</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">med_weight</span><span class="p">[</span><span class="n">pp</span><span class="p">]</span><span class="si">:</span><span class="s2">0.2e</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Broadcast the median weight to all ranks</span>
        <span class="n">data</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">med_weight</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">w</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmed</span> <span class="o">*</span> <span class="n">med_weight</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>

        <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">flag</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span></div>
</div>



<div class="viewcode-block" id="RadiometerWeight">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RadiometerWeight">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RadiometerWeight</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Update vis_weight according to the radiometer equation.</span>

<span class="sd">    .. math::</span>

<span class="sd">        \text{weight}_{ij} = N_\text{samp} / V_{ii} V_{jj}</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    replace : bool, optional</span>
<span class="sd">        Replace any existing weights (default). If `False` then we multiply the</span>
<span class="sd">        existing weights by the radiometer values.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">replace</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="RadiometerWeight.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RadiometerWeight.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Change the vis weight.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stream : SiderealStream or TimeStream</span>
<span class="sd">            Data to be weighted. This is done in place.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        stream : SiderealStream or TimeStream</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">caput.astro.constants</span><span class="w"> </span><span class="kn">import</span> <span class="n">STELLAR_S</span>

        <span class="c1"># Redistribute over the frequency direction</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">ninput</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">])</span>
        <span class="n">nprod</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">nprod</span> <span class="o">!=</span> <span class="p">(</span><span class="n">ninput</span> <span class="o">*</span> <span class="p">(</span><span class="n">ninput</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Must have a input stream with the full correlation triangle.&quot;</span>
            <span class="p">)</span>

        <span class="n">freq_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">][</span><span class="s2">&quot;width&quot;</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealStream</span><span class="p">):</span>
            <span class="n">RA_S</span> <span class="o">=</span> <span class="mi">240</span> <span class="o">*</span> <span class="n">STELLAR_S</span>  <span class="c1"># SI seconds in 1 deg of RA change</span>
            <span class="n">int_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">ra</span><span class="p">)))</span> <span class="o">/</span> <span class="n">RA_S</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">int_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">])))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace</span><span class="p">:</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># Construct and set the correct weights in place</span>
        <span class="n">nsamp</span> <span class="o">=</span> <span class="mf">1e6</span> <span class="o">*</span> <span class="n">freq_width</span> <span class="o">*</span> <span class="n">int_time</span>
        <span class="n">autos</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">extract_diagonal</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">vis</span><span class="p">[:])</span><span class="o">.</span><span class="n">real</span>
        <span class="n">weight_fac</span> <span class="o">=</span> <span class="n">nsamp</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">/</span> <span class="n">autos</span>
        <span class="n">tools</span><span class="o">.</span><span class="n">apply_gain</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:],</span> <span class="n">weight_fac</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">stream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:])</span>

        <span class="c1"># Return timestream with updated weights</span>
        <span class="k">return</span> <span class="n">stream</span></div>
</div>



<div class="viewcode-block" id="SanitizeWeights">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.SanitizeWeights">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SanitizeWeights</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Flags weights outside of a valid range.</span>

<span class="sd">    Flags any weights above a max threshold and below a minimum threshold.</span>
<span class="sd">    Baseline dependent, so only some baselines may be flagged.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    max_thresh : float</span>
<span class="sd">        largest value to keep</span>
<span class="sd">    min_thresh : float</span>
<span class="sd">        smallest value to keep</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">max_thresh</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1e30</span><span class="p">)</span>
    <span class="n">min_thresh</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1e-30</span><span class="p">)</span>

<div class="viewcode-block" id="SanitizeWeights.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.SanitizeWeights.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate the max and min values.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            if min_thresh is larger than max_thresh</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_thresh</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_thresh</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Minimum threshold is larger than maximum threshold.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SanitizeWeights.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.SanitizeWeights.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mask any weights outside of the threshold range.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : :class:`andata.CorrData` or :class:`containers.VisContainer` object</span>
<span class="sd">            Data containing the weights to be flagged</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : same object as data</span>
<span class="sd">            Data object with high/low weights masked in-place</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure data is distributed in frequency</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">weight</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="n">weight</span><span class="p">[</span><span class="n">weight</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_thresh</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">weight</span><span class="p">[</span><span class="n">weight</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_thresh</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">return</span> <span class="n">data</span></div>
</div>



<div class="viewcode-block" id="NegativeAutosMask">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.NegativeAutosMask">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">NegativeAutosMask</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Flag in frequency-time if any autocorrelation is negative.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="NegativeAutosMask.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.NegativeAutosMask.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">VisContainer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">RFIMask</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract autos and flag if any auto is negative.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data</span>
<span class="sd">            Timestream dataset containing visibilities and</span>
<span class="sd">            the relevant index map entries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask</span>
<span class="sd">            time-frequency mask</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Extract autocorrelations</span>
        <span class="n">prodstack</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">prodstack</span>
        <span class="n">autos</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="p">[:,</span> <span class="n">prodstack</span><span class="p">[</span><span class="s2">&quot;input_a&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">prodstack</span><span class="p">[</span><span class="s2">&quot;input_b&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">real</span>

        <span class="c1"># Flag if any auto is negative and gather the mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">autos</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">allgather</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mf">100.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mask</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">% of data flagged due to negative autos.&quot;</span>
        <span class="p">)</span>

        <span class="n">mask_cont</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">RFIMask</span><span class="p">(</span><span class="n">axes_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">attrs_from</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
        <span class="n">mask_cont</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">mask</span>

        <span class="k">return</span> <span class="n">mask_cont</span></div>
</div>



<div class="viewcode-block" id="SmoothVisWeight">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.SmoothVisWeight">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SmoothVisWeight</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Smooth the visibility weights with a median filter.</span>

<span class="sd">    This is done in-place.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    kernel_size : int, optional</span>
<span class="sd">        Size of the kernel for the median filter in time points.</span>
<span class="sd">        Default is 31, corresponding to ~5 minutes window for 10s cadence data.</span>
<span class="sd">    mask_zeros : bool, optional</span>
<span class="sd">        Mask out zero-weight entries when taking the moving weighted median.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># 31 time points correspond to ~ 5min in 10s cadence</span>
    <span class="n">kernel_size</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">31</span><span class="p">)</span>
    <span class="n">mask_zeros</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="SmoothVisWeight.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.SmoothVisWeight.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">TimeStream</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">TimeStream</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Smooth the weights with a median filter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data</span>
<span class="sd">            Data containing the weights to be smoothed</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data</span>
<span class="sd">            Data object containing the same data as the input, but with the</span>
<span class="sd">            weights substituted by the smoothed ones.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure data is distributed in frequency,</span>
        <span class="c1"># so a frequency loop will not be too large.</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">weight_local</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">weight_local</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1"># Find values equal to zero to preserve them in final weights</span>
            <span class="n">zeromask</span> <span class="o">=</span> <span class="n">weight_local</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span>

            <span class="c1"># moving_weighted_median wants float64-type weights</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_zeros</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">weight_local</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">weight_local</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="n">weight_local</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">median</span><span class="o">.</span><span class="n">moving_weighted_median</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">weight_local</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">weights</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
                <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_size</span><span class="p">),</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;split&quot;</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Ensure zero values are zero</span>
            <span class="n">weight_local</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">zeromask</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">return</span> <span class="n">data</span></div>
</div>



<div class="viewcode-block" id="ThresholdVisWeightFrequency">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.ThresholdVisWeightFrequency">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ThresholdVisWeightFrequency</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a mask to remove all weights below a per-frequency threshold.</span>

<span class="sd">    A single relative threshold is set for each frequency along with an absolute</span>
<span class="sd">    minimum weight threshold. Masking is done relative to the mean baseline.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    absolute_threshold : float</span>
<span class="sd">        Any weights with values less than this number will be set to zero.</span>
<span class="sd">    relative_threshold : float</span>
<span class="sd">        Any weights with values less than this number times the average weight</span>
<span class="sd">        will be set to zero.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">absolute_threshold</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">)</span>
    <span class="n">relative_threshold</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>

<div class="viewcode-block" id="ThresholdVisWeightFrequency.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.ThresholdVisWeightFrequency.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make a baseline-independent mask.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stream : `.core.container` with `weight` attribute</span>
<span class="sd">            Container to mask</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : RFIMask container</span>
<span class="sd">            RFIMask container with mask set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Make the output container depending on what &#39;stream&#39; is</span>
        <span class="k">if</span> <span class="s2">&quot;ra&quot;</span> <span class="ow">in</span> <span class="n">stream</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
            <span class="n">mask_cont</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealRFIMask</span><span class="p">(</span><span class="n">axes_from</span><span class="o">=</span><span class="n">stream</span><span class="p">,</span> <span class="n">attrs_from</span><span class="o">=</span><span class="n">stream</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">stream</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
            <span class="n">mask_cont</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">RFIMask</span><span class="p">(</span><span class="n">axes_from</span><span class="o">=</span><span class="n">stream</span><span class="p">,</span> <span class="n">attrs_from</span><span class="o">=</span><span class="n">stream</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Require Timestream or SiderealStream. Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">weight</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="c1"># Average over the baselines (stack) axis</span>
        <span class="n">mean_baseline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Cut out any values below fixed threhold. Return a np.ndarray</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">mean_baseline</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">absolute_threshold</span><span class="p">,</span> <span class="n">mean_baseline</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="p">)</span>
        <span class="c1"># Average across the time (ra) axis to get per-frequency thresholds,</span>
        <span class="c1"># ignoring any nans. np.nanmean will give a warning if an entire band is</span>
        <span class="c1"># nan, which we expect to happen in some cases.</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="n">action</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Mean of empty slice&quot;</span><span class="p">)</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Create a 2D baseline-independent mask.</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span>
            <span class="n">mean_baseline</span>
            <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">fmax</span><span class="p">(</span><span class="n">threshold</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_threshold</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">absolute_threshold</span><span class="p">)</span>
        <span class="p">)[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># Collect all parts of the mask. Method .allgather() returns a np.ndarray</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">allgather</span><span class="p">()</span>
        <span class="c1"># Log the percent of data masked</span>
        <span class="n">drop_frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">%0.5f%%</span><span class="s2"> of data is below the weight threshold&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">drop_frac</span><span class="p">))</span>
        <span class="p">)</span>

        <span class="n">mask_cont</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">mask</span>

        <span class="k">return</span> <span class="n">mask_cont</span></div>
</div>



<div class="viewcode-block" id="ThresholdVisWeightBaseline">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.ThresholdVisWeightBaseline">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ThresholdVisWeightBaseline</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Form a mask corresponding to weights that are below some threshold.</span>

<span class="sd">    The threshold is determined as `maximum(absolute_threshold,</span>
<span class="sd">    relative_threshold * average(weight))` and is evaluated per product/stack</span>
<span class="sd">    entry. The user can specify whether to use a mean or median as the average,</span>
<span class="sd">    but note that the mean is much more likely to be biased by anomalously</span>
<span class="sd">    high- or low-weight samples (both of which are present in raw CHIME data).</span>
<span class="sd">    The user can also specify that weights below some threshold should not be</span>
<span class="sd">    considered when taking the average and constructing the mask (the default</span>
<span class="sd">    is to only ignore zero-weight samples).</span>

<span class="sd">    The task outputs a BaselineMask or SiderealBaselineMask depending on the</span>
<span class="sd">    input container.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    average_type : string, optional</span>
<span class="sd">        Type of average to use (&quot;median&quot; or &quot;mean&quot;). Default: &quot;median&quot;.</span>
<span class="sd">    absolute_threshold : float, optional</span>
<span class="sd">        Any weights with values less than this number will be set to zero.</span>
<span class="sd">        Default: 1e-7.</span>
<span class="sd">    relative_threshold : float, optional</span>
<span class="sd">        Any weights with values less than this number times the average weight</span>
<span class="sd">        will be set to zero. Default: 1e-6.</span>
<span class="sd">    ignore_absolute_threshold : float, optional</span>
<span class="sd">        Any weights with values less than this number will be ignored when</span>
<span class="sd">        taking averages and constructing the mask. Default: 0.0.</span>
<span class="sd">    pols_to_flag : string, optional</span>
<span class="sd">        Which polarizations to flag. &quot;copol&quot; only flags XX and YY baselines,</span>
<span class="sd">        while &quot;all&quot; flags everything. Default: &quot;all&quot;.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">average_type</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">enum</span><span class="p">([</span><span class="s2">&quot;median&quot;</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">)</span>
    <span class="n">absolute_threshold</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">)</span>
    <span class="n">relative_threshold</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">)</span>
    <span class="n">ignore_absolute_threshold</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">pols_to_flag</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">enum</span><span class="p">([</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="s2">&quot;copol&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="ThresholdVisWeightBaseline.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.ThresholdVisWeightBaseline.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">telescope</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the telescope model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        telescope : TransitTelescope</span>
<span class="sd">            The telescope object to use</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">get_telescope</span><span class="p">(</span><span class="n">telescope</span><span class="p">)</span></div>


<div class="viewcode-block" id="ThresholdVisWeightBaseline.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.ThresholdVisWeightBaseline.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">stream</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">BaselineMask</span> <span class="o">|</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealBaselineMask</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct baseline-dependent mask.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stream : `.core.container` with `weight` attribute</span>
<span class="sd">            Input container whose weights are used to construct the mask.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `BaselineMask` or `SiderealBaselineMask`</span>
<span class="sd">            The output baseline-dependent mask.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">mpi4py</span><span class="w"> </span><span class="kn">import</span> <span class="n">MPI</span>

        <span class="c1"># Only redistribute the weight dataset, because CorrData containers will have</span>
        <span class="c1"># other parallel datasets without a stack axis</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Make the output container, depending on input type</span>
        <span class="k">if</span> <span class="s2">&quot;ra&quot;</span> <span class="ow">in</span> <span class="n">stream</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
            <span class="n">mask_cont</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealBaselineMask</span><span class="p">(</span>
                <span class="n">axes_from</span><span class="o">=</span><span class="n">stream</span><span class="p">,</span> <span class="n">attrs_from</span><span class="o">=</span><span class="n">stream</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">stream</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
            <span class="n">mask_cont</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">BaselineMask</span><span class="p">(</span><span class="n">axes_from</span><span class="o">=</span><span class="n">stream</span><span class="p">,</span> <span class="n">attrs_from</span><span class="o">=</span><span class="n">stream</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Task requires TimeStream, SiderealStream, or CorrData. Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Redistribute output container along stack axis</span>
        <span class="n">mask_cont</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;stack&quot;</span><span class="p">)</span>

        <span class="c1"># Get local section of weights</span>
        <span class="n">local_weight</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="c1"># Reshape the weight array</span>
        <span class="n">average_weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">local_weight</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">local_weight</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="n">average_sel</span> <span class="o">=</span> <span class="n">average_weight</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_absolute_threshold</span>

        <span class="c1"># For each baseline (axis=1), take average over non-ignored time/freq samples</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">average_type</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
            <span class="n">average_weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">average_weight</span> <span class="o">*</span> <span class="n">average_sel</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">average_weight</span> <span class="o">*=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">average_sel</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">average_type</span> <span class="o">==</span> <span class="s2">&quot;median&quot;</span><span class="p">:</span>
            <span class="n">average_weight</span> <span class="o">=</span> <span class="n">median</span><span class="o">.</span><span class="n">weighted_median</span><span class="p">(</span>
                <span class="n">average_weight</span><span class="p">,</span> <span class="n">average_sel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Figure out which entries to keep</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">absolute_threshold</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_threshold</span> <span class="o">*</span> <span class="n">average_weight</span>
        <span class="p">)</span>

        <span class="c1"># Compute the mask, excluding samples that we want to ignore</span>
        <span class="n">local_mask</span> <span class="o">=</span> <span class="n">local_weight</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">local_mask</span> <span class="o">&amp;=</span> <span class="n">local_weight</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_absolute_threshold</span>

        <span class="c1"># If only flagging co-pol baselines, make separate mask to select those,</span>
        <span class="c1"># and multiply into low-weight mask</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pols_to_flag</span> <span class="o">==</span> <span class="s2">&quot;copol&quot;</span><span class="p">:</span>
            <span class="c1"># Get local section of stack axis</span>
            <span class="n">local_stack</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="n">stream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_bounds</span><span class="p">]</span>

            <span class="c1"># Get product map from input stream</span>
            <span class="n">prod</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">prod</span><span class="p">[:]</span>

            <span class="c1"># Get polarisation of each input for each element of local stack axis</span>
            <span class="n">pol_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">polarisation</span><span class="p">[</span><span class="n">prod</span><span class="p">[</span><span class="n">local_stack</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">]][</span><span class="s2">&quot;input_a&quot;</span><span class="p">]]</span>
            <span class="n">pol_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">polarisation</span><span class="p">[</span><span class="n">prod</span><span class="p">[</span><span class="n">local_stack</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">]][</span><span class="s2">&quot;input_b&quot;</span><span class="p">]]</span>

            <span class="c1"># Make mask to select co-pol baselines</span>
            <span class="n">local_pol_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">pol_a</span> <span class="o">==</span> <span class="n">pol_b</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

            <span class="c1"># Apply pol mask to low-weight mask</span>
            <span class="n">local_mask</span> <span class="o">*=</span> <span class="n">local_pol_mask</span>

        <span class="c1"># Compute the fraction of data that will be masked</span>
        <span class="n">local_mask_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">local_mask</span><span class="p">)</span>
        <span class="n">global_mask_total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">local_mask_sum</span><span class="p">)</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Allreduce</span><span class="p">(</span><span class="n">local_mask_sum</span><span class="p">,</span> <span class="n">global_mask_total</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">SUM</span><span class="p">)</span>
        <span class="n">mask_frac</span> <span class="o">=</span> <span class="n">global_mask_total</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">global_shape</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mf">100.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mask_frac</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2"> of data is below the weight threshold&quot;</span><span class="p">)</span>

        <span class="c1"># Save mask to output container</span>
        <span class="n">mask_cont</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">local_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Distribute back across frequency</span>
        <span class="n">mask_cont</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mask_cont</span></div>
</div>



<div class="viewcode-block" id="CollapseBaselineMask">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.CollapseBaselineMask">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CollapseBaselineMask</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Collapse a baseline-dependent mask along the baseline axis.</span>

<span class="sd">    The output is a frequency/time mask that is True for any freq/time sample</span>
<span class="sd">    for which any baseline is masked in the input mask.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="CollapseBaselineMask.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.CollapseBaselineMask.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">baseline_mask</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">BaselineMask</span> <span class="o">|</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealBaselineMask</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">RFIMask</span> <span class="o">|</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealRFIMask</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Collapse input mask over baseline axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        baseline_mask : `BaselineMask` or `SiderealBaselineMask`</span>
<span class="sd">            Input baseline-dependent mask</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask_cont : `RFIMask` or `SiderealRFIMask`</span>
<span class="sd">            Output baseline-independent mask.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Redistribute input mask along freq axis</span>
        <span class="n">baseline_mask</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Make container for output mask. Remember that this will not be distributed.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">baseline_mask</span><span class="p">,</span> <span class="n">containers</span><span class="o">.</span><span class="n">BaselineMask</span><span class="p">):</span>
            <span class="n">mask_cont</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">RFIMask</span><span class="p">(</span>
                <span class="n">axes_from</span><span class="o">=</span><span class="n">baseline_mask</span><span class="p">,</span> <span class="n">attrs_from</span><span class="o">=</span><span class="n">baseline_mask</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">baseline_mask</span><span class="p">,</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealBaselineMask</span><span class="p">):</span>
            <span class="n">mask_cont</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealRFIMask</span><span class="p">(</span>
                <span class="n">axes_from</span><span class="o">=</span><span class="n">baseline_mask</span><span class="p">,</span> <span class="n">attrs_from</span><span class="o">=</span><span class="n">baseline_mask</span>
            <span class="p">)</span>

        <span class="c1"># Get local section of baseline-dependent mask</span>
        <span class="n">local_mask</span> <span class="o">=</span> <span class="n">baseline_mask</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="c1"># Collapse along stack axis</span>
        <span class="n">local_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">local_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Gather full mask on each rank</span>
        <span class="n">full_mask</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">local_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">allgather</span><span class="p">()</span>

        <span class="c1"># Log the percent of freq/time samples masked</span>
        <span class="n">drop_frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">full_mask</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">full_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;After baseline collapse: </span><span class="si">{</span><span class="mf">100.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">drop_frac</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">%% of data&quot;</span>
            <span class="s2">&quot; is below the weight threshold&quot;</span>
        <span class="p">)</span>

        <span class="n">mask_cont</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">full_mask</span>

        <span class="k">return</span> <span class="n">mask_cont</span></div>
</div>



<div class="viewcode-block" id="RFIVisMask">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RFIVisMask">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RFIVisMask</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Identify and flag RFI in visibility data.</span>

<span class="sd">    This is a non-functional base class.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    stokes_i : bool</span>
<span class="sd">        If true, flag on stokes I visibilities. Otherwise, flag on</span>
<span class="sd">        all polarizations. Flagging on Stokes I can provide performance</span>
<span class="sd">        benefits, as the number of baselines is reduced by a factor</span>
<span class="sd">        of 4.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">stokes_i</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="RFIVisMask.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RFIVisMask.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">telescope</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set up the baseline selections and ordering.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        telescope : TransitTelescope</span>
<span class="sd">            The telescope object to use</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">get_telescope</span><span class="p">(</span><span class="n">telescope</span><span class="p">)</span></div>


    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">TimeStream</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">RFIMask</span><span class="p">:</span> <span class="o">...</span>
    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealStream</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealRFIMask</span><span class="p">:</span> <span class="o">...</span>
<div class="viewcode-block" id="RFIVisMask.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RFIVisMask.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make a mask from the data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stream</span>
<span class="sd">            Data to use when masking. Axes should be frequency, stack,</span>
<span class="sd">            and time-like.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask</span>
<span class="sd">            Time-frequency mask, where values marked `True` are flagged.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Get the sample times and create output container</span>
        <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">stream</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">time</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">RFIMask</span><span class="p">(</span><span class="n">axes_from</span><span class="o">=</span><span class="n">stream</span><span class="p">,</span> <span class="n">attrs_from</span><span class="o">=</span><span class="n">stream</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;ra&quot;</span> <span class="ow">in</span> <span class="n">stream</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
            <span class="c1"># Convert ra to unix time</span>
            <span class="n">csd</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lsd&quot;</span><span class="p">,</span> <span class="n">stream</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;csd&quot;</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">csd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Dataset does not have a `csd` or `lsd` attribute.&quot;</span><span class="p">)</span>

            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">lsd_to_unix</span><span class="p">(</span><span class="n">csd</span> <span class="o">+</span> <span class="n">stream</span><span class="o">.</span><span class="n">ra</span> <span class="o">/</span> <span class="mf">360.0</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealRFIMask</span><span class="p">(</span><span class="n">axes_from</span><span class="o">=</span><span class="n">stream</span><span class="p">,</span> <span class="n">attrs_from</span><span class="o">=</span><span class="n">stream</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expected data with `time` or `ra` axis. Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="n">freq</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="n">stream</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_bounds</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stokes_i</span><span class="p">:</span>
            <span class="c1"># Get stokes I visibilities, weights, and baselines</span>
            <span class="n">vis</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">baselines</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">stokes_I</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use the distributed arrays</span>
            <span class="n">vis</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span>
            <span class="n">baselines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">baselines</span>

        <span class="c1"># Set up the initial mask, reducing over baselines</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">weight</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">mask</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:]</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_static_rfi_mask_hook</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mf">100.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mask</span><span class="o">.</span><span class="n">allgather</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">% of data initially flagged.&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Create a time-frequency mask</span>
        <span class="n">out</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_mask</span><span class="p">(</span><span class="n">vis</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">baselines</span><span class="p">,</span> <span class="n">times</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mf">100.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">% of data flagged.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="RFIVisMask.generate_mask">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RFIVisMask.generate_mask">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">generate_mask</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">vis</span><span class="p">:</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="p">,</span>
        <span class="n">weight</span><span class="p">:</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="p">,</span>
        <span class="n">mask</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">],</span>
        <span class="n">freq</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">],</span>
        <span class="n">baselines</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">],</span>
        <span class="n">times</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a time-frequency mask.</span>

<span class="sd">        This method should always return the mask for _all_ frequencies.</span>

<span class="sd">        Not implemented in the base class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vis</span>
<span class="sd">            Complex visibility data. Shape is (nfreq, nstack, ntimes).</span>
<span class="sd">        weight</span>
<span class="sd">            Weights for the visibility data. Shape is (nfreq, nstack, ntimes).</span>
<span class="sd">        mask</span>
<span class="sd">            Initial mask. Shape is (nfreq, ntimes).</span>
<span class="sd">        freq</span>
<span class="sd">            1D array of frequencies in the data (in MHz).</span>
<span class="sd">        baselines</span>
<span class="sd">            2D array of baseline vectors in meters. Shape is (nstack, 2)</span>
<span class="sd">        times</span>
<span class="sd">            1D array of unix timestamps.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask</span>
<span class="sd">            Time-frequency mask. Shape is (nfreq, ntimes). True will mask</span>
<span class="sd">            a time-frequency sample.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_static_rfi_mask_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">timestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Override to mask entire frequency channels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq : np.ndarray[nfreq]</span>
<span class="sd">            1D array of frequencies in the data (in MHz).</span>

<span class="sd">        timestamp : np.array[float]</span>
<span class="sd">            Start observing time (in unix time)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask : np.ndarray[nfreq]</span>
<span class="sd">            Mask array. True will mask a frequency channel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span></div>



<div class="viewcode-block" id="RFITransientVisMask">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RFITransientVisMask">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RFITransientVisMask</span><span class="p">(</span><span class="n">RFIVisMask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Identify and flag transient RFI in visibility data.</span>

<span class="sd">    Each frequency is processed individually. A high-pass filter is applied</span>
<span class="sd">    in RA to isolate transient RFI. The high-pass filtered visibilities are</span>
<span class="sd">    beamformed, and a MAD filter is applied to the resulting map. A</span>
<span class="sd">    time/RA sample is then flagged if some fraction of beams exceed the</span>
<span class="sd">    MAD threshold for that sample.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    mad_base_size</span>
<span class="sd">        Median absolute deviations base window. Default is [1, 101].</span>
<span class="sd">    mad_dev_size</span>
<span class="sd">        Median absolute deviation median deviation window.</span>
<span class="sd">        Default is [1, 51].</span>
<span class="sd">    sigma_high</span>
<span class="sd">        Median absolute deviations sigma threshold. Default is 8.0.</span>
<span class="sd">    sigma_low</span>
<span class="sd">        Median absolute deviations low sigma threshold. A value above</span>
<span class="sd">        this threshold is masked only if it is either larger than `sigma_high`</span>
<span class="sd">        or it is larger than `sigma_low` AND connected to a region larger</span>
<span class="sd">        than `sigma_high`. Default is 2.0.</span>
<span class="sd">    frac_samples</span>
<span class="sd">        Fraction of flagged samples in map space above which the entire</span>
<span class="sd">        time sample will be flagged. Default is 0.01.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mad_base_size</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">list_type</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">101</span><span class="p">])</span>
    <span class="n">mad_dev_size</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">list_type</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">51</span><span class="p">])</span>
    <span class="n">sigma_high</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">8.0</span><span class="p">)</span>
    <span class="n">sigma_low</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
    <span class="n">frac_samples</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>

<div class="viewcode-block" id="RFITransientVisMask.generate_mask">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RFITransientVisMask.generate_mask">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">generate_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">baselines</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mask scattered transient RFI.&quot;&quot;&quot;</span>
        <span class="c1"># Convert times to ra in radians</span>
        <span class="n">ra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">unix_to_lsa</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">period</span><span class="o">=</span><span class="mf">360.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span>

        <span class="c1"># Get the per-frequency high-pass and low-pass cuts</span>
        <span class="n">dec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span>
        <span class="n">lambda_inv</span> <span class="o">=</span> <span class="n">freq</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">*</span> <span class="mf">1e6</span> <span class="o">/</span> <span class="n">constants</span><span class="o">.</span><span class="n">c</span>
        <span class="n">hpf_cut</span> <span class="o">=</span> <span class="n">lambda_inv</span> <span class="o">*</span> <span class="n">baselines</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dec</span><span class="p">)</span>

        <span class="c1"># Create the output mask and apply the initial mask</span>
        <span class="n">finalmask</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">vis</span><span class="o">.</span><span class="n">global_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">finalmask</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="c1"># Dereference the distributed array</span>
        <span class="n">fl</span> <span class="o">=</span> <span class="n">finalmask</span><span class="o">.</span><span class="n">local_array</span>

        <span class="c1"># Iterate over frequencies</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fl</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1"># Skip if frequency is already masked</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">ii</span><span class="p">]):</span>
                <span class="k">continue</span>

            <span class="c1"># high-pass filter</span>
            <span class="n">vhpf</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">highpass_weighted_convolution_filter</span><span class="p">(</span>
                <span class="n">vis</span><span class="o">.</span><span class="n">local_array</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                <span class="n">weight</span><span class="o">.</span><span class="n">local_array</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span>
                <span class="n">ra</span><span class="p">,</span>
                <span class="n">hpf_cut</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">vfft</span> <span class="o">=</span> <span class="n">cfft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">vhpf</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">vfft</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">vfft</span><span class="p">)</span>
            <span class="c1"># Compute median absolute deviations of the filtered map</span>
            <span class="n">mad_</span> <span class="o">=</span> <span class="n">mad</span><span class="p">(</span><span class="n">vfft</span><span class="p">,</span> <span class="n">fl</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mad_base_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mad_dev_size</span><span class="p">)</span>
            <span class="c1"># Hysteresis threshold mask flags anything above `sigma_high` or</span>
            <span class="c1"># anything above `sigma_low` ONLY if it is connected to a region</span>
            <span class="c1"># above `sigma_high`</span>
            <span class="n">fl</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">|=</span> <span class="n">apply_hysteresis_threshold</span><span class="p">(</span><span class="n">mad_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_low</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_high</span><span class="p">)</span>

        <span class="c1"># Apply scale-invariant rank operator. At this stage, the mask typically</span>
        <span class="c1"># won&#39;t have regions which are wide in _both_ time and frequency, so this</span>
        <span class="c1"># should have a fairly minimal effect on the total flagging. Avoid extending</span>
        <span class="c1"># anything that was originally masked.</span>
        <span class="n">finalmask</span> <span class="o">=</span> <span class="n">finalmask</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">finalmask</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:]</span> <span class="o">|=</span> <span class="n">rfi</span><span class="o">.</span><span class="n">scale_invariant_rank</span><span class="p">(</span>
            <span class="n">finalmask</span><span class="o">.</span><span class="n">local_array</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="o">.</span><span class="n">allgather</span><span class="p">()[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
            <span class="n">eta</span><span class="o">=</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">),</span>
            <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">finalmask</span> <span class="o">=</span> <span class="n">finalmask</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Collapse over beams and return the time-frequency mask</span>
        <span class="k">return</span> <span class="n">finalmask</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">allgather</span><span class="p">()</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">frac_samples</span></div>
</div>



<div class="viewcode-block" id="RFIInverseRedundancyChisqFreqMask">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RFIInverseRedundancyChisqFreqMask">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RFIInverseRedundancyChisqFreqMask</span><span class="p">(</span><span class="n">RFIVisMask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Identify and flag time-constant RFI in visibilities.</span>

<span class="sd">    Apply a median absolute deviation (MAD) filter to the median</span>
<span class="sd">    in time of a chi-squared metric, followed by a high-sensitivity</span>
<span class="sd">    MAD filter on the ratio of the visibilities to a smoothed</span>
<span class="sd">    background.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    nsigma</span>
<span class="sd">        Starting threshold for the MAD algorithm, given in number of standard</span>
<span class="sd">        deviations. The threshold is reduced each iteration. Default is 10.0.</span>
<span class="sd">    winsize : tuple, optional</span>
<span class="sd">        Size of the median filter window to estimate the smooth background for</span>
<span class="sd">        the final low-sensitivity 2D flagging. Default is (15, 11).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nsigma</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">15.0</span><span class="p">)</span>
    <span class="n">winsize</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>

<div class="viewcode-block" id="RFIInverseRedundancyChisqFreqMask.generate_mask">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RFIInverseRedundancyChisqFreqMask.generate_mask">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">generate_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">baselines</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mask narrowband RFI.&quot;&quot;&quot;</span>
        <span class="c1"># We need all frequencies, so redistribute to the length-one</span>
        <span class="c1"># reduced baseline axis and gather</span>
        <span class="n">vis</span> <span class="o">=</span> <span class="n">vis</span><span class="o">.</span><span class="n">real</span><span class="o">.</span><span class="n">allgather</span><span class="p">()[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">weight</span><span class="o">.</span><span class="n">allgather</span><span class="p">()[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">allgather</span><span class="p">()</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_masked_median_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">winsize</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="c1"># Median function that ignores masked values, operating</span>
            <span class="c1"># on the magnitude of complex values</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">winsize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Move the window size to the correct axis</span>
                    <span class="n">winsize</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">winsize</span><span class="p">)</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">winsize</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
                    <span class="n">winsize</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                    <span class="n">winsize</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">winsize</span><span class="p">)</span>

            <span class="c1"># `weighted_median` requires c-contiguous float64 input</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">winsize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Apply a moving median filter to the weights</span>
                <span class="n">med</span> <span class="o">=</span> <span class="n">median</span><span class="o">.</span><span class="n">moving_weighted_median</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">winsize</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">med</span> <span class="o">=</span> <span class="n">median</span><span class="o">.</span><span class="n">weighted_median</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">and</span> <span class="p">(</span><span class="n">winsize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">med</span> <span class="o">=</span> <span class="n">med</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">med</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">med</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="k">return</span> <span class="n">med</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_mad1d</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Subtract a smooth baseline using IarPLS</span>
            <span class="n">baseline</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">IarPLS_1d</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mf">5e1</span><span class="p">)</span>
            <span class="c1"># Re-use the spectrum array to store the absolute deviations</span>
            <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">spectrum</span> <span class="o">-</span> <span class="n">baseline</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">spectrum</span><span class="p">)</span>
            <span class="n">med</span> <span class="o">=</span> <span class="mf">1.4826</span> <span class="o">*</span> <span class="n">_masked_median_func</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">spectrum</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">med</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_mask1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">thresh_low</span><span class="p">,</span> <span class="n">thresh_high</span><span class="p">):</span>
            <span class="n">spectrum</span> <span class="o">=</span> <span class="n">_masked_median_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">mi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Convert to median absolute deviations</span>
            <span class="n">m1d</span> <span class="o">=</span> <span class="n">_mad1d</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">apply_hysteresis_threshold</span><span class="p">(</span><span class="n">m1d</span><span class="p">,</span> <span class="n">thresh_low</span><span class="p">,</span> <span class="n">thresh_high</span><span class="p">)</span>

        <span class="c1"># Use only nighttime data</span>
        <span class="n">tslc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_day_flag_hook</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>

        <span class="n">vi</span> <span class="o">=</span> <span class="n">vis</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">tslc</span><span class="p">]</span>
        <span class="n">mi</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">tslc</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Apply the base 1D flagging</span>
        <span class="n">mi</span> <span class="o">|=</span> <span class="n">_mask1d</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsigma</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsigma</span><span class="p">)</span>

        <span class="c1"># Divide out a smooth background and do a higher sensitivity flagging</span>
        <span class="n">bg</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">medfilt</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">winsize</span><span class="p">)</span> <span class="o">*</span> <span class="o">~</span><span class="n">mi</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="n">vi</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">bg</span><span class="p">)</span>

        <span class="n">mi</span> <span class="o">|=</span> <span class="n">_mask1d</span><span class="p">(</span><span class="n">ratio</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsigma</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsigma</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Apply the 1D frequency mask to all times</span>
        <span class="n">mask</span> <span class="o">|=</span> <span class="p">(</span><span class="n">mi</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">tslc</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mask</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_day_flag_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Override to mask daytime.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        times : np.ndarray[ntime]</span>
<span class="sd">            Array of timestamps.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask : np.ndarray[ntime]</span>
<span class="sd">            Mask array. True will mask out a time sample.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">times</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span></div>



<div class="viewcode-block" id="RFIStaticVisMask">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RFIStaticVisMask">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RFIStaticVisMask</span><span class="p">(</span>
    <span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">group_tasks</span><span class="p">(</span>
        <span class="n">MaskBaselines</span><span class="p">,</span>
        <span class="n">transform</span><span class="o">.</span><span class="n">ReduceChisqInverseRedundancy</span><span class="p">,</span>
        <span class="n">RFIInverseRedundancyChisqFreqMask</span><span class="p">,</span>
    <span class="p">)</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Group of tasks to identify and flag narrowband RFI in the visibilities.</span>

<span class="sd">    This task runs a series of tasks to identify and flag narrowband RFI</span>
<span class="sd">    in visibility data. The tasks are:</span>

<span class="sd">    1. `MaskBaselines`: Mask short baselines that are sensitive to diffuse</span>
<span class="sd">       emission from the sky.</span>
<span class="sd">    2. `ReduceChisqInverseRedundancy`: Compute a chi-squared test statistic</span>
<span class="sd">       using inverse-redundancy weighting.</span>
<span class="sd">    3. `RFIInverseRedundancyChisqMask`: Identify and flag (mostly) static RFI</span>
<span class="sd">       in the visibilities using the inverse-redundancy chi-squared metric.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Properties for MaskBaselines</span>
    <span class="n">mask_short</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span>
    <span class="n">mask_pol</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;XX&quot;</span><span class="p">,</span> <span class="s2">&quot;YY&quot;</span><span class="p">])</span>
    <span class="n">share</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">enum</span><span class="p">([</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;vis&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;vis&quot;</span><span class="p">)</span>
    <span class="c1"># Properties for ReduceChisqInverseRedundancy</span>
    <span class="n">dataset</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;vis&quot;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">])</span>
    <span class="c1"># Properties for RFIVisMask</span>
    <span class="n">stokes_i</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>



<div class="viewcode-block" id="RFIMaskChisqHighDelay">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RFIMaskChisqHighDelay">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RFIMaskChisqHighDelay</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mask frequencies and times with anomalous chi-squared test statistic.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    flag_ew : array</span>
<span class="sd">        If the input container has an east-west baseline axis, then this</span>
<span class="sd">        flag will be applied to the weights before collapsing over that axis.</span>
<span class="sd">    reg_arpls : float</span>
<span class="sd">        Smoothness regularisation used when estimating the baseline</span>
<span class="sd">        for flagging bad frequencies. Default is 1e5.</span>
<span class="sd">    nsigma_1d : float</span>
<span class="sd">        Mask any frequency where the median over unmasked time samples</span>
<span class="sd">        deviates from the baseline by more than this number of</span>
<span class="sd">        median absolute deviations.  Default is 5.0.</span>
<span class="sd">    win_t : float</span>
<span class="sd">        Size of the window (in number of time samples)</span>
<span class="sd">        used to compute a median filtered version of the test statistic.</span>
<span class="sd">    win_f : float</span>
<span class="sd">        Size of the window (in number of frequency channels)</span>
<span class="sd">        used to compute a median filtered version of the test statistic.</span>
<span class="sd">    nsigma_2d: float</span>
<span class="sd">        Mask any frequency and time where the absolute deviation</span>
<span class="sd">        from the median filtered version is greater than this number</span>
<span class="sd">        of expected standard deviations given the number of degrees</span>
<span class="sd">        of freedom (i.e., number of baselines).</span>
<span class="sd">    estimate_var : bool</span>
<span class="sd">        Estimate the variance in the test statistic using the median</span>
<span class="sd">        absolute deviation over a region defined by the win_t and</span>
<span class="sd">        win_f parameters.</span>
<span class="sd">    only_positive : bool</span>
<span class="sd">        Only mask large postive excursions in the test statistic,</span>
<span class="sd">        leaving large negative excursions unmasked.</span>
<span class="sd">    separate_pol : bool</span>
<span class="sd">        If true, construct a mask for each pol separately.  If false, sum the</span>
<span class="sd">        chi-squared values over all polarisations and construct a single mask.</span>
<span class="sd">    mask_type : {&quot;mad&quot;|&quot;sumthreshold&quot;}</span>
<span class="sd">        Algorithm to use to generate the mask.</span>
<span class="sd">    niter : int, optional</span>
<span class="sd">        Number of iterations.  At each iterations the baseline and standard</span>
<span class="sd">        deviation are re-estimated using the mask from the previous iteration.</span>
<span class="sd">    rho : float, optional</span>
<span class="sd">        Reduce the threshold by this factor at each iteration.  A value of 1</span>
<span class="sd">        will keep the threshold constant for all iterations.</span>
<span class="sd">    max_m : int, optional</span>
<span class="sd">        Maximum size of the SumThreshold window to use.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">flag_ew</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>

    <span class="n">reg_arpls</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1e5</span><span class="p">)</span>
    <span class="n">nsigma_1d</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span>

    <span class="n">win_t</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">601</span><span class="p">)</span>
    <span class="n">win_f</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">nsigma_2d</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span>
    <span class="n">estimate_var</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">only_positive</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">separate_pol</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">mask_type</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">enum</span><span class="p">([</span><span class="s2">&quot;mad&quot;</span><span class="p">,</span> <span class="s2">&quot;sumthreshold&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;mad&quot;</span><span class="p">)</span>
    <span class="n">niter</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
    <span class="n">max_m</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">32</span><span class="p">)</span>

<div class="viewcode-block" id="RFIMaskChisqHighDelay.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RFIMaskChisqHighDelay.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">telescope</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save telescope object for time calculations.</span>

<span class="sd">        Only used to convert (LSD, RA) to unix time when masking</span>
<span class="sd">        sidereal streams.  Not required when masking time streams.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        telescope : TransitTelescope</span>
<span class="sd">            Telescope object used for time calculations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">telescope</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">io</span><span class="o">.</span><span class="n">get_telescope</span><span class="p">(</span><span class="n">telescope</span><span class="p">)</span>

        <span class="c1"># Set thresholds for sum-threshold algorithm</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_type</span> <span class="o">==</span> <span class="s2">&quot;sumthreshold&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsigma_2d</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niter</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="RFIMaskChisqHighDelay.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RFIMaskChisqHighDelay.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a mask from the data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stream : dcontainers.TimeStream | dcontainers.SiderealStream |</span>
<span class="sd">                 dcontainers.HybridVisStream | dcontainers.RingMap</span>
<span class="sd">            Container holding a chi-squared test statistic in the visibility dataset.</span>
<span class="sd">            A weighted average will be taken over any axis that is not time/ra or frequency.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask : dcontainers.RFIMask | dcontainers.SiderealRFIMask |</span>
<span class="sd">               dcontainers.RFIMaskByPol | dcontainers.SiderealRFIMaskByPol</span>
<span class="sd">            Time-frequency mask, where values marked `True` are flagged.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Distribute over frequency</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">freq</span>

        <span class="c1"># Determine time axis</span>
        <span class="n">multiple_days</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="s2">&quot;ra&quot;</span> <span class="ow">in</span> <span class="n">stream</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;For sidereal streams, must provide telescope object during setup.&quot;</span>
                <span class="p">)</span>

            <span class="n">csd</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lsd&quot;</span><span class="p">,</span> <span class="n">stream</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;csd&quot;</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">csd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data does not have a `csd` or `lsd` attribute.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">csd</span><span class="p">):</span>
                <span class="n">csd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">csd</span><span class="p">))</span>
                <span class="n">multiple_days</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="n">timestamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">lsd_to_unix</span><span class="p">(</span><span class="n">csd</span> <span class="o">+</span> <span class="n">stream</span><span class="o">.</span><span class="n">ra</span> <span class="o">/</span> <span class="mf">360.0</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">time</span>

        <span class="c1"># Expand the weight dataset so that it can broadcast against the data dataset.</span>
        <span class="c1"># Assumes that weight contains a subset of the axes in data, with the shared</span>
        <span class="c1"># axes in the same order.  This is true for all of the supported input</span>
        <span class="c1"># containers listed in the docstring.</span>
        <span class="n">dax</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span>
        <span class="n">wax</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span>
        <span class="n">wshp</span> <span class="o">=</span> <span class="p">[</span><span class="n">stream</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">wax</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ax</span><span class="p">)]</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">wax</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">dax</span><span class="p">]</span>
        <span class="n">wshp</span><span class="p">[</span><span class="n">dax</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Extract the shape of the axes that are missing from the weights dataset,</span>
        <span class="c1"># so that we can scale the denominator by this factor.</span>
        <span class="n">wshp_missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">sz</span> <span class="k">for</span> <span class="n">sz</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dax</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">wax</span><span class="p">]</span>
        <span class="n">wfactor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">wshp_missing</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wshp_missing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">1.0</span>

        <span class="c1"># Sum over any axis that is neither time nor frequency</span>
        <span class="n">keep_axis</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;ra&quot;</span><span class="p">]</span>

        <span class="n">separate_pol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">separate_pol</span> <span class="ow">and</span> <span class="s2">&quot;pol&quot;</span> <span class="ow">in</span> <span class="n">dax</span>
        <span class="k">if</span> <span class="n">separate_pol</span><span class="p">:</span>
            <span class="n">keep_axis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;pol&quot;</span><span class="p">)</span>

        <span class="n">axsum</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">ii</span> <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dax</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keep_axis</span><span class="p">])</span>

        <span class="n">chisq</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span><span class="o">.</span><span class="n">real</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">wshp</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag_ew</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s2">&quot;ew&quot;</span> <span class="ow">in</span> <span class="n">dax</span><span class="p">:</span>
            <span class="n">ew_slc</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="o">==</span> <span class="s2">&quot;ew&quot;</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">dax</span><span class="p">])</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">weight</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag_ew</span><span class="p">[</span><span class="n">ew_slc</span><span class="p">]</span>

        <span class="n">wsum</span> <span class="o">=</span> <span class="n">wfactor</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axsum</span><span class="p">)</span>
        <span class="n">chisq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight</span> <span class="o">*</span> <span class="n">chisq</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axsum</span><span class="p">)</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">wsum</span><span class="p">)</span>

        <span class="c1"># Gather all frequencies on all nodes</span>
        <span class="n">chisq</span> <span class="o">=</span> <span class="n">chisq</span><span class="o">.</span><span class="n">allgather</span><span class="p">()</span>
        <span class="n">wsum</span> <span class="o">=</span> <span class="n">wsum</span><span class="o">.</span><span class="n">allgather</span><span class="p">()</span>

        <span class="n">mask_input</span> <span class="o">=</span> <span class="n">wsum</span> <span class="o">==</span> <span class="mf">0.0</span>

        <span class="c1"># Determine what time samples should be ignored when constructing the mask</span>
        <span class="k">if</span> <span class="n">multiple_days</span><span class="p">:</span>
            <span class="n">mask_daytime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">timestamp</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask_daytime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_day_flag_hook</span><span class="p">(</span><span class="n">timestamp</span><span class="p">)</span>

        <span class="n">mask_sources</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_flag_hook</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>

        <span class="c1"># Create output container</span>
        <span class="k">if</span> <span class="n">separate_pol</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;ra&quot;</span> <span class="ow">in</span> <span class="n">stream</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
                <span class="n">OutputContainer</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealRFIMaskByPol</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">OutputContainer</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">RFIMaskByPol</span>
        <span class="k">elif</span> <span class="s2">&quot;ra&quot;</span> <span class="ow">in</span> <span class="n">stream</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
            <span class="n">OutputContainer</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealRFIMask</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">OutputContainer</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">RFIMask</span>

        <span class="n">output</span> <span class="o">=</span> <span class="n">OutputContainer</span><span class="p">(</span><span class="n">axes_from</span><span class="o">=</span><span class="n">stream</span><span class="p">,</span> <span class="n">attrs_from</span><span class="o">=</span><span class="n">stream</span><span class="p">)</span>
        <span class="n">output</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># If requested, construct a mask for each polarisation separately</span>
        <span class="n">pol_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">pol</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">if</span> <span class="n">separate_pol</span> <span class="k">else</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">pslc</span> <span class="ow">in</span> <span class="n">pol_slice</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask_input</span><span class="p">[</span><span class="n">pslc</span><span class="p">]</span> <span class="o">|</span> <span class="n">mask_sources</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsigma_1d</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">mask_1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_1d</span><span class="p">(</span><span class="n">chisq</span><span class="p">[</span><span class="n">pslc</span><span class="p">],</span> <span class="n">mask</span> <span class="o">|</span> <span class="n">mask_daytime</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="n">mask</span> <span class="o">|=</span> <span class="n">mask_1d</span>
                <span class="n">output</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">pslc</span><span class="p">]</span> <span class="o">|=</span> <span class="n">mask_1d</span>

            <span class="c1"># Mask using dynamic spectrum</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsigma_2d</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="c1"># The inverse variance of the chisq per dof test statistic is ndof / 2.</span>
                <span class="c1"># This expression assumes ndof is stored in the weight dataset.</span>
                <span class="n">w</span> <span class="o">=</span> <span class="o">~</span><span class="n">mask</span> <span class="o">*</span> <span class="n">wsum</span><span class="p">[</span><span class="n">pslc</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_type</span> <span class="o">==</span> <span class="s2">&quot;mad&quot;</span><span class="p">:</span>
                    <span class="n">mask_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_2d</span><span class="p">(</span><span class="n">chisq</span><span class="p">[</span><span class="n">pslc</span><span class="p">],</span> <span class="n">w</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mask_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_2d_sumthreshold</span><span class="p">(</span><span class="n">chisq</span><span class="p">[</span><span class="n">pslc</span><span class="p">],</span> <span class="n">w</span><span class="p">)</span>

                <span class="n">output</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">pslc</span><span class="p">]</span> <span class="o">|=</span> <span class="n">mask_2d</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask_daytime</span>

        <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="RFIMaskChisqHighDelay.mask_1d">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RFIMaskChisqHighDelay.mask_1d">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mask_1d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mask frequency channels where median chi-squared deviates from neighbors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : np.ndarray[nfreq, ntime]</span>
<span class="sd">            Chi-squared per degree of freedom.</span>
<span class="sd">        m : np.ndarray[nfreq, ntime]</span>
<span class="sd">            Boolean mask that indicates which samples to ignore</span>
<span class="sd">            when calculating the median over time.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask : np.ndarray[nfreq]</span>
<span class="sd">            Boolean mask that indicates frequency channels where</span>
<span class="sd">            the median chi-squared over time deviates significantly</span>
<span class="sd">            from that of the neighboring channels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For each frequency, caculate a weighted median</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">((</span><span class="o">~</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>

        <span class="n">med_y</span> <span class="o">=</span> <span class="n">median</span><span class="o">.</span><span class="n">weighted_median</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">med_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">med_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">((</span><span class="o">~</span><span class="n">med_m</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>

        <span class="c1"># Estimate a baseline</span>
        <span class="n">baseline</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">arPLS_1d</span><span class="p">(</span><span class="n">med_y</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">med_m</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reg_arpls</span><span class="p">)</span>

        <span class="c1"># Subtract the baseline and estimate the noise</span>
        <span class="n">abs_dev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">med_m</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">med_y</span> <span class="o">-</span> <span class="n">baseline</span><span class="p">))</span>

        <span class="n">mad</span> <span class="o">=</span> <span class="mf">1.48625</span> <span class="o">*</span> <span class="n">median</span><span class="o">.</span><span class="n">weighted_median</span><span class="p">(</span><span class="n">abs_dev</span><span class="p">,</span> <span class="n">med_w</span><span class="p">)</span>

        <span class="c1"># Flag outliers</span>
        <span class="k">return</span> <span class="n">abs_dev</span> <span class="o">&gt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsigma_1d</span> <span class="o">*</span> <span class="n">mad</span><span class="p">)</span></div>


<div class="viewcode-block" id="RFIMaskChisqHighDelay.mask_2d">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RFIMaskChisqHighDelay.mask_2d">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mask_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mask frequencies and times where the chi-squared deviates from local median.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : np.ndarray[nfreq, ntime]</span>
<span class="sd">            Chi-squared per degree of freedom.</span>
<span class="sd">        w : np.ndarray[nfreq, ntime]</span>
<span class="sd">            Inverse variance of the chi-squared per degree of freedom,</span>
<span class="sd">            with zero indicating previously masked samples.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask : np.ndarray[nfreq]</span>
<span class="sd">            Boolean mask that indicates frequencies and times where</span>
<span class="sd">            chi-squared deviates significantly from the local median.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For each frequency, caculate a moving weighted median</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
        <span class="n">win_size</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">win_f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">win_t</span><span class="p">)</span>

        <span class="n">med_y</span> <span class="o">=</span> <span class="n">median</span><span class="o">.</span><span class="n">moving_weighted_median</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">win_size</span><span class="p">)</span>

        <span class="c1"># Calculate the deviation from the median, normalized by the</span>
        <span class="c1"># expected standard deviation</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">med_y</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>

        <span class="c1"># If requested, estimate the variance in the test statistic</span>
        <span class="c1"># using the median absolute deviation.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_var</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">((</span><span class="n">w</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
            <span class="n">mad_y</span> <span class="o">=</span> <span class="mf">1.48625</span> <span class="o">*</span> <span class="n">median</span><span class="o">.</span><span class="n">moving_weighted_median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dy</span><span class="p">),</span> <span class="n">f</span><span class="p">,</span> <span class="n">win_size</span><span class="p">)</span>
            <span class="n">dy</span> <span class="o">*=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">mad_y</span><span class="p">)</span>

        <span class="c1"># Take the absolute value of the relative excursion unless</span>
        <span class="c1"># explicitely requested to only flag positive excursions.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">only_positive</span><span class="p">:</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span>

        <span class="c1"># Flag times and frequencies that deviate by more than some threshold</span>
        <span class="k">return</span> <span class="n">dy</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsigma_2d</span></div>


<div class="viewcode-block" id="RFIMaskChisqHighDelay.mask_2d_sumthreshold">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RFIMaskChisqHighDelay.mask_2d_sumthreshold">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mask_2d_sumthreshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterative application of sumthreshold algorithm to mask large chi-squared.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : np.ndarray[nfreq, ntime]</span>
<span class="sd">            Chi-squared per degree of freedom.</span>
<span class="sd">        w : np.ndarray[nfreq, ntime]</span>
<span class="sd">            Inverse variance of the chi-squared per degree of freedom,</span>
<span class="sd">            with zero indicating previously masked samples.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask : np.ndarray[nfreq]</span>
<span class="sd">            Boolean mask that indicates frequencies and times where</span>
<span class="sd">            chi-squared deviates significantly from the local median.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="n">win_size</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">win_f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">win_t</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_var</span><span class="p">:</span>
            <span class="n">mad_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="c1"># Slowly reduce the threshold.  At each iteration generate a new estimate</span>
        <span class="c1"># of the background sky and the variance using the current mask.</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">w</span> <span class="o">==</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">nsigma</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="c1"># Calculate the local median</span>
            <span class="n">med_y</span> <span class="o">=</span> <span class="n">median</span><span class="o">.</span><span class="n">moving_weighted_median</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">win_size</span><span class="p">)</span>

            <span class="c1"># Calculate the deviation from the median, normalized by the</span>
            <span class="c1"># expected standard deviation</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">med_y</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>

            <span class="c1"># If requested, estimate the variance in the test statistic</span>
            <span class="c1"># using the median absolute deviation.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_var</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">f</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="n">mad_y</span> <span class="o">=</span> <span class="mf">1.48625</span> <span class="o">*</span> <span class="n">median</span><span class="o">.</span><span class="n">moving_weighted_median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dy</span><span class="p">),</span> <span class="n">f</span><span class="p">,</span> <span class="n">win_size</span><span class="p">)</span>

            <span class="c1"># Generate a mask using sumthreshold</span>
            <span class="n">stmask</span> <span class="o">=</span> <span class="n">rfi</span><span class="o">.</span><span class="n">sumthreshold</span><span class="p">(</span>
                <span class="n">dy</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_m</span><span class="p">,</span>
                <span class="n">start_flag</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
                <span class="n">threshold1</span><span class="o">=</span><span class="n">nsigma</span><span class="p">,</span>
                <span class="n">remove_median</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">correct_for_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">rho</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                <span class="n">variance</span><span class="o">=</span><span class="n">mad_y</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                <span class="n">only_positive</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">only_positive</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Update the current mask</span>
            <span class="n">mask</span> <span class="o">|=</span> <span class="n">stmask</span>

        <span class="c1"># Return the mask</span>
        <span class="k">return</span> <span class="n">mask</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_source_flag_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">freq</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Override to mask bright point sources.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        times : np.ndarray[ntime]</span>
<span class="sd">            Array of timestamps.</span>
<span class="sd">        freq : np.ndarray[nfreq]</span>
<span class="sd">            Array of frequencies.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask : np.ndarray[nfreq, ntime]</span>
<span class="sd">            Mask array. True will mask out a time sample.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">freq</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">times</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_day_flag_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Override to mask daytime.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        times : np.ndarray[ntime]</span>
<span class="sd">            Array of timestamps.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask : np.ndarray[nfreq, ntime]</span>
<span class="sd">            Mask array. True will mask out a time sample.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">times</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span></div>



<div class="viewcode-block" id="RFISensitivityMask">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RFISensitivityMask">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RFISensitivityMask</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Identify RFI as deviations in system sensitivity from expected radiometer noise.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    mask_type : string, optional</span>
<span class="sd">        One of &#39;mad&#39;, &#39;sumthreshold&#39; or &#39;combine&#39;.</span>
<span class="sd">        Default is combine, which uses the sumthreshold everywhere</span>
<span class="sd">        except around the transits of the sun and bright point sources,</span>
<span class="sd">        where it applies the MAD mask to avoid masking out the transits.</span>
<span class="sd">    include_pol : list of strings, optional</span>
<span class="sd">        The list of polarisations to include. Default is to use all</span>
<span class="sd">        polarisations.</span>
<span class="sd">    nsigma_1d : float, optional</span>
<span class="sd">        Construct a static mask by identifying any frequency channel</span>
<span class="sd">        whose quantile over time deviates from the median over frequency</span>
<span class="sd">        by more than this number of median absolute deviations.</span>
<span class="sd">        Default: 5.0</span>
<span class="sd">    quantile_1d: float, optional</span>
<span class="sd">        The quantile to use along time to construct the static mask.</span>
<span class="sd">        Default: 0.15</span>
<span class="sd">    win_f_1d : int, optional</span>
<span class="sd">        Number of frequency channels used to calculate a rolling median</span>
<span class="sd">        and median absolute deviation for the staic mask.  Default: 191</span>
<span class="sd">    nsigma : float, optional</span>
<span class="sd">        The final threshold for the MAD, TV, and SumThreshold algorithms</span>
<span class="sd">        given as number of standard deviations.  Default: 5.0</span>
<span class="sd">    niter : int, optional</span>
<span class="sd">        Number of iterations.  At each iterations the baseline and standard</span>
<span class="sd">        deviation are re-estimated using the mask from the previous iteration.</span>
<span class="sd">        Default: 5</span>
<span class="sd">    rho : float, optional</span>
<span class="sd">        Reduce the threshold by this factor at each iteration.  A value of 1</span>
<span class="sd">        will keep the threshold constant for all iterations.  Default: 1.5</span>
<span class="sd">    base_size : [int, int]</span>
<span class="sd">        The size of the region used to estimate the baseline, provided as</span>
<span class="sd">        (number of frequency channels, number of time samples).  Default: (37, 181)</span>
<span class="sd">    mad_size : [int, int]</span>
<span class="sd">        The size of the region used to estimate the standard deviation, provided</span>
<span class="sd">        (number of frequency channels, number of time samples).  Default: (101, 31)</span>
<span class="sd">    tv_fraction : float, optional</span>
<span class="sd">        Fraction of bad samples in a digital TV channel that cause the whole</span>
<span class="sd">        channel to be flagged.  Default: 0.5</span>
<span class="sd">    max_m : int, optional</span>
<span class="sd">        Maximum size of the SumThreshold window to use.  Default: 64</span>
<span class="sd">    sir : bool, optional</span>
<span class="sd">        Apply scale invariant rank (SIR) operator on top of final mask.</span>
<span class="sd">        Default: False</span>
<span class="sd">    eta : float optional</span>
<span class="sd">        Aggressiveness of the SIR operator.  With eta=0, no additional samples</span>
<span class="sd">        are flagged and with eta=1, all samples will be flagged.  Default: 0.2</span>
<span class="sd">    only_time : bool, optinal</span>
<span class="sd">        Only apply the SIR operator along the time axis.  Default: False</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mask_type</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">enum</span><span class="p">([</span><span class="s2">&quot;mad&quot;</span><span class="p">,</span> <span class="s2">&quot;sumthreshold&quot;</span><span class="p">,</span> <span class="s2">&quot;combine&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;combine&quot;</span><span class="p">)</span>
    <span class="n">include_pol</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">list_type</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="n">nsigma_1d</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span>
    <span class="n">quantile_1d</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.15</span><span class="p">)</span>
    <span class="n">win_f_1d</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">191</span><span class="p">)</span>

    <span class="n">nsigma</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span>
    <span class="n">niter</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>

    <span class="n">base_size</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">list_type</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">(</span><span class="mi">37</span><span class="p">,</span> <span class="mi">181</span><span class="p">))</span>
    <span class="n">mad_size</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">list_type</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">(</span><span class="mi">101</span><span class="p">,</span> <span class="mi">31</span><span class="p">))</span>
    <span class="n">tv_fraction</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">max_m</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>

    <span class="n">sir</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">eta</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
    <span class="n">only_time</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Convert MAD to RMS</span>
    <span class="n">MAD_TO_RMS</span> <span class="o">=</span> <span class="mf">1.4826</span>

<div class="viewcode-block" id="RFISensitivityMask.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RFISensitivityMask.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Define the threshold as a function of iteration.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsigma</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niter</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="RFISensitivityMask.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RFISensitivityMask.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sensitivity</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Derive an RFI mask from sensitivity data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sensitivity : containers.SystemSensitivity</span>
<span class="sd">            Sensitivity data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rfimask : containers.RFIMask</span>
<span class="sd">            RFI mask derived from sensitivity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Distribute over polarisation as we need all times and frequencies</span>
        <span class="c1"># available simultaneously</span>
        <span class="n">sensitivity</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;pol&quot;</span><span class="p">)</span>

        <span class="n">pol</span> <span class="o">=</span> <span class="n">sensitivity</span><span class="o">.</span><span class="n">pol</span>
        <span class="n">npol</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pol</span><span class="p">)</span>

        <span class="c1"># Divide sensitivity to get a radiometer test</span>
        <span class="n">radiometer</span> <span class="o">=</span> <span class="n">sensitivity</span><span class="o">.</span><span class="n">measured</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span>
            <span class="n">sensitivity</span><span class="o">.</span><span class="n">radiometer</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="p">)</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">sensitivity</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span> <span class="o">==</span> <span class="mf">0.0</span>

        <span class="c1"># Look up static mask if it exists</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">sensitivity</span><span class="o">.</span><span class="n">freq</span>
        <span class="n">static_flag</span> <span class="o">=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">_static_rfi_mask_hook</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">sensitivity</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Look up times to use the mad mask</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_type</span> <span class="o">==</span> <span class="s2">&quot;combine&quot;</span><span class="p">:</span>
            <span class="n">madtimes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_st_mad_hook</span><span class="p">(</span><span class="n">sensitivity</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>

        <span class="c1"># Create arrays to hold final masks</span>
        <span class="n">nfreq</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">ntime</span> <span class="o">=</span> <span class="n">radiometer</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">finalmask</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="p">((</span><span class="n">npol</span><span class="p">,</span> <span class="n">nfreq</span><span class="p">,</span> <span class="n">ntime</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">finalmask</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Loop over polarisations</span>
        <span class="k">for</span> <span class="n">li</span><span class="p">,</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">finalmask</span><span class="o">.</span><span class="n">enumerate</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
            <span class="c1"># Only process this polarisation if we should be including it,</span>
            <span class="c1"># otherwise skip and let it be implicitly set to False (i.e. not</span>
            <span class="c1"># masked)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_pol</span> <span class="ow">and</span> <span class="n">pol</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_pol</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Initial flag on weights equal to zero.</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">radiometer</span><span class="p">[:,</span> <span class="n">li</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">origflag</span> <span class="o">=</span> <span class="n">flag</span><span class="p">[:,</span> <span class="n">li</span><span class="p">,</span> <span class="p">:]</span>

            <span class="c1"># Combine weights with static flag</span>
            <span class="n">current_flag</span> <span class="o">=</span> <span class="n">origflag</span> <span class="o">|</span> <span class="n">static_flag</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>

            <span class="c1"># Mask frequency channels based on their quantile over time</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsigma_1d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">flag_1d</span><span class="p">,</span> <span class="n">y_static</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask_1d</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">current_flag</span><span class="p">)</span>
                <span class="n">current_flag</span> <span class="o">|=</span> <span class="n">flag_1d</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">y_static</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>

            <span class="c1"># Slowly reduce the threshold.  At each iteration generate a new estimate</span>
            <span class="c1"># of the background sky and the variance using the current mask.</span>
            <span class="k">for</span> <span class="n">nsigma</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">:</span>
                <span class="c1"># Estimate the background by taking a 2D rolling median</span>
                <span class="n">med_y</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">medfilt</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">current_flag</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_size</span><span class="p">)</span>
                <span class="n">dy</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">med_y</span>

                <span class="c1"># Estimate the median absolute deviation</span>
                <span class="n">ady</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span>

                <span class="n">med_ady</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MAD_TO_RMS</span> <span class="o">*</span> <span class="n">filters</span><span class="o">.</span><span class="n">medfilt</span><span class="p">(</span>
                    <span class="n">ady</span><span class="p">,</span> <span class="n">current_flag</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mad_size</span>
                <span class="p">)</span>

                <span class="n">ady_nsigma</span> <span class="o">=</span> <span class="n">ady</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">med_ady</span><span class="p">)</span>

                <span class="c1"># Flag based on median absolute deviation</span>
                <span class="n">madmask</span> <span class="o">=</span> <span class="n">ady_nsigma</span> <span class="o">&gt;</span> <span class="n">nsigma</span>

                <span class="c1"># Flag for scattered TV emission</span>
                <span class="n">tvmask</span> <span class="o">=</span> <span class="n">tv_channels_flag</span><span class="p">(</span>
                    <span class="n">ady_nsigma</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">nsigma</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tv_fraction</span>
                <span class="p">)</span>

                <span class="n">madmask</span> <span class="o">|=</span> <span class="n">tvmask</span>

                <span class="c1"># Pick which of the MAD or SumThreshold mask to use (or blend them)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_type</span> <span class="o">==</span> <span class="s2">&quot;mad&quot;</span><span class="p">:</span>
                    <span class="n">current_flag</span> <span class="o">|=</span> <span class="n">madmask</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Generate sumthreshold mask</span>
                    <span class="n">stmask</span> <span class="o">=</span> <span class="n">rfi</span><span class="o">.</span><span class="n">sumthreshold</span><span class="p">(</span>
                        <span class="n">dy</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">max_m</span><span class="p">,</span>
                        <span class="n">start_flag</span><span class="o">=</span><span class="n">current_flag</span> <span class="o">|</span> <span class="n">tvmask</span><span class="p">,</span>
                        <span class="n">threshold1</span><span class="o">=</span><span class="n">nsigma</span><span class="p">,</span>
                        <span class="n">remove_median</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">correct_for_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">rho</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                        <span class="n">variance</span><span class="o">=</span><span class="n">med_ady</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                    <span class="p">)</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_type</span> <span class="o">==</span> <span class="s2">&quot;sumthreshold&quot;</span><span class="p">:</span>
                        <span class="n">current_flag</span> <span class="o">|=</span> <span class="n">stmask</span>

                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># combine</span>
                        <span class="n">tempmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">madtimes</span><span class="p">,</span> <span class="n">madmask</span><span class="p">,</span> <span class="n">stmask</span><span class="p">)</span>
                        <span class="c1"># If SIR is not going to be applied to the final mask,</span>
                        <span class="c1"># then apply it here to extend the sumthreshold mask</span>
                        <span class="c1"># in time across the transits.</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sir</span><span class="p">:</span>
                            <span class="n">expanded</span> <span class="o">=</span> <span class="n">rfi</span><span class="o">.</span><span class="n">scale_invariant_rank</span><span class="p">(</span>
                                <span class="n">tempmask</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
                            <span class="p">)</span>
                            <span class="n">tempmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">madtimes</span><span class="p">,</span> <span class="n">expanded</span><span class="p">,</span> <span class="n">tempmask</span><span class="p">)</span>

                        <span class="n">current_flag</span> <span class="o">|=</span> <span class="n">tempmask</span>

            <span class="n">finalmask</span><span class="p">[</span><span class="n">li</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_flag</span>

        <span class="c1"># Perform an OR (.any) along the pol axis and reform into an mpiarray.MPIArray</span>
        <span class="c1"># along the freq axis</span>
        <span class="n">finalmask</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">finalmask</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Collect all parts of the mask onto rank 1 and then broadcast to all ranks</span>
        <span class="n">finalmask</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">finalmask</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">allgather</span><span class="p">()</span>

        <span class="c1"># Log the fraction of data masked</span>
        <span class="n">percent_masked</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">finalmask</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">finalmask</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;After RFISensitivityMask, </span><span class="si">{</span><span class="n">percent_masked</span><span class="si">:</span><span class="s2">0.2f</span><span class="si">}</span><span class="s2"> percent &quot;</span>
            <span class="s2">&quot;of data will be masked.&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Apply scale invariant rank (SIR) operator, if asked for.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sir</span><span class="p">:</span>
            <span class="n">finalmask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_sir</span><span class="p">(</span><span class="n">finalmask</span><span class="p">,</span> <span class="n">static_flag</span><span class="p">)</span>

            <span class="c1"># Again log the fraction of data masked, so we can</span>
            <span class="c1"># tell how much data is being excised by SIR</span>
            <span class="n">percent_masked</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">finalmask</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">finalmask</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;After SIR operator, </span><span class="si">{</span><span class="n">percent_masked</span><span class="si">:</span><span class="s2">0.2f</span><span class="si">}</span><span class="s2"> percent &quot;</span>
                <span class="s2">&quot;of data will be masked.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Create container to hold mask</span>
        <span class="n">rfimask</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">RFIMask</span><span class="p">(</span><span class="n">axes_from</span><span class="o">=</span><span class="n">sensitivity</span><span class="p">,</span> <span class="n">attrs_from</span><span class="o">=</span><span class="n">sensitivity</span><span class="p">)</span>
        <span class="n">rfimask</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">finalmask</span>

        <span class="k">return</span> <span class="n">rfimask</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_combine_st_mad_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">freq</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Override to add a custom blending mask between the SumThreshold and MAD flagged data.</span>

<span class="sd">        This is useful to use the MAD algorithm around bright source</span>
<span class="sd">        transits, where the SumThreshold begins to remove real signal.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        times : np.ndarray[ntime]</span>
<span class="sd">            Times of the data at floating point UNIX time.</span>
<span class="sd">        freq : np.ndarray[nfreq]</span>
<span class="sd">            Array of frequencies.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        combine : np.ndarray[ntime]</span>
<span class="sd">            Mixing array as a function of time. If `True` that sample will be</span>
<span class="sd">            filled from the MAD, if `False` use the SumThreshold algorithm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">freq</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">times</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_static_rfi_mask_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">timestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Override this function to apply a static RFI mask to the data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq : np.ndarray[nfreq]</span>
<span class="sd">            1D array of frequencies in the data (in MHz).</span>
<span class="sd">        timestamp : float or np.ndarray[ntimes]</span>
<span class="sd">            timestamps to use when determining the static mask for this datatset</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask : np.ndarray[nfreq]</span>
<span class="sd">            Mask array. True will include a frequency channel, False masks it out.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_mask_1d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rad</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mask based on the median over time.&quot;&quot;&quot;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">rad</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">((</span><span class="o">~</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>

        <span class="n">medt_y</span> <span class="o">=</span> <span class="n">median</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">quantile_1d</span><span class="p">)</span>
        <span class="n">medt_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">win_f_1d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">medf_medt_y</span> <span class="o">=</span> <span class="n">median</span><span class="o">.</span><span class="n">weighted_median</span><span class="p">(</span><span class="n">medt_y</span><span class="p">,</span> <span class="n">medt_w</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">medf_medt_y</span> <span class="o">=</span> <span class="n">median</span><span class="o">.</span><span class="n">moving_weighted_median</span><span class="p">(</span><span class="n">medt_y</span><span class="p">,</span> <span class="n">medt_w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">win_f_1d</span><span class="p">)</span>

        <span class="n">absd_medt_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">medt_y</span> <span class="o">-</span> <span class="n">medf_medt_y</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">win_f_1d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mad_1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MAD_TO_RMS</span> <span class="o">*</span> <span class="n">median</span><span class="o">.</span><span class="n">weighted_median</span><span class="p">(</span><span class="n">absd_medt_y</span><span class="p">,</span> <span class="n">medt_w</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mad_1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MAD_TO_RMS</span> <span class="o">*</span> <span class="n">median</span><span class="o">.</span><span class="n">moving_weighted_median</span><span class="p">(</span>
                <span class="n">absd_medt_y</span><span class="p">,</span> <span class="n">medt_w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">win_f_1d</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">absd_medt_y</span> <span class="o">&gt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsigma_1d</span> <span class="o">*</span> <span class="n">mad_1d</span><span class="p">),</span> <span class="n">medt_y</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_apply_sir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">baseflag</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="mf">0.2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Expand the mask with SIR.&quot;&quot;&quot;</span>
        <span class="c1"># Remove baseflag from mask and run SIR</span>
        <span class="n">nobaseflag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">nobaseflag</span><span class="p">[</span><span class="n">baseflag</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">axes</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">only_time</span> <span class="k">else</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">nobaseflagsir</span> <span class="o">=</span> <span class="n">rfi</span><span class="o">.</span><span class="n">scale_invariant_rank</span><span class="p">(</span><span class="n">nobaseflag</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>

        <span class="c1"># Make sure the original mask (including baseflag) is still masked</span>
        <span class="k">return</span> <span class="n">nobaseflagsir</span> <span class="o">|</span> <span class="n">mask</span></div>



<div class="viewcode-block" id="RFIMask">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RFIMask">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RFIMask</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Crappy RFI masking.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    sigma : float, optional</span>
<span class="sd">        The false positive rate of the flagger given as sigma value assuming</span>
<span class="sd">        the non-RFI samples are Gaussian.</span>
<span class="sd">    tv_fraction : float, optional</span>
<span class="sd">        Number of bad samples in a digital TV channel that cause the whole</span>
<span class="sd">        channel to be flagged.</span>
<span class="sd">    stack_ind : int</span>
<span class="sd">        Which stack to process to derive flags for the whole dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">sigma</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span>
    <span class="n">tv_fraction</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">stack_ind</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sstream</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealStream</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealRFIMask</span><span class="p">:</span> <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sstream</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">TimeStream</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">RFIMask</span><span class="p">:</span> <span class="o">...</span>

<div class="viewcode-block" id="RFIMask.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RFIMask.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sstream</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">TimeStream</span> <span class="o">|</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealStream</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">RFIMask</span> <span class="o">|</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealRFIMask</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply a day time mask.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sstream</span>
<span class="sd">            Unmasked sidereal or time stream visibility data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask</span>
<span class="sd">            The derived RFI mask.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Select the correct mask type depending on if we have sidereal data or not</span>
        <span class="n">output_type</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">containers</span><span class="o">.</span><span class="n">SiderealRFIMask</span>
            <span class="k">if</span> <span class="s2">&quot;ra&quot;</span> <span class="ow">in</span> <span class="n">sstream</span><span class="o">.</span><span class="n">index_map</span>
            <span class="k">else</span> <span class="n">containers</span><span class="o">.</span><span class="n">RFIMask</span>
        <span class="p">)</span>

        <span class="n">sstream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">([</span><span class="s2">&quot;stack&quot;</span><span class="p">,</span> <span class="s2">&quot;prod&quot;</span><span class="p">])</span>

        <span class="n">ssv</span> <span class="o">=</span> <span class="n">sstream</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span>
        <span class="n">ssw</span> <span class="o">=</span> <span class="n">sstream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span>

        <span class="c1"># Figure out which rank actually has the requested index</span>
        <span class="n">lstart</span> <span class="o">=</span> <span class="n">ssv</span><span class="o">.</span><span class="n">local_offset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">lstop</span> <span class="o">=</span> <span class="n">lstart</span> <span class="o">+</span> <span class="n">ssv</span><span class="o">.</span><span class="n">local_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">has_ind</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack_ind</span> <span class="o">&gt;=</span> <span class="n">lstart</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack_ind</span> <span class="o">&lt;</span> <span class="n">lstop</span><span class="p">)</span>
        <span class="n">has_ind_list</span> <span class="o">=</span> <span class="n">sstream</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allgather</span><span class="p">(</span><span class="n">has_ind</span><span class="p">)</span>
        <span class="n">rank_with_ind</span> <span class="o">=</span> <span class="n">has_ind_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Rank </span><span class="si">%i</span><span class="s2"> has the requested index </span><span class="si">%i</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">rank_with_ind</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack_ind</span>
        <span class="p">)</span>

        <span class="n">mask_cont</span> <span class="o">=</span> <span class="n">output_type</span><span class="p">(</span><span class="n">copy_from</span><span class="o">=</span><span class="n">sstream</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask_cont</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span>

        <span class="c1"># Get the rank with stack to create the new mask</span>
        <span class="k">if</span> <span class="n">sstream</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="n">rank_with_ind</span><span class="p">:</span>
            <span class="c1"># Cut out the right section</span>
            <span class="n">wf</span> <span class="o">=</span> <span class="n">ssv</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack_ind</span> <span class="o">-</span> <span class="n">lstart</span><span class="p">]</span>
            <span class="n">ww</span> <span class="o">=</span> <span class="n">ssw</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack_ind</span> <span class="o">-</span> <span class="n">lstart</span><span class="p">]</span>

            <span class="c1"># Generate an initial mask and calculate the scaled deviations</span>
            <span class="c1"># TODO: replace this magic threshold</span>
            <span class="n">weight_cut</span> <span class="o">=</span> <span class="mf">1e-4</span> <span class="o">*</span> <span class="n">ww</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  <span class="c1"># Ignore samples with small weights</span>
            <span class="n">wm</span> <span class="o">=</span> <span class="n">ww</span> <span class="o">&lt;</span> <span class="n">weight_cut</span>
            <span class="n">maddev</span> <span class="o">=</span> <span class="n">mad</span><span class="p">(</span><span class="n">wf</span><span class="p">,</span> <span class="n">wm</span><span class="p">)</span>

            <span class="c1"># Replace any NaNs (where too much data is missing) with a large enough</span>
            <span class="c1"># value to always be flagged</span>
            <span class="n">maddev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">maddev</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="n">maddev</span><span class="p">)</span>

            <span class="c1"># Reflag for scattered TV emission</span>
            <span class="n">tvmask</span> <span class="o">=</span> <span class="n">tv_channels_flag</span><span class="p">(</span>
                <span class="n">maddev</span><span class="p">,</span> <span class="n">sstream</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tv_fraction</span>
            <span class="p">)</span>

            <span class="c1"># Construct the new mask</span>
            <span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">tvmask</span> <span class="o">|</span> <span class="p">(</span><span class="n">maddev</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span>

        <span class="c1"># Broadcast the new flags to all ranks and then apply</span>
        <span class="n">sstream</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">rank_with_ind</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Flagging </span><span class="si">%0.2f%%</span><span class="s2"> of data due to RFI.&quot;</span>
            <span class="o">%</span> <span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">mask_cont</span></div>
</div>



<div class="viewcode-block" id="ApplyTimeFreqMask">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.ApplyTimeFreqMask">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ApplyTimeFreqMask</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply a time-frequency mask to the data.</span>

<span class="sd">    Typically this is used to mask out all inputs at times and</span>
<span class="sd">    frequencies contaminated by RFI.</span>

<span class="sd">    This task may produce output with shared datasets. Be warned that</span>
<span class="sd">    this can produce unexpected outputs if not properly taken into</span>
<span class="sd">    account.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    share : {&quot;all&quot;, &quot;none&quot;, &quot;vis&quot;, &quot;map&quot;}</span>
<span class="sd">        Which datasets should we share with the input. If &quot;none&quot; we create a</span>
<span class="sd">        full copy of the data, if &quot;vis&quot; or &quot;map&quot; we create a copy only of the modified</span>
<span class="sd">        weight dataset and the unmodified vis dataset is shared, if &quot;all&quot; we</span>
<span class="sd">        modify in place and return the input container.</span>
<span class="sd">    collapse_pol : bool</span>
<span class="sd">        Take the logical OR of the mask along the polarisation axis prior to applying</span>
<span class="sd">        it to the data.  In other words, mask a frequency and time in all polarisations</span>
<span class="sd">        if it was identified as contaminated in any polarisation.</span>
<span class="sd">    match_axes : bool, optional</span>
<span class="sd">        If True (default), the rfimask and tstream must have identical time-like axis.</span>
<span class="sd">        Otherwise, the mask is applied only to the overlapping region of the time-like axis.</span>
<span class="sd">        Non-overlapping regions remain unchanged. Samples must still have the same RA or</span>
<span class="sd">        timestamp values in overlapping regions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">share</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">enum</span><span class="p">([</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;vis&quot;</span><span class="p">,</span> <span class="s2">&quot;map&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>
    <span class="n">collapse_pol</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">match_axes</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="ApplyTimeFreqMask.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.ApplyTimeFreqMask.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tstream</span><span class="p">,</span> <span class="n">rfimask</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply the mask by zeroing the weights.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tstream : timestream or sidereal stream</span>
<span class="sd">            A timestream or sidereal stream like container. For example,</span>
<span class="sd">            `containers.TimeStream`, `andata.CorrData` or</span>
<span class="sd">            `containers.SiderealStream`.</span>
<span class="sd">        rfimask : containers.RFIMask, containers.RFIMaskByPol,</span>
<span class="sd">                  containers.SiderealRFIMask, containers.SiderealRFIMaskByPol</span>
<span class="sd">            An RFI mask for the same period of time.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tstream : timestream or sidereal stream</span>
<span class="sd">            The masked timestream. Note that the masking is done in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rfimask</span><span class="p">,</span> <span class="n">containers</span><span class="o">.</span><span class="n">RFIMask</span> <span class="o">|</span> <span class="n">containers</span><span class="o">.</span><span class="n">RFIMaskByPol</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tstream</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Expected a timestream like type. Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">tstream</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
            <span class="n">timelike_ax</span> <span class="o">=</span> <span class="s2">&quot;time&quot;</span>
            <span class="n">timelike_data</span> <span class="o">=</span> <span class="n">tstream</span><span class="o">.</span><span class="n">time</span>
            <span class="n">timelike_mask</span> <span class="o">=</span> <span class="n">rfimask</span><span class="o">.</span><span class="n">time</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">rfimask</span><span class="p">,</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealRFIMask</span> <span class="o">|</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealRFIMaskByPol</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tstream</span><span class="p">,</span> <span class="s2">&quot;ra&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Expected a sidereal stream like type. Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">tstream</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
            <span class="n">timelike_ax</span> <span class="o">=</span> <span class="s2">&quot;ra&quot;</span>
            <span class="n">timelike_data</span> <span class="o">=</span> <span class="n">tstream</span><span class="o">.</span><span class="n">ra</span>
            <span class="n">timelike_mask</span> <span class="o">=</span> <span class="n">rfimask</span><span class="o">.</span><span class="n">ra</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Require a RFIMask or SiderealRFIMask. Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">rfimask</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Validate the frequency axis</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">tstream</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="n">rfimask</span><span class="o">.</span><span class="n">freq</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;timestream and mask data have different freq axes.&quot;</span><span class="p">)</span>

        <span class="c1"># Validate the time-like axis</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_axes</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">timelike_data</span><span class="p">,</span> <span class="n">timelike_mask</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;timestream and mask data have different time-like axes.&quot;</span>
                <span class="p">)</span>
            <span class="c1"># Index the entire arrays</span>
            <span class="n">data_sel</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">mask_sel</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get the samples in `data` which exist in `mask`</span>
            <span class="n">data_sel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">timelike_data</span><span class="p">,</span> <span class="n">timelike_mask</span><span class="p">)</span>
            <span class="c1"># Get the samples in `mask` which exist in `data`</span>
            <span class="n">mask_sel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">timelike_mask</span><span class="p">,</span> <span class="n">timelike_data</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">data_sel</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;No overlapping samples found in timelike axis.&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Data axis: </span><span class="si">{</span><span class="n">timelike_data</span><span class="si">}</span><span class="se">\n</span><span class="s2">Mask axis: </span><span class="si">{</span><span class="n">timelike_mask</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Ensure we are frequency distributed</span>
        <span class="n">tstream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Create a slice that broadcasts the mask to the final shape</span>
        <span class="n">t_axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tstream</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span>
        <span class="n">m_axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rfimask</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span>

        <span class="c1"># Get mask data and shape data</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">rfimask</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span>

        <span class="c1"># Deal with the polarisation axis</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">rfimask</span><span class="p">,</span> <span class="n">containers</span><span class="o">.</span><span class="n">RFIMaskByPol</span> <span class="o">|</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealRFIMaskByPol</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapse_pol</span> <span class="ow">or</span> <span class="s2">&quot;pol&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">t_axes</span><span class="p">:</span>
                <span class="c1"># Collapse polarisation axis</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">m_axes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;pol&quot;</span><span class="p">))</span>
                <span class="n">m_axes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;pol&quot;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="s2">&quot;pol&quot;</span> <span class="ow">in</span> <span class="n">t_axes</span><span class="p">:</span>
                <span class="c1"># Validate the polarisation axis</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">tstream</span><span class="o">.</span><span class="n">pol</span><span class="p">,</span> <span class="n">rfimask</span><span class="o">.</span><span class="n">pol</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;timestream and mask data have different pol axes.&quot;</span>
                    <span class="p">)</span>

        <span class="c1"># Create a slice that broadcasts the mask to the final shape</span>
        <span class="n">bcast_slice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">m_axes</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">t_axes</span><span class="p">]</span>
        <span class="c1"># Create a slice that selects indices to write to</span>
        <span class="n">inp_slice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">t_axes</span><span class="p">]</span>

        <span class="c1"># RFI Mask is not distributed, so we need to cut out the frequencies</span>
        <span class="c1"># that are local for the tstream</span>
        <span class="n">bcast_slice</span><span class="p">[</span><span class="n">t_axes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">tstream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_bounds</span>
        <span class="c1"># Index the overlapping parts of the time-like axis</span>
        <span class="n">inp_slice</span><span class="p">[</span><span class="n">t_axes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">timelike_ax</span><span class="p">)]</span> <span class="o">=</span> <span class="n">data_sel</span>
        <span class="n">bcast_slice</span><span class="p">[</span><span class="n">t_axes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">timelike_ax</span><span class="p">)]</span> <span class="o">=</span> <span class="n">mask_sel</span>

        <span class="c1"># Convert the finalised slices to tuples</span>
        <span class="n">inp_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">inp_slice</span><span class="p">)</span>
        <span class="n">bcast_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">bcast_slice</span><span class="p">)</span>

        <span class="c1"># Create output container by copying based on share parameter</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">share</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">tsc</span> <span class="o">=</span> <span class="n">tstream</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">share</span> <span class="o">==</span> <span class="s2">&quot;vis&quot;</span><span class="p">:</span>
            <span class="n">tsc</span> <span class="o">=</span> <span class="n">tstream</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">shared</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;vis&quot;</span><span class="p">,))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">share</span> <span class="o">==</span> <span class="s2">&quot;map&quot;</span><span class="p">:</span>
            <span class="n">tsc</span> <span class="o">=</span> <span class="n">tstream</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">shared</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;map&quot;</span><span class="p">,))</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># self.share == &quot;none&quot;</span>
            <span class="n">tsc</span> <span class="o">=</span> <span class="n">tstream</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Mask the data</span>
        <span class="n">tsc</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[</span><span class="n">inp_slice</span><span class="p">]</span> <span class="o">*=</span> <span class="o">~</span><span class="n">mask</span><span class="p">[</span><span class="n">bcast_slice</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">tsc</span></div>
</div>



<div class="viewcode-block" id="ApplyGenericMask">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.ApplyGenericMask">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ApplyGenericMask</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply a mask to a dataset with arbitrary axes.</span>

<span class="sd">    All of the mask axes must be present in the dataset, but</span>
<span class="sd">    the dataset can have additional axes.</span>

<span class="sd">    Assumes that a sample marked `True` in the mask dataset</span>
<span class="sd">    should be flagged.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ApplyGenericMask.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.ApplyGenericMask.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">ContainerPrototype</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">ContainerPrototype</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply the mask to the dataset weights.</span>

<span class="sd">        Reorder the mask axes and add broadcasting axes if necessary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data</span>
<span class="sd">            Any container with a frequency axis.</span>
<span class="sd">        mask</span>
<span class="sd">            Any container whose axes are a subset of the axes in data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data</span>
<span class="sd">            The input container with the weight dataset set to zero</span>
<span class="sd">            for masked samples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Pull out the axes of each dataset</span>
        <span class="n">daxes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span>
        <span class="n">maxes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span>

        <span class="c1"># Make sure all the mask axes exist in the data</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">ax</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">daxes</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">maxes</span><span class="p">):</span>
            <span class="n">missing_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">maxes</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">daxes</span><span class="p">]</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Mask has axes </span><span class="si">{</span><span class="n">missing_axes</span><span class="si">}</span><span class="s2"> which are not found in data.&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Data axes: </span><span class="si">{</span><span class="n">daxes</span><span class="si">}</span><span class="se">\n</span><span class="s2">Mask axes: </span><span class="si">{</span><span class="n">maxes</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Redistribute over frequency, assuming that all containers have</span>
        <span class="c1"># a frequency axis</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
        <span class="n">mask</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Rearrange the existing mask axes to match their order in the dataset</span>
        <span class="n">tinds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">maxes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">daxes</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">maxes</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">tinds</span><span class="p">)</span>

        <span class="c1"># Add broadcasting axes now that mask axes are in the correct order</span>
        <span class="n">bcast_slobj</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">maxes</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">daxes</span><span class="p">)</span>

        <span class="c1"># Multiply the inverse mask into the weights</span>
        <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:]</span> <span class="o">*=</span> <span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">[</span><span class="n">bcast_slobj</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span></div>
</div>



<span class="c1"># Alias for backwards compatibility</span>
<span class="n">MaskBeamformedOutliers</span> <span class="o">=</span> <span class="n">ApplyGenericMask</span>


<div class="viewcode-block" id="GeneralCombineMasks">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.GeneralCombineMasks">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GeneralCombineMasks</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Combine multiple masks using a user-specified logical expression.</span>

<span class="sd">    The input is a list of containers with `mask` datasets. Each mask is assigned</span>
<span class="sd">    a variable name (`A`, `B`, `C`, ..., `Z`) in the order they appear. The logical</span>
<span class="sd">    combination is defined using a Python expression involving those variables.</span>

<span class="sd">    For example, if `masks = [m1, m2]`, then the expression</span>
<span class="sd">    `&quot;A &amp; ~B&quot;` would keep values that are masked in `m1` and not in `m2`.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    expression : str</span>
<span class="sd">        A Python expression combining the mask variables. Variables must be uppercase</span>
<span class="sd">        letters `A`, `B`, ..., matching the order of the input masks.</span>
<span class="sd">        The expression must evaluate to a boolean array of the same shape.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">expression</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>

    <span class="n">_dataset_name</span> <span class="o">=</span> <span class="s2">&quot;mask&quot;</span>
    <span class="n">_operators</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="s2">&quot;&amp;|~^()&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="GeneralCombineMasks.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.GeneralCombineMasks.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">masks</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">ContainerPrototype</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Combine the given list of masks using the logical expression.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        masks : list of ContainerPrototype</span>
<span class="sd">            A list of containers with a `mask` dataset, all of the same type and shape.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        combined_mask : ContainerPrototype</span>
<span class="sd">            A new container of the same type with the result of the logical combination.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">masks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">26</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Too many masks: only A-Z are supported (max 26).&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">masks</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">mask</span> <span class="ow">in</span> <span class="n">masks</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All input masks must be of the same container type.&quot;</span><span class="p">)</span>

        <span class="c1"># Check the expression only contains valid characters</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_allowed_pattern</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid expression: &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="si">}</span><span class="s2">&#39;. Allowed characters: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;A-Z, digits, whitespace, and </span><span class="si">{</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_operators</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">mask</span> <span class="ow">in</span> <span class="n">masks</span><span class="p">:</span>
            <span class="n">mask</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Assign variables A, B, C, ..., one per mask</span>
        <span class="n">namespace</span> <span class="o">=</span> <span class="p">{</span>
            <span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">):</span> <span class="n">mask</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_dataset_name</span><span class="p">][:]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">masks</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="c1"># Evaluate the logical expression</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Evaluating mask combination expression: &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">,</span> <span class="p">{},</span> <span class="n">namespace</span><span class="p">)</span>

        <span class="c1"># Create a copy and set the result</span>
        <span class="n">combined_mask</span> <span class="o">=</span> <span class="n">masks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">combined_mask</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
        <span class="n">combined_mask</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_dataset_name</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">result</span>

        <span class="k">return</span> <span class="n">combined_mask</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_build_allowed_pattern</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build a regex pattern for allowed expressions.&quot;&quot;&quot;</span>
        <span class="c1"># Escape special regex characters if needed</span>
        <span class="n">escaped_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operators</span><span class="p">]</span>
        <span class="n">ops_pattern</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">escaped_ops</span><span class="p">)</span>
        <span class="c1"># A-Z letters, digits, and whitespace are always allowed</span>
        <span class="k">return</span> <span class="sa">rf</span><span class="s2">&quot;^[A-Z0-9\s</span><span class="si">{</span><span class="n">ops_pattern</span><span class="si">}</span><span class="s2">]+$&quot;</span></div>



<div class="viewcode-block" id="CombineMasks">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.CombineMasks">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CombineMasks</span><span class="p">(</span><span class="n">GeneralCombineMasks</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Combine an arbitrary number of masks conservatively (logical OR).&quot;&quot;&quot;</span>

<div class="viewcode-block" id="CombineMasks.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.CombineMasks.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">masks</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">ContainerPrototype</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct the logical OR of all masks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        masks : list of ContainerPrototype</span>
<span class="sd">            A list of containers with a `mask` dataset, all of the same type and shape.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        combined_mask : ContainerPrototype</span>
<span class="sd">            A new container of the same type containing the logical OR of all masks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Construct expression: A | B | C ...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expression</span> <span class="o">=</span> <span class="s2">&quot; | &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">masks</span><span class="p">))])</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">masks</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="ApplyTaper">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.ApplyTaper">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ApplyTaper</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply a taper to a dataset with arbitrary axes.</span>

<span class="sd">    All of the taper axes must be present in the dataset, but</span>
<span class="sd">    the dataset can have additional axes.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    update_weight : bool</span>
<span class="sd">        If set to True, the taper will be applied to the</span>
<span class="sd">        weight dataset using the standard equation for</span>
<span class="sd">        propagation of uncertainty.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">update_weight</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="ApplyTaper.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.ApplyTaper.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">ContainerPrototype</span><span class="p">,</span> <span class="n">taper</span><span class="p">:</span> <span class="n">ContainerPrototype</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply the taper to the dataset weights.</span>

<span class="sd">        Reorder the taper axes and add broadcasting axes if necessary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : containers.DataWeightContainer</span>
<span class="sd">            A container with `data` and `weight` properties.</span>
<span class="sd">            Both the data and weight must include a `freq` axis,</span>
<span class="sd">            and must contain all axes present in the taper.</span>
<span class="sd">        taper : ContainerPrototype</span>
<span class="sd">            Any container that has a `taper` property that has</span>
<span class="sd">            a `freq` axis and whose othes axes are a subset of</span>
<span class="sd">            those in the data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : containers.DataWeightContainer</span>
<span class="sd">            The input container, with the `data` property scaled by the taper,</span>
<span class="sd">            and optionally the `weight` scaled appropriately.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Pull out the axes of each dataset</span>
        <span class="n">daxes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span>
        <span class="n">waxes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span>
        <span class="n">taxes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">taper</span><span class="o">.</span><span class="n">taper</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span>

        <span class="c1"># Make sure all the taper axes exist in the data</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">axes</span> <span class="ow">in</span> <span class="p">[(</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="n">daxes</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span> <span class="n">waxes</span><span class="p">)]:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">ax</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">taxes</span><span class="p">):</span>
                <span class="n">missing_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">taxes</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]</span>
                <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Taper has axes </span><span class="si">{</span><span class="n">missing_axes</span><span class="si">}</span><span class="s2"> which are not found in </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> axes: </span><span class="si">{</span><span class="n">axes</span><span class="si">}</span><span class="se">\n</span><span class="s2">taper axes: </span><span class="si">{</span><span class="n">taxes</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Redistribute over frequency, assuming that all containers have</span>
        <span class="c1"># a frequency axis</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
        <span class="n">taper</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Rearrange the existing taper axes to match their order in the dataset</span>
        <span class="n">tinds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">taxes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">daxes</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">taxes</span><span class="p">)</span>
        <span class="n">taper</span> <span class="o">=</span> <span class="n">taper</span><span class="o">.</span><span class="n">taper</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">tinds</span><span class="p">)</span>

        <span class="c1"># Add broadcasting axes now that taper axes are in the correct order</span>
        <span class="n">dbcast</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">taxes</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">daxes</span><span class="p">)</span>
        <span class="n">wbcast</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">taxes</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">waxes</span><span class="p">)</span>

        <span class="c1"># Multiply the data by the taper</span>
        <span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">taper</span><span class="p">[</span><span class="n">dbcast</span><span class="p">]</span>

        <span class="c1"># Optionally update the weights</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_weight</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">taper</span><span class="p">[</span><span class="n">wbcast</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="n">data</span></div>
</div>



<div class="viewcode-block" id="GeneralCombineTapers">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.GeneralCombineTapers">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GeneralCombineTapers</span><span class="p">(</span><span class="n">GeneralCombineMasks</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Combine multiple taper functions using a user-defined expression.</span>

<span class="sd">    This is a subclass of `GeneralCombineMasks` that operates on the `taper`</span>
<span class="sd">    dataset rather than `mask`. Each input taper is assigned a variable</span>
<span class="sd">    (`A`, `B`, `C`, ..., `Z`) in the order they appear. The combination is</span>
<span class="sd">    defined by the `expression` property, which is evaluated using standard</span>
<span class="sd">    Python syntax.</span>

<span class="sd">    For example, an expression like `&quot;A * B&quot;` multiplies two taper functions</span>
<span class="sd">    elementwise.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    expression : str</span>
<span class="sd">        A Python expression combining the taper datasets from each input</span>
<span class="sd">        container using variable names `A`, `B`, etc.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_dataset_name</span> <span class="o">=</span> <span class="s2">&quot;taper&quot;</span>
    <span class="n">_operators</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="s2">&quot;+-*/()&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="CombineTapers">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.CombineTapers">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CombineTapers</span><span class="p">(</span><span class="n">GeneralCombineTapers</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Combine an arbitrary number of tapers conservatively (multiply).&quot;&quot;&quot;</span>

<div class="viewcode-block" id="CombineTapers.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.CombineTapers.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tapers</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">ContainerPrototype</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct the product of all tapers.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tapers : list of ContainerPrototype</span>
<span class="sd">            A list of containers with a `taper` dataset, all of the same type and shape.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        combined_taper : ContainerPrototype</span>
<span class="sd">            A new container of the same type containing the product of all tapers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Construct expression: A * B * C ...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expression</span> <span class="o">=</span> <span class="s2">&quot; * &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tapers</span><span class="p">))])</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">tapers</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="MaskFromTaper">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.MaskFromTaper">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MaskFromTaper</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a binary mask from a taper.</span>

<span class="sd">    This task constructs a `RingMapMask` by thresholding a `RingMapTaper`.</span>
<span class="sd">    The resulting mask is `True` where the taper is either less than 1.0</span>
<span class="sd">    or equal to 0.0, depending on the `outer` parameter.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    outer : bool</span>
<span class="sd">        If True, mask all samples within the outer boundary of the taper</span>
<span class="sd">        (i.e., where the taper is &lt; 1).  If False, mask all samples</span>
<span class="sd">        within the inner boundary of the taper is (i.e., where the taper is 0).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">outer</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="MaskFromTaper.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.MaskFromTaper.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">taper</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate the mask from the taper.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        taper : containers.RingMapTaper</span>
<span class="sd">            The taper used to generate the mask.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : containers.RingMapMask</span>
<span class="sd">            The boolean mask that indicates where the taper is</span>
<span class="sd">            less than 1 (outer = True) or zero (outer = False).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">taper</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">RingMapMask</span><span class="p">(</span>
            <span class="n">axes_from</span><span class="o">=</span><span class="n">taper</span><span class="p">,</span>
            <span class="n">attrs_from</span><span class="o">=</span><span class="n">taper</span><span class="p">,</span>
            <span class="n">distributed</span><span class="o">=</span><span class="n">taper</span><span class="o">.</span><span class="n">distributed</span><span class="p">,</span>
            <span class="n">comm</span><span class="o">=</span><span class="n">taper</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">out</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">outer</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">taper</span><span class="o">.</span><span class="n">taper</span><span class="p">[:]</span> <span class="o">&lt;</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">taper</span><span class="o">.</span><span class="n">taper</span><span class="p">[:]</span> <span class="o">==</span> <span class="mf">0.0</span>

        <span class="k">return</span> <span class="n">out</span></div>
</div>



<div class="viewcode-block" id="TaperDelayTransform">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.TaperDelayTransform">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">TaperDelayTransform</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply a taper or mask to a DelayTransform container.</span>

<span class="sd">    This task applies a frequency-collapsed taper or mask to the delay-domain</span>
<span class="sd">    representation of ringmaps. Because DelayTransform containers are indexed</span>
<span class="sd">    over (baseline_axes, sample, delay), the taper or mask must first be averaged</span>
<span class="sd">    or collapsed over frequency and then reshaped to align with the baseline axes.</span>
<span class="sd">    This operation is necessary due to the mismatch between the frequency-dependent</span>
<span class="sd">    structure of the taper/mask and the frequency-transformed delay axis.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    update_weight : bool</span>
<span class="sd">        If True, update the weights to account for the applied taper. This multiplies</span>
<span class="sd">        the weights by 1 / taper^2 in all unmasked regions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">update_weight</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="TaperDelayTransform.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.TaperDelayTransform.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">DelayTransform</span><span class="p">,</span>
        <span class="n">apply</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">RingMapTaper</span> <span class="o">|</span> <span class="n">containers</span><span class="o">.</span><span class="n">RingMapMask</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply the taper or mask to the DelayTransform container.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : containers.DelayTransform</span>
<span class="sd">            The dataset to be modified in-place. Must contain a &#39;spectrum&#39;</span>
<span class="sd">            dataset with shape (..., sample, delay), where &#39;sample&#39;</span>
<span class="sd">            corresponds to RA, and a &#39;weight&#39; dataset of the same shape.</span>
<span class="sd">        apply : RingMapTaper or RingMapMask</span>
<span class="sd">            A container providing the taper or mask to apply. For a</span>
<span class="sd">            RingMapTaper, the taper will be averaged over frequency. For a</span>
<span class="sd">            RingMapMask, pixels that are good in all frequency channels will</span>
<span class="sd">            be treated as 1.0 and others as 0.0.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : containers.DelayTransform</span>
<span class="sd">            The input DelayTransform container with &#39;spectrum&#39; and optionally</span>
<span class="sd">            &#39;weight&#39; modified in-place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Distribute over the sample/ra axis</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;sample&quot;</span><span class="p">)</span>
        <span class="n">apply</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;ra&quot;</span><span class="p">)</span>

        <span class="c1"># Collapse the taper/mask over the frequency axis</span>
        <span class="c1"># Resulting array will have shape (pol, el, ra)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">apply</span><span class="p">,</span> <span class="n">containers</span><span class="o">.</span><span class="n">RingMapTaper</span><span class="p">):</span>
            <span class="n">taper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">apply</span><span class="o">.</span><span class="n">taper</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">taper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="o">~</span><span class="n">apply</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">nra</span> <span class="o">=</span> <span class="n">taper</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Check that the axes match</span>
        <span class="k">for</span> <span class="n">dax</span><span class="p">,</span> <span class="n">tax</span> <span class="ow">in</span> <span class="p">[(</span><span class="s2">&quot;sample&quot;</span><span class="p">,</span> <span class="s2">&quot;ra&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;el&quot;</span><span class="p">,</span> <span class="s2">&quot;el&quot;</span><span class="p">)]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="n">dax</span><span class="p">],</span> <span class="n">apply</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="n">tax</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Mismatch between </span><span class="si">{</span><span class="n">dax</span><span class="si">}</span><span class="s2"> axis of delay transform and </span><span class="si">{</span><span class="n">tax</span><span class="si">}</span><span class="s2"> axis of taper/mask.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Reformat the taper into a shape that can be broadcasted against the delay transform</span>
        <span class="n">bax</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;baseline_axes&quot;</span><span class="p">]</span>
        <span class="n">shp</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">bax</span><span class="p">],</span> <span class="n">nra</span><span class="p">)</span>
        <span class="n">bcast</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;pol&quot;</span><span class="p">,</span> <span class="s2">&quot;el&quot;</span><span class="p">]</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">bax</span><span class="p">])</span>

        <span class="n">taper_expanded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">taper_expanded</span> <span class="o">*=</span> <span class="n">taper</span><span class="p">[</span><span class="n">bcast</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="n">taper_collapsed</span> <span class="o">=</span> <span class="n">taper_expanded</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nra</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Multiply the delay transform by the taper/mask</span>
        <span class="n">data</span><span class="o">.</span><span class="n">spectrum</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">taper_collapsed</span>

        <span class="c1"># Optionally update the weights</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_weight</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;weight&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:]</span> <span class="o">*=</span> <span class="p">(</span>
                    <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">taper_collapsed</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Delay transform does not contain a weight dataset.  Skipping application of mask/taper.&quot;</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span></div>
</div>



<div class="viewcode-block" id="ApplyBaselineMask">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.ApplyBaselineMask">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ApplyBaselineMask</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply a distributed mask that varies across baselines.</span>

<span class="sd">    No broadcasting is done, so the data and mask should have the same</span>
<span class="sd">    axes. This shouldn&#39;t be used for non-distributed time-freq masks.</span>

<span class="sd">    This task may produce output with shared datasets. Be warned that</span>
<span class="sd">    this can produce unexpected outputs if not properly taken into</span>
<span class="sd">    account.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    share : {&quot;all&quot;, &quot;none&quot;, &quot;vis&quot;, &quot;map&quot;}</span>
<span class="sd">        Which datasets should we share with the input. If &quot;none&quot; we create a</span>
<span class="sd">        full copy of the data, if &quot;vis&quot; or &quot;map&quot; we create a copy only of the modified</span>
<span class="sd">        weight dataset and the unmodified vis dataset is shared, if &quot;all&quot; we</span>
<span class="sd">        modify in place and return the input container.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">share</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">enum</span><span class="p">([</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;vis&quot;</span><span class="p">,</span> <span class="s2">&quot;map&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">TimeStream</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">BaselineMask</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">TimeStream</span><span class="p">:</span> <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealStream</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealBaselineMask</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealStream</span><span class="p">:</span> <span class="o">...</span>

<div class="viewcode-block" id="ApplyBaselineMask.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.ApplyBaselineMask.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Flag data by zeroing the weights.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data</span>
<span class="sd">            Data to apply mask to. Must have a stack axis</span>
<span class="sd">        mask</span>
<span class="sd">            A baseline-dependent mask</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data</span>
<span class="sd">            The masked data. Masking is done in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">containers</span><span class="o">.</span><span class="n">BaselineMask</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected a timestream-like type. Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">mask</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span>
                <span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">mask</span><span class="o">.</span><span class="n">time</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;timestream and mask have different time axes.&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealBaselineMask</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;ra&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Expected a sidereal stream like type. Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">ra</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">mask</span><span class="o">.</span><span class="n">ra</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">ra</span><span class="p">,</span> <span class="n">mask</span><span class="o">.</span><span class="n">ra</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sidereal stream and mask have different RA axes.&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Require a BaselineMask or SiderealBaselineMask. Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Validate remaining axes</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">stack</span><span class="p">,</span> <span class="n">mask</span><span class="o">.</span><span class="n">stack</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;data and mask have different baseline axes.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">freq</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">mask</span><span class="o">.</span><span class="n">freq</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span>
            <span class="n">data</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="n">mask</span><span class="o">.</span><span class="n">freq</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;data and mask have different freq axes.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">share</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">tsc</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">share</span> <span class="o">==</span> <span class="s2">&quot;vis&quot;</span><span class="p">:</span>
            <span class="n">tsc</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">shared</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;vis&quot;</span><span class="p">,))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">share</span> <span class="o">==</span> <span class="s2">&quot;map&quot;</span><span class="p">:</span>
            <span class="n">tsc</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">shared</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;map&quot;</span><span class="p">,))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tsc</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">tsc</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">*=</span> <span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="o">.</span><span class="n">mask</span><span class="p">[:])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tsc</span></div>
</div>



<div class="viewcode-block" id="MaskFreq">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.MaskFreq">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MaskFreq</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make a mask for certain frequencies.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    bad_freq_ind : list, optional</span>
<span class="sd">        A list containing frequencies to flag out. Each entry can either be an</span>
<span class="sd">        integer giving an individual frequency index to remove, or 2-tuples giving</span>
<span class="sd">        start and end indices of a range to flag (as with a standard slice, the end</span>
<span class="sd">        is *not* included.)</span>
<span class="sd">    factorize : bool, optional</span>
<span class="sd">        Find the smallest factorizable mask of the time-frequency axis that covers all</span>
<span class="sd">        samples already flagged in the data.</span>
<span class="sd">    all_time : bool, optional</span>
<span class="sd">        Only include frequencies where all time samples are present.</span>
<span class="sd">    mask_missing_data : bool, optional</span>
<span class="sd">        Mask time-freq samples where some baselines (for visibily data) or</span>
<span class="sd">        polarisations/elevations (for ring map data) are missing.</span>
<span class="sd">    freq_frac : float, optional</span>
<span class="sd">        Fully mask any frequency where the fraction of unflagged samples</span>
<span class="sd">        is less than this value. Default is None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bad_freq_ind</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">factorize</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">all_time</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">mask_missing_data</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">freq_frac</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

<div class="viewcode-block" id="MaskFreq.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.MaskFreq.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">VisContainer</span> <span class="o">|</span> <span class="n">containers</span><span class="o">.</span><span class="n">RingMap</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">RFIMask</span> <span class="o">|</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealRFIMask</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make the mask.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data</span>
<span class="sd">            The data to mask.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask_cont</span>
<span class="sd">            Frequency mask container</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">maskcls</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">containers</span><span class="o">.</span><span class="n">SiderealRFIMask</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealContainer</span><span class="p">)</span>
            <span class="k">else</span> <span class="n">containers</span><span class="o">.</span><span class="n">RFIMask</span>
        <span class="p">)</span>
        <span class="n">maskcont</span> <span class="o">=</span> <span class="n">maskcls</span><span class="p">(</span><span class="n">axes_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">attrs_from</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">maskcont</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span>

        <span class="c1"># Get the total number of amount of data for each freq-time. This is used to</span>
        <span class="c1"># create an initial mask.</span>
        <span class="n">waxes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span>
        <span class="n">axis_sum</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">[</span><span class="n">ii</span> <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">waxes</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;ra&quot;</span><span class="p">]]</span>
        <span class="p">)</span>
        <span class="n">axis_dist</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">waxes</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;ra&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">present_data</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span>
            <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis_sum</span><span class="p">),</span>
            <span class="n">comm</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis_dist</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">all_present_data</span> <span class="o">=</span> <span class="n">present_data</span><span class="o">.</span><span class="n">allgather</span><span class="p">()</span>
        <span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">all_present_data</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input data: </span><span class="si">{</span><span class="mf">100.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mask</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">% flagged.&quot;</span><span class="p">)</span>

        <span class="c1"># Create an initial mask of the freq-time space, where bad samples are</span>
        <span class="c1"># True. If `mask_missing_data` is set this masks any sample where the amount</span>
        <span class="c1"># of present data is less than the maximum, otherwise it is where all</span>
        <span class="c1"># data is missing</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_missing_data</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">all_present_data</span> <span class="o">&lt;</span> <span class="n">all_present_data</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Requiring all baselines: </span><span class="si">{</span><span class="mf">100.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mask</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">% flagged.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bad_freq_ind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nfreq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_freq_mask</span><span class="p">(</span><span class="n">nfreq</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Frequency mask: </span><span class="si">{</span><span class="mf">100.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mask</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">% flagged.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_frac</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">|=</span> <span class="n">mask</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_frac</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fractional mask: </span><span class="si">{</span><span class="mf">100.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mask</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">% flagged.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_time</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">|=</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;All time mask: </span><span class="si">{</span><span class="mf">100.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mask</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">% flagged.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">factorize</span><span class="p">:</span>
            <span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimal_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Factorizable mask: </span><span class="si">{</span><span class="mf">100.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mask</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">% flagged.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">maskcont</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_bad_freq_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nfreq</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># Parse the bad frequency list to create a per frequency mask</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bad_freq_ind</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">nfreq</span><span class="p">:</span>
                    <span class="n">mask</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Elements of `bad_freq_ind` must be integers or 2-tuples. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">mask</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_optimal_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># From the freq-time input mask, create the smallest factorizable mask that</span>
        <span class="c1"># covers all the original masked samples</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">minimize_scalar</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">genmask</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="c1"># Calculate a factorisable mask given the time masking threshold f</span>
            <span class="n">time_mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">f</span>
            <span class="n">freq_mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[:,</span> <span class="o">~</span><span class="n">time_mask</span><span class="p">]</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">time_mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">|</span> <span class="n">freq_mask</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">fmask</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="c1"># Calculate the total area masked given f</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">genmask</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Current value: </span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">m</span>

        <span class="c1"># Solve to find a value of f that minimises the amount of data masked</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">minimize_scalar</span><span class="p">(</span>
            <span class="n">fun</span><span class="o">=</span><span class="n">fmask</span><span class="p">,</span>
            <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;bounded&quot;</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;maxiter&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;xatol&quot;</span><span class="p">:</span> <span class="mf">1e-4</span><span class="p">},</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">res</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Optimisation did not converge, but this isn&#39;t unexpected.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">genmask</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">)</span></div>



<div class="viewcode-block" id="BlendStack">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.BlendStack">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BlendStack</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mix a small amount of a stack into data to regularise RFI gaps.</span>

<span class="sd">    This is designed to mix in a small amount of a stack into a day of data (which</span>
<span class="sd">    will have RFI masked gaps) to attempt to regularise operations which struggle to</span>
<span class="sd">    deal with time variable masks, e.g. `DelaySpectrumEstimator`.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    frac : float, optional</span>
<span class="sd">        The relative weight to give the stack in the average. This multiplies the</span>
<span class="sd">        weights already in the stack, and so it should be remembered that these may</span>
<span class="sd">        already be significantly higher than the single day weights.</span>
<span class="sd">    match_median : bool, optional</span>
<span class="sd">        Estimate the median in the time/RA direction from the common samples and use</span>
<span class="sd">        this to match any quasi time-independent bias of the data (e.g. cross talk).</span>
<span class="sd">    subtract : bool, optional</span>
<span class="sd">        Rather than taking an average, instead subtract out the blending stack</span>
<span class="sd">        from the input data in the common samples to calculate the difference</span>
<span class="sd">        between them. The interpretation of `frac` is a scaling of the inverse</span>
<span class="sd">        variance of the stack to an inverse variance of a prior on the</span>
<span class="sd">        difference, e.g. a `frac = 1e-4` means that we expect the standard</span>
<span class="sd">        deviation of the difference between the data and the stacked data to be</span>
<span class="sd">        100x larger than the noise of the stacked data.</span>
<span class="sd">    mask_freq : bool, optional</span>
<span class="sd">        Maintain masking if a frequency is entirely flagged - i.e., even if</span>
<span class="sd">        blending data exists in those bands, do not blend.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">frac</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span>
    <span class="n">match_median</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">subtract</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">mask_freq</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="BlendStack.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.BlendStack.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_stack</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the stacked data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_stack : SiderealStream, RingMap,or HybridVisStream</span>
<span class="sd">            Data stack to blend</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_stack</span> <span class="o">=</span> <span class="n">data_stack</span></div>


<div class="viewcode-block" id="BlendStack.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.BlendStack.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Blend a small amount of the stack into the incoming data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : SiderealStream, RingMap,or HybridVisStream</span>
<span class="sd">            The data to be blended into. This is modified in place.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data_blend : SiderealStream, RingMap,or HybridVisStream</span>
<span class="sd">            The modified data. This is the same object as the input, and it has been</span>
<span class="sd">            modified in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;effective_ra&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Blending uncorrected rebinned data not supported. &quot;</span>
                <span class="s2">&quot;Please apply a correction such as `sidereal.RebinGradientCorrection.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_stack</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;type(data) (=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">) must match&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;type(data_stack) (=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_stack</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">_supported_types</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">containers</span><span class="o">.</span><span class="n">SiderealStream</span><span class="p">,</span>
            <span class="n">containers</span><span class="o">.</span><span class="n">RingMap</span><span class="p">,</span>
            <span class="n">containers</span><span class="o">.</span><span class="n">HybridVisStream</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">_supported_types</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Only </span><span class="si">{</span><span class="n">_supported_types</span><span class="si">}</span><span class="s2"> are supported. Got data type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Try and get both the stack and the incoming data to have the same</span>
        <span class="c1"># distribution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_stack</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">dset_stack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_stack</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">dset</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="k">if</span> <span class="n">dset_stack</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">dset</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Size of data (</span><span class="si">{</span><span class="n">dset</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">) must match &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;data_stack (</span><span class="si">{</span><span class="n">dset_stack</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Add broadcast axes to the weight datasets</span>
        <span class="n">dax</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span>
        <span class="n">wax</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span>
        <span class="n">slobj</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">wax</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">dax</span><span class="p">])</span>

        <span class="n">weight_stack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_stack</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[</span><span class="n">slobj</span><span class="p">]</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[</span><span class="n">slobj</span><span class="p">]</span>

        <span class="c1"># Find the median offset between the stack and the daily data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_median</span><span class="p">:</span>
            <span class="c1"># Find the parts of the both the stack and the daily data that are both</span>
            <span class="c1"># measured</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">weight_stack</span><span class="p">[:]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

            <span class="c1"># Move the time-like axis to the end</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">dax</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;ra&quot;</span><span class="p">)</span>
            <span class="n">dss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">dset_stack</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">dset</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Broadcast the mask against the datasets</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">dss</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># Get the median of the real part of the data and the stack</span>
            <span class="n">stack_med_real</span> <span class="o">=</span> <span class="n">median</span><span class="o">.</span><span class="n">weighted_median</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">dss</span><span class="o">.</span><span class="n">real</span><span class="p">),</span> <span class="n">mask</span>
            <span class="p">)</span>
            <span class="c1"># Get the median of the data in the common subset</span>
            <span class="n">data_med_real</span> <span class="o">=</span> <span class="n">median</span><span class="o">.</span><span class="n">weighted_median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">real</span><span class="p">),</span> <span class="n">mask</span><span class="p">)</span>

            <span class="c1"># If the data is complex, get the complex component too</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">dss</span><span class="p">):</span>
                <span class="n">stack_med_imag</span> <span class="o">=</span> <span class="n">median</span><span class="o">.</span><span class="n">weighted_median</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">dss</span><span class="o">.</span><span class="n">imag</span><span class="p">),</span> <span class="n">mask</span>
                <span class="p">)</span>

                <span class="n">data_med_imag</span> <span class="o">=</span> <span class="n">median</span><span class="o">.</span><span class="n">weighted_median</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">imag</span><span class="p">),</span> <span class="n">mask</span>
                <span class="p">)</span>

            <span class="c1"># Construct an offset to match the medians in the time/RA direction</span>
            <span class="n">stack_offset</span> <span class="o">=</span> <span class="n">data_med_real</span> <span class="o">-</span> <span class="n">stack_med_real</span>

            <span class="c1"># Add the complex component if it exists</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">dss</span><span class="p">):</span>
                <span class="n">stack_offset</span> <span class="o">=</span> <span class="n">stack_offset</span> <span class="o">+</span> <span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="p">(</span><span class="n">data_med_imag</span> <span class="o">-</span> <span class="n">stack_med_imag</span><span class="p">)</span>

            <span class="c1"># Move the axes back</span>
            <span class="n">stack_offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">stack_offset</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">stack_offset</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_freq</span><span class="p">:</span>
            <span class="c1"># Collapse the frequency selection over other axes</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">ii</span> <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dax</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="o">!=</span> <span class="s2">&quot;freq&quot;</span><span class="p">))</span>
            <span class="n">fsel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Apply the frequency selection to the stacked weights</span>
            <span class="n">weight_stack</span> <span class="o">*=</span> <span class="n">fsel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtract</span><span class="p">:</span>
            <span class="c1"># Subtract the base stack where data is present, otherwise give zeros</span>

            <span class="n">dset</span> <span class="o">-=</span> <span class="n">dset_stack</span> <span class="o">+</span> <span class="n">stack_offset</span>
            <span class="n">dset</span> <span class="o">*=</span> <span class="p">(</span><span class="n">weight</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

            <span class="c1"># This sets the weights where weight == 0 to frac * weight_stack,</span>
            <span class="c1"># otherwise weight is the sum of the variances. It&#39;s a bit obscure</span>
            <span class="c1"># because it attempts to do the operations in place rather than</span>
            <span class="c1"># building many temporaries</span>
            <span class="n">weight</span> <span class="o">*=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">weight</span> <span class="o">+</span> <span class="n">weight_stack</span><span class="p">)</span>
            <span class="n">weight</span> <span class="o">+=</span> <span class="p">(</span><span class="n">weight</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">frac</span>
            <span class="n">weight</span> <span class="o">*=</span> <span class="n">weight_stack</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Perform a weighted average of the data to fill in missing samples</span>
            <span class="n">dset</span> <span class="o">*=</span> <span class="n">weight</span>
            <span class="n">dset</span> <span class="o">+=</span> <span class="n">weight_stack</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">frac</span> <span class="o">*</span> <span class="p">(</span><span class="n">dset_stack</span> <span class="o">+</span> <span class="n">stack_offset</span><span class="p">)</span>
            <span class="n">weight</span> <span class="o">+=</span> <span class="n">weight_stack</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">frac</span>

            <span class="n">dset</span> <span class="o">*=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span></div>
</div>



<span class="c1"># This is here for compatibility</span>
<span class="n">ApplyRFIMask</span> <span class="o">=</span> <span class="n">ApplyTimeFreqMask</span>
<span class="n">MaskData</span> <span class="o">=</span> <span class="n">MaskMModeData</span>


<div class="viewcode-block" id="mad">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.mad">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mad</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">base_size</span><span class="o">=</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">mad_size</span><span class="o">=</span><span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="mi">21</span><span class="p">),</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the MAD of freq-time data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : np.ndarray</span>
<span class="sd">        Data to filter.</span>
<span class="sd">    mask : np.ndarray</span>
<span class="sd">        Initial mask.</span>
<span class="sd">    base_size : tuple</span>
<span class="sd">        Size of the window to use in (freq, time) when</span>
<span class="sd">        estimating the baseline.</span>
<span class="sd">    mad_size : tuple</span>
<span class="sd">        Size of the window to use in (freq, time) when</span>
<span class="sd">        estimating the MAD.</span>
<span class="sd">    debug : bool, optional</span>
<span class="sd">        If True, return deviation and mad arrays as well</span>
<span class="sd">    sigma : bool, optional</span>
<span class="sd">        Rescale the output into units of Gaussian sigmas.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mad : np.ndarray</span>
<span class="sd">        Size of deviation at each point in MAD units. This output may contain</span>
<span class="sd">        NaN&#39;s for regions of missing data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xs</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">medfilt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">base_size</span><span class="p">)</span>
    <span class="n">dev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">xs</span><span class="p">)</span>

    <span class="n">mad</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">medfilt</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">mad_size</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sigma</span><span class="p">:</span>
        <span class="n">mad</span> <span class="o">*=</span> <span class="mf">1.4826</span>  <span class="c1"># apply the conversion from MAD-&gt;sigma</span>

    <span class="c1"># Suppress warnings about NaNs produced during the division</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">dev</span> <span class="o">/</span> <span class="n">mad</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">mad</span>
    <span class="k">return</span> <span class="n">r</span></div>



<div class="viewcode-block" id="inverse_binom_cdf_prob">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.inverse_binom_cdf_prob">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">inverse_binom_cdf_prob</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">F</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the trial probability that gives the CDF.</span>

<span class="sd">    This gets the trial probability that gives an overall cumulative</span>
<span class="sd">    probability for Pr(X &lt;= k; N, p) = F</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    k : int</span>
<span class="sd">        Maximum number of successes.</span>
<span class="sd">    N : int</span>
<span class="sd">        Total number of trials.</span>
<span class="sd">    F : float</span>
<span class="sd">        The cumulative probability for (k, N).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    p : float</span>
<span class="sd">        The trial probability.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This uses the result that we can write the cumulative probability of a</span>
    <span class="c1"># binomial in terms of an incomplete beta function</span>

    <span class="kn">import</span><span class="w"> </span><span class="nn">scipy.special</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

    <span class="k">return</span> <span class="n">sp</span><span class="o">.</span><span class="n">betaincinv</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="n">k</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">F</span><span class="p">)</span></div>



<div class="viewcode-block" id="sigma_to_p">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.sigma_to_p">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sigma_to_p</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the probability of an excursion larger than sigma for a Gaussian.&quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ss</span>

    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ss</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span></div>



<div class="viewcode-block" id="p_to_sigma">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.p_to_sigma">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">p_to_sigma</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the sigma exceeded by the tails of a Gaussian with probability p.&quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ss</span>

    <span class="k">return</span> <span class="n">ss</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">isf</span><span class="p">(</span><span class="n">p</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span></div>



<div class="viewcode-block" id="tv_channels_flag">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.tv_channels_flag">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">tv_channels_flag</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform a higher sensitivity flagging for the TV stations.</span>

<span class="sd">    This flags a whole TV station band if more than fraction f of the samples</span>
<span class="sd">    within a station band exceed a given threshold. The threshold is calculated</span>
<span class="sd">    by wanting a fixed false positive rate (as described by sigma) for fraction</span>
<span class="sd">    f of samples exceeding the threshold</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : np.ndarray[freq, time]</span>
<span class="sd">        Deviations of data in sigma units.</span>
<span class="sd">    freq : np.ndarray[freq]</span>
<span class="sd">        Frequency of samples in MHz.</span>
<span class="sd">    sigma : float, optional</span>
<span class="sd">        The probability of a false positive given as a sigma of a Gaussian.</span>
<span class="sd">    f : float, optional</span>
<span class="sd">        Fraction of bad samples within each channel before flagging the whole</span>
<span class="sd">        thing.</span>
<span class="sd">    debug : bool, optional</span>
<span class="sd">        Returns (mask, fraction) instead to give extra debugging info.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mask : np.ndarray[bool]</span>
<span class="sd">        Mask of the input data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p_false</span> <span class="o">=</span> <span class="n">sigma_to_p</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
    <span class="n">frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">tvstart_freq</span> <span class="o">=</span> <span class="mi">398</span>
    <span class="n">tvwidth_freq</span> <span class="o">=</span> <span class="mi">6</span>

    <span class="c1"># Calculate the boundaries of each frequency channel</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">freq</span><span class="p">)))</span>
    <span class="n">freq_start</span> <span class="o">=</span> <span class="n">freq</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">df</span>
    <span class="n">freq_end</span> <span class="o">=</span> <span class="n">freq</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">df</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">67</span><span class="p">):</span>
        <span class="c1"># Find all frequencies that lie wholly or partially within the TV channel</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">tvstart_freq</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">tvwidth_freq</span>
        <span class="n">fe</span> <span class="o">=</span> <span class="n">fs</span> <span class="o">+</span> <span class="n">tvwidth_freq</span>
        <span class="n">sel</span> <span class="o">=</span> <span class="p">(</span><span class="n">freq_end</span> <span class="o">&gt;=</span> <span class="n">fs</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">freq_start</span> <span class="o">&lt;=</span> <span class="n">fe</span><span class="p">)</span>

        <span class="c1"># Don&#39;t continue processing channels for which we don&#39;t have</span>
        <span class="c1"># frequencies in the incoming data</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sel</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">continue</span>

        <span class="c1"># Calculate the threshold to apply</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">sel</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span>

        <span class="c1"># This is the Gaussian threshold required for there to be at most a p_false</span>
        <span class="c1"># chance of more than k trials exceeding the threshold. This is the correct</span>
        <span class="c1"># expression, and has been double checked by numerical trials.</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">p_to_sigma</span><span class="p">(</span><span class="n">inverse_binom_cdf_prob</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">p_false</span><span class="p">))</span>

        <span class="n">frac</span><span class="p">[</span><span class="n">sel</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">sel</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="n">frac</span> <span class="o">&gt;</span> <span class="n">f</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mask</span><span class="p">,</span> <span class="n">frac</span>

    <span class="k">return</span> <span class="n">mask</span></div>



<div class="viewcode-block" id="complex_med">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.complex_med">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">complex_med</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Complex median, done by applying to the real/imag parts individually.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : np.ndarray</span>
<span class="sd">        Array to apply to.</span>
<span class="sd">    *args, **kwargs : list, dict</span>
<span class="sd">        Passed straight through to `np.nanmedian`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    m : np.ndarray</span>
<span class="sd">        Median.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span>
        <span class="n">x</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="destripe">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.destripe">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">destripe</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subtract the median along a specified axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : np.ndarray</span>
<span class="sd">        Array to destripe.</span>
<span class="sd">    w : np.ndarray</span>
<span class="sd">        Mask array for points to include (True) or ignore (False).</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis to apply destriping along.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : np.ndarray</span>
<span class="sd">        Destriped array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Calculate the average along the axis</span>
    <span class="n">stripe</span> <span class="o">=</span> <span class="n">complex_med</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">stripe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">stripe</span><span class="p">)</span>

    <span class="c1"># Construct a slice to broadcast back along the axis</span>
    <span class="n">bsel</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">bsel</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">bsel</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">bsel</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="n">stripe</span><span class="p">[</span><span class="n">bsel</span><span class="p">]</span></div>



<div class="viewcode-block" id="RFIMaskSiderealRegridderNearest">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RFIMaskSiderealRegridderNearest">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RFIMaskSiderealRegridderNearest</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert the axis of an RFI mask from time to ra.</span>

<span class="sd">    The conversion is performed by mapping values between Unix time and LSA</span>
<span class="sd">    using the geographic location of the telescope, as provided by the Observer object.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    spread_factor : float</span>
<span class="sd">        Spreading width in RA bins for conservative flagging. Default is 1.0.</span>
<span class="sd">    npix : int</span>
<span class="sd">        The number of pixels used to cover the full RA range from 0 to 360. Defualt is 4096.</span>
<span class="sd">    single_CSD : bool</span>
<span class="sd">        Whether to extract only the main CSD from the input time stream. If True, only the region</span>
<span class="sd">        between the first occurrence of RA=0 and the second occurrence of RA=360 will be kept.</span>
<span class="sd">        Values outside this window will be excluded from interpolation. Default is True.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">spread_factor</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">npix</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">4096</span><span class="p">)</span>
    <span class="n">single_CSD</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="RFIMaskSiderealRegridderNearest.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RFIMaskSiderealRegridderNearest.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">manager</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the local observers position.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        manager :</span>
<span class="sd">            An Observer object holding the geographic location of the telescope.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observer</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">get_telescope</span><span class="p">(</span><span class="n">manager</span><span class="p">)</span></div>


<div class="viewcode-block" id="RFIMaskSiderealRegridderNearest.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RFIMaskSiderealRegridderNearest.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rfimask</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert time axis to RA axis using LSA mapping.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rfimask : containers.LocalizedRFIMask or containers.RFIMask</span>
<span class="sd">            Input mask with axes (freq, el, time) or (freq, time).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : containers.LocalizedSiderealRFIMask or containers.SiderealRFIMask</span>
<span class="sd">            Output mask with axes (freq, ra, el) or (freq, ra).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rfimask</span><span class="p">,</span> <span class="n">containers</span><span class="o">.</span><span class="n">LocalizedRFIMask</span><span class="p">):</span>
            <span class="n">to_type</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">LocalizedSiderealRFIMask</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rfimask</span><span class="p">,</span> <span class="n">containers</span><span class="o">.</span><span class="n">RFIMask</span><span class="p">):</span>
            <span class="n">to_type</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealRFIMask</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expected LocalizedSiderealRFIMask or SiderealRFIMask input. Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">rfimask</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="n">from_ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observer</span><span class="o">.</span><span class="n">unix_to_lsa</span><span class="p">(</span><span class="n">rfimask</span><span class="o">.</span><span class="n">time</span><span class="p">[:])</span>

        <span class="c1"># If needed, trim the input rfimask to a single CSD</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_CSD</span><span class="p">:</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">from_ax</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diff</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not find a complete CSD in the input.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Found more than one CSD in the input.&quot;</span><span class="p">)</span>

            <span class="n">start</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># Mark values outside this region as invalid (-1)</span>
            <span class="n">from_ax</span><span class="p">[:</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">from_ax</span><span class="p">[</span><span class="n">end</span><span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">return</span> <span class="n">_convert_axis_nearest_interpolation</span><span class="p">(</span>
            <span class="n">stream</span><span class="o">=</span><span class="n">rfimask</span><span class="p">,</span>
            <span class="n">to_type</span><span class="o">=</span><span class="n">to_type</span><span class="p">,</span>
            <span class="n">from_ax_name</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">,</span>
            <span class="n">to_ax_name</span><span class="o">=</span><span class="s2">&quot;ra&quot;</span><span class="p">,</span>
            <span class="n">from_ax</span><span class="o">=</span><span class="n">from_ax</span><span class="p">,</span>
            <span class="n">to_ax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="n">spread_factor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spread_factor</span><span class="p">,</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="RFIMaskTimeRegridderNearest">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RFIMaskTimeRegridderNearest">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RFIMaskTimeRegridderNearest</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Align the time axis of an input container to a target stream.</span>

<span class="sd">    This task adjusts the time axis of an RFI mask to match the time axis of</span>
<span class="sd">    a target dataset such as a TimeStream or SystemSensitivity, using nearest interpolation.</span>
<span class="sd">    This is useful when the original mask and the target data stream do not have exactly</span>
<span class="sd">    matching time axes.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    spread_factor : float</span>
<span class="sd">        Width of conservative flagging window in time resolution units. Default is 1.0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">spread_factor</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>

<div class="viewcode-block" id="RFIMaskTimeRegridderNearest.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RFIMaskTimeRegridderNearest.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tstream</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the reference time axis from the target stream.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tstream : containers.TimeStream, SystemSensitivity, etc.</span>
<span class="sd">            A time-like data container that provides the target time axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_time</span> <span class="o">=</span> <span class="n">tstream</span><span class="o">.</span><span class="n">time</span><span class="p">[:]</span>
        <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expected a time-like stream for reference time. Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">tstream</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">exc</span></div>


<div class="viewcode-block" id="RFIMaskTimeRegridderNearest.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.RFIMaskTimeRegridderNearest.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rfimask</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply time alignment to the input RFI mask.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rfimask : containers.RFIMask or containers.LocalizedRFIMask</span>
<span class="sd">            Input RFI mask with original time axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : same type as input</span>
<span class="sd">            RFI mask with time axis matched to the target.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_convert_axis_nearest_interpolation</span><span class="p">(</span>
            <span class="n">stream</span><span class="o">=</span><span class="n">rfimask</span><span class="p">,</span>
            <span class="n">to_type</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">rfimask</span><span class="p">),</span>
            <span class="n">from_ax_name</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">,</span>
            <span class="n">to_ax_name</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">,</span>
            <span class="n">from_ax</span><span class="o">=</span><span class="n">rfimask</span><span class="o">.</span><span class="n">time</span><span class="p">[:],</span>
            <span class="n">to_ax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">target_time</span><span class="p">[:],</span>
            <span class="n">spread_factor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spread_factor</span><span class="p">,</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="ReduceMaskEl">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.ReduceMaskEl">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ReduceMaskEl</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reduce the &#39;el&#39; axis from input classes and produce corresponding reduced output classes.</span>

<span class="sd">    Reduction algorithm: If the number of True values in the mask along the el axis</span>
<span class="sd">    is higher than a given threshold, set the mask to True.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    el_threshold : int</span>
<span class="sd">    This number determines the minimum number of detected RFI events along the el axis required for a data point</span>
<span class="sd">    to be included in the reduced mask. Default is 1.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">el_threshold</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="ReduceMaskEl.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.ReduceMaskEl.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rfimask</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Produce a RFI mask.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rfimask : containers.LocalizedRFIMask(freq, el, time) or containers.SiderealLocalizedRFIMask(freq, ra, el)</span>
<span class="sd">            El-specific RFI mask indicating channels that are free from RFI events.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : containers.RFIMask(freq, time) or containers.SiderealRFIMask(freq, ra)</span>
<span class="sd">            Non el-specific RFI mask indicating channels that are free from RFI events.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validate inpput class</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rfimask</span><span class="p">,</span> <span class="n">containers</span><span class="o">.</span><span class="n">LocalizedRFIMask</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rfimask</span><span class="p">,</span> <span class="n">containers</span><span class="o">.</span><span class="n">LocalizedSiderealRFIMask</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Input class must be LocalizedRFIMask or LocalizedSiderealRFIMask. Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">rfimask</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Extract mask/frac and axes data</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">rfimask</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span>
        <span class="n">el_axis</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rfimask</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;el&quot;</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">rfimask</span><span class="o">.</span><span class="n">freq</span><span class="p">[:]</span>

        <span class="c1"># Apply reduction condition</span>
        <span class="n">reduced_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">el_axis</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">el_threshold</span>

        <span class="c1"># Determine output class type</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rfimask</span><span class="p">,</span> <span class="n">containers</span><span class="o">.</span><span class="n">LocalizedRFIMask</span><span class="p">):</span>
            <span class="c1"># LocalizedRFIMask(freq, el, time) -&gt; RFIMask(freq, time)</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">rfimask</span><span class="o">.</span><span class="n">time</span><span class="p">[:]</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">RFIMask</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rfimask</span><span class="p">,</span> <span class="n">containers</span><span class="o">.</span><span class="n">LocalizedSiderealRFIMask</span><span class="p">):</span>
            <span class="c1"># LocalizedSiderealRFIMask(freq, ra, el)  -&gt; SiderealRFIMask(freq, ra)</span>
            <span class="n">ra</span> <span class="o">=</span> <span class="n">rfimask</span><span class="o">.</span><span class="n">ra</span><span class="p">[:]</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealRFIMask</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">ra</span><span class="o">=</span><span class="n">ra</span><span class="p">)</span>

        <span class="c1"># The output RFI mask is not frequency distributed</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">reduced_mask</span>
        <span class="n">arrdist</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">final_mask</span> <span class="o">=</span> <span class="n">arrdist</span><span class="o">.</span><span class="n">allgather</span><span class="p">()</span>

        <span class="n">output</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">final_mask</span>

        <span class="c1"># Return output container</span>
        <span class="k">return</span> <span class="n">output</span></div>
</div>



<div class="viewcode-block" id="ApplyLocalizedRFIMask">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.ApplyLocalizedRFIMask">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ApplyLocalizedRFIMask</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply a localised (el-sensitive) RFI mask to the data by zeroing the weights.</span>

<span class="sd">    This class extends the class ApplyTimeFreqMask to include el in addition to freq and ra,</span>
<span class="sd">    and can be further extended for a new RingMap class (freq,el,time).</span>
<span class="sd">    Note that while the ra and el axes of the tstream and mask datasets do not need to be identical,</span>
<span class="sd">    they must have overlapping regions. However, their freq axes must be identical.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    share : {&quot;all&quot;, &quot;none&quot;, &quot;map&quot;}</span>
<span class="sd">        Which datasets should we share with the input. If &quot;none&quot; we create a</span>
<span class="sd">        full copy of the data, if &quot;map&quot; we create a copy only of the modified</span>
<span class="sd">        weight dataset and the unmodified vis dataset is shared, if &quot;all&quot; we</span>
<span class="sd">        modify in place and return the input container.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">share</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">enum</span><span class="p">([</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;map&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="ApplyLocalizedRFIMask.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.flagging.html#draco.analysis.flagging.ApplyLocalizedRFIMask.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tstream</span><span class="p">,</span> <span class="n">rfimask</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply the mask by zeroing the weights.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tstream : containers.RingMap</span>
<span class="sd">            A data container with axes (pol, freq, ra, el).</span>
<span class="sd">        rfimask : containers.LocalizedSiderealRFIMask(freq, ra, el)</span>
<span class="sd">            An RFI mask with overlapping freq, ra and el regions with the tstream, containers.RingMap.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tstream : containers.RingMap</span>
<span class="sd">            The masked RingMap with weights modified in overlapping regions. Note that the masking is done in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validate axes</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tstream</span><span class="p">,</span> <span class="n">containers</span><span class="o">.</span><span class="n">RingMap</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Require a containers.RingMap. Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">tstream</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rfimask</span><span class="p">,</span> <span class="n">containers</span><span class="o">.</span><span class="n">LocalizedSiderealRFIMask</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Require a LocalizedSiderealRFIMask. Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">rfimask</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="c1"># Validate the frequency axis</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">tstream</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="n">rfimask</span><span class="o">.</span><span class="n">freq</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;timestream and mask data have different freq axes.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">share</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">tsc</span> <span class="o">=</span> <span class="n">tstream</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">share</span> <span class="o">==</span> <span class="s2">&quot;map&quot;</span><span class="p">:</span>
            <span class="n">tsc</span> <span class="o">=</span> <span class="n">tstream</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">shared</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;map&quot;</span><span class="p">,))</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># &quot;none&quot;</span>
            <span class="n">tsc</span> <span class="o">=</span> <span class="n">tstream</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Ensure we are frequency distributed</span>
        <span class="n">tstream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Get mask data and shape data</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">rfimask</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="n">nfreq</span><span class="p">,</span> <span class="n">nra</span><span class="p">,</span> <span class="n">nel</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">npol</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">tstream</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Find the overlapping indices for ra and el</span>
        <span class="n">ra_overlap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">tstream</span><span class="o">.</span><span class="n">ra</span><span class="p">,</span> <span class="n">rfimask</span><span class="o">.</span><span class="n">ra</span><span class="p">,</span> <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">el_overlap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">tstream</span><span class="o">.</span><span class="n">el</span><span class="p">,</span> <span class="n">rfimask</span><span class="o">.</span><span class="n">el</span><span class="p">,</span> <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Validate that there are overlapping regions</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ra_overlap</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No overlapping ra regions found.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">el_overlap</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No overlapping el regions found.&quot;</span><span class="p">)</span>

        <span class="c1"># Get the indices corresponding to the overlapping regions</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">t_ra_index</span><span class="p">,</span> <span class="n">m_ra_index</span> <span class="o">=</span> <span class="n">ra_overlap</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">t_el_index</span><span class="p">,</span> <span class="n">m_el_index</span> <span class="o">=</span> <span class="n">el_overlap</span>

        <span class="c1"># Create the pol and freq axes</span>
        <span class="n">t_pol_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">npol</span><span class="p">)</span>
        <span class="n">tm_freq_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nfreq</span><span class="p">)</span>

        <span class="c1"># Reshape the mask to include a singleton polarization dimension</span>
        <span class="c1"># This ensures compatibility with the weight array, which includes a polarization axis</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nfreq</span><span class="p">,</span> <span class="n">nra</span><span class="p">,</span> <span class="n">nel</span><span class="p">)</span>

        <span class="c1"># Mask the data.</span>
        <span class="n">tsc</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">t_pol_index</span><span class="p">,</span> <span class="n">tm_freq_index</span><span class="p">,</span> <span class="n">t_ra_index</span><span class="p">,</span> <span class="n">t_el_index</span><span class="p">)</span>
        <span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">tm_freq_index</span><span class="p">,</span> <span class="n">m_ra_index</span><span class="p">,</span> <span class="n">m_el_index</span><span class="p">)])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">tsc</span></div>
</div>



<span class="k">def</span><span class="w"> </span><span class="nf">_convert_axis_nearest_interpolation</span><span class="p">(</span>
    <span class="n">stream</span><span class="p">,</span> <span class="n">to_type</span><span class="p">,</span> <span class="n">from_ax_name</span><span class="p">,</span> <span class="n">to_ax_name</span><span class="p">,</span> <span class="n">from_ax</span><span class="p">,</span> <span class="n">to_ax</span><span class="p">,</span> <span class="n">spread_factor</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generic axis conversion using nearest-neighbor interpolation.</span>

<span class="sd">    This function converts one axis of a data container from &#39;from_ax_name&#39;</span>
<span class="sd">    to &#39;to_ax_name&#39; by re-mapping dataset values onto a new target axis.</span>
<span class="sd">    It uses nearest-neighbor interpolation to associate the new axis bins</span>
<span class="sd">    with the closest original data points. Additionally, it can apply a</span>
<span class="sd">    conservative spreading window, where flagged or elevated samples</span>
<span class="sd">    spread to nearby bins within a distance determined by &#39;spread_factor&#39;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    stream : ContainerPrototype</span>
<span class="sd">        The input container holding the original data and axis.</span>
<span class="sd">        Example: LocalizedRFIMask with axes (freq, time, el).</span>
<span class="sd">    to_type : type</span>
<span class="sd">        The class of the output container to produce.</span>
<span class="sd">        Example: LocalizedSiderealRFIMask with axes (freq, el, ra).</span>
<span class="sd">    from_ax_name : str</span>
<span class="sd">        The name of the axis in the input container to convert from.</span>
<span class="sd">        Example: &#39;time&#39;.</span>
<span class="sd">    to_ax_name : str</span>
<span class="sd">        The name of the target axis to convert to.</span>
<span class="sd">        Example: &#39;ra&#39;.</span>
<span class="sd">    from_ax : np.ndarray</span>
<span class="sd">        The array of converted input axis values (e.g., times converted to RA).</span>
<span class="sd">        This defines how the existing data aligns with the new axis.</span>
<span class="sd">    to_ax : np.ndarray</span>
<span class="sd">        The target axis values of the output data.</span>
<span class="sd">    spread_factor : float</span>
<span class="sd">        The width of the conservative spreading window in units of the input axis</span>
<span class="sd">        resolution. If the axes match exactly, spreading is disabled.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ContainerPrototype</span>
<span class="sd">        A new container of type `to_type` with converted axes and interpolated datasets.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Boolean datasets are propagated conservatively using a logical OR</span>
<span class="sd">      across the spreading window.</span>
<span class="sd">    - Numerical datasets are averaged over the spreading window,</span>
<span class="sd">      preserving fractional quantities (e.g., fractional RFI occupancy).</span>
<span class="sd">    - If `spread_factor` is zero or the input/output axes match exactly,</span>
<span class="sd">      only pure nearest-neighbor interpolation is performed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Estimate resolutions to determine mapping strategy</span>
    <span class="n">new_resolution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">to_ax</span><span class="p">)))</span>
    <span class="n">from_resolution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">from_ax</span><span class="p">)))</span>

    <span class="c1"># Determine nearest-neighbor indices for mapping</span>
    <span class="k">if</span> <span class="n">new_resolution</span> <span class="o">&lt;</span> <span class="n">from_resolution</span><span class="p">:</span>
        <span class="n">nearest_indices</span> <span class="o">=</span> <span class="n">_search_nearest</span><span class="p">(</span><span class="n">from_ax</span><span class="p">,</span> <span class="n">to_ax</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nearest_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">from_ax</span><span class="p">))</span>

    <span class="c1"># Compute pairwise distances between each new axis point and nearest from_ax points</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span>
        <span class="n">to_ax</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">from_ax</span><span class="p">[</span><span class="n">nearest_indices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span>
    <span class="p">)</span>

    <span class="c1"># Disable spreading if axes align exactly (diagonal distance is zero)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">spread_factor</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Setting &#39;spread_factor = 0&#39; because axes are aligned exactly&quot;</span><span class="p">)</span>

    <span class="c1"># Construct conservative spreading window</span>
    <span class="n">resolution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">from_ax</span><span class="p">)))</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">spread_factor</span> <span class="o">*</span> <span class="n">resolution</span>

    <span class="c1"># Create output container with converted axis values</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">to_ax_name</span> <span class="k">if</span> <span class="n">ax</span> <span class="o">==</span> <span class="n">from_ax_name</span> <span class="k">else</span> <span class="n">ax</span><span class="p">):</span> <span class="p">(</span>
            <span class="n">to_ax</span> <span class="k">if</span> <span class="n">ax</span> <span class="o">==</span> <span class="n">from_ax_name</span> <span class="k">else</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">stream</span><span class="o">.</span><span class="n">axes</span>
    <span class="p">}</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">to_type</span><span class="p">(</span><span class="o">**</span><span class="n">axes</span><span class="p">,</span> <span class="n">attrs_from</span><span class="o">=</span><span class="n">stream</span><span class="p">)</span>

    <span class="c1"># Interpolate each dataset in the container</span>
    <span class="k">for</span> <span class="n">dname</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">datasets</span><span class="p">):</span>
        <span class="c1"># Extract dataset and bring from_ax to the front</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">dname</span><span class="p">)[:])</span>
        <span class="n">ax_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">dname</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">from_ax_name</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ax_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Interpolation based on data type</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">:</span>
            <span class="c1"># Boolean datasets: use OR over spreading window</span>
            <span class="n">converted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">nearest_indices</span><span class="p">],</span> <span class="n">axes</span><span class="o">=</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Numerical datasets: compute weighted average over the spreading window</span>
            <span class="n">window</span> <span class="o">=</span> <span class="n">window</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">numerator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">nearest_indices</span><span class="p">],</span> <span class="n">axes</span><span class="o">=</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">denominator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">numerator</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">converted</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">denominator</span><span class="p">)</span>

        <span class="c1"># Create dataset in the output container if not present</span>
        <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dname</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="n">dname</span><span class="p">)</span>

        <span class="c1"># Move converted axis back to appropariate location</span>
        <span class="n">ax_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dname</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">to_ax_name</span><span class="p">)</span>
        <span class="n">converted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">converted</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ax_idx</span><span class="p">)</span>

        <span class="c1"># Store converted dataset</span>
        <span class="n">out</span><span class="p">[</span><span class="n">dname</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">converted</span>

    <span class="c1"># Return output container</span>
    <span class="k">return</span> <span class="n">out</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016, Richard Shaw.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>