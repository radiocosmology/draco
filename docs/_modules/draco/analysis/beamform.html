

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>draco.analysis.beamform &mdash; draco 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=9edc463e" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            draco
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev.html">Development Guidelines</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">draco</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">draco.analysis.beamform</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for draco.analysis.beamform</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Beamform visibilities to the location of known sources.&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">healpy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.interpolate</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">caput</span><span class="w"> </span><span class="kn">import</span> <span class="n">config</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">caput.astro</span><span class="w"> </span><span class="kn">import</span> <span class="n">constants</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">caput.astro</span><span class="w"> </span><span class="kn">import</span> <span class="n">skyfield</span> <span class="k">as</span> <span class="n">skf</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">caput.astro</span><span class="w"> </span><span class="kn">import</span> <span class="n">time</span> <span class="k">as</span> <span class="n">ctime</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">caput.pipeline</span><span class="w"> </span><span class="kn">import</span> <span class="n">tasklib</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">skyfield.api</span><span class="w"> </span><span class="kn">import</span> <span class="n">Angle</span><span class="p">,</span> <span class="n">Star</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">draco.analysis.sidereal</span><span class="w"> </span><span class="kn">import</span> <span class="n">_search_nearest</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">..core</span><span class="w"> </span><span class="kn">import</span> <span class="n">containers</span><span class="p">,</span> <span class="n">io</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..util</span><span class="w"> </span><span class="kn">import</span> <span class="n">interferometry</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..util._fast_tools</span><span class="w"> </span><span class="kn">import</span> <span class="n">beamform</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..util.tools</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">baseline_vector</span><span class="p">,</span>
    <span class="n">calculate_redundancy</span><span class="p">,</span>
    <span class="n">correct_phase_wrap</span><span class="p">,</span>
    <span class="n">find_contiguous_slices</span><span class="p">,</span>
    <span class="n">invert_no_zero</span><span class="p">,</span>
    <span class="n">polarization_map</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># Constants</span>
<span class="n">NU21</span> <span class="o">=</span> <span class="n">constants</span><span class="o">.</span><span class="n">nu21</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">constants</span><span class="o">.</span><span class="n">c</span>


<div class="viewcode-block" id="BeamFormBase">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.BeamFormBase">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BeamFormBase</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for beam forming tasks.</span>

<span class="sd">    Defines a few useful methods. Not to be used directly</span>
<span class="sd">    but as parent class for BeamForm and BeamFormCat.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    collapse_ha : bool</span>
<span class="sd">        Sum over hour-angle/time to complete the beamforming. Default is True.</span>
<span class="sd">    polarization : string</span>
<span class="sd">        Determines the polarizations that will be output:</span>
<span class="sd">            - &#39;I&#39; : Stokes I only.</span>
<span class="sd">            - &#39;full&#39; : &#39;XX&#39;, &#39;XY&#39;, &#39;YX&#39; and &#39;YY&#39; in this order. (default)</span>
<span class="sd">            - &#39;copol&#39; : &#39;XX&#39; and &#39;YY&#39; only.</span>
<span class="sd">            - &#39;stokes&#39; : &#39;I&#39;, &#39;Q&#39;, &#39;U&#39; and &#39;V&#39; in this order. Not implemented.</span>
<span class="sd">    weight : string</span>
<span class="sd">        How to weight the redundant baselines when adding:</span>
<span class="sd">            - &#39;natural&#39; : each baseline weighted by its redundancy (default)</span>
<span class="sd">            - &#39;uniform&#39; : each baseline given equal weight</span>
<span class="sd">            - &#39;inverse_variance&#39; : each baseline weighted by the weight attribute</span>
<span class="sd">    no_beam_model : string</span>
<span class="sd">        Do not include a primary beam factor in the beamforming</span>
<span class="sd">        weights, i.e., use uniform weighting as a function of hour angle</span>
<span class="sd">        and declination.</span>
<span class="sd">    timetrack : float</span>
<span class="sd">        How long (in seconds) to track sources at each side of transit.</span>
<span class="sd">        Default is 900 seconds.  Total transit time will be 2 * timetrack.</span>
<span class="sd">    variable_timetrack : bool</span>
<span class="sd">        Scale the total time to track each source by the secant of the</span>
<span class="sd">        source declination, so that all sources are tracked through</span>
<span class="sd">        the same angle on the sky.  Default is False.</span>
<span class="sd">    freqside : int</span>
<span class="sd">        Number of frequencies to process at each side of the source.</span>
<span class="sd">        Default (None) processes all frequencies.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">collapse_ha</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">polarization</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">enum</span><span class="p">([</span><span class="s2">&quot;I&quot;</span><span class="p">,</span> <span class="s2">&quot;full&quot;</span><span class="p">,</span> <span class="s2">&quot;copol&quot;</span><span class="p">,</span> <span class="s2">&quot;stokes&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;full&quot;</span><span class="p">)</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">enum</span><span class="p">([</span><span class="s2">&quot;natural&quot;</span><span class="p">,</span> <span class="s2">&quot;uniform&quot;</span><span class="p">,</span> <span class="s2">&quot;inverse_variance&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;natural&quot;</span><span class="p">)</span>
    <span class="n">no_beam_model</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">timetrack</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">900.0</span><span class="p">)</span>
    <span class="n">variable_timetrack</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">freqside</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">data_available</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="BeamFormBase.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.BeamFormBase.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">manager</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generic setup method.</span>

<span class="sd">        To be complemented by specific setup methods in daughter tasks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        manager : either `ProductManager`, `BeamTransfer` or `TransitTelescope`</span>
<span class="sd">            Contains a TransitTelescope object describing the telescope.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the TransitTelescope object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">get_telescope</span><span class="p">(</span><span class="n">manager</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span>

        <span class="c1"># Polarizations.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span> <span class="o">==</span> <span class="s2">&quot;I&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_pol</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;XX&quot;</span><span class="p">,</span> <span class="s2">&quot;YY&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">return_pol</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;I&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span> <span class="o">==</span> <span class="s2">&quot;full&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_pol</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;XX&quot;</span><span class="p">,</span> <span class="s2">&quot;XY&quot;</span><span class="p">,</span> <span class="s2">&quot;YX&quot;</span><span class="p">,</span> <span class="s2">&quot;YY&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">return_pol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_pol</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span> <span class="o">==</span> <span class="s2">&quot;copol&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_pol</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;XX&quot;</span><span class="p">,</span> <span class="s2">&quot;YY&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">return_pol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_pol</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span> <span class="o">==</span> <span class="s2">&quot;stokes&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_pol</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;XX&quot;</span><span class="p">,</span> <span class="s2">&quot;XY&quot;</span><span class="p">,</span> <span class="s2">&quot;YX&quot;</span><span class="p">,</span> <span class="s2">&quot;YY&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">return_pol</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;I&quot;</span><span class="p">,</span> <span class="s2">&quot;Q&quot;</span><span class="p">,</span> <span class="s2">&quot;U&quot;</span><span class="p">,</span> <span class="s2">&quot;V&quot;</span><span class="p">]</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Stokes parameters are not implemented&quot;</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This should never happen. config.enum should bark first.</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Invalid polarization parameter: </span><span class="si">{0}</span><span class="s2">&quot;</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polarization</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">npol</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">process_pol</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">map_pol_feed</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">pstr</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">polarisation</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pstr</span><span class="p">)</span> <span class="k">for</span> <span class="n">pstr</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">]</span>
        <span class="p">}</span>

        <span class="c1"># Ensure that if we are using variable time tracking,</span>
        <span class="c1"># then we are also collapsing over hour angle.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_timetrack</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapse_ha</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot;Tracking source for declination dependent amount of time &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">timetrack</span><span class="si">:</span><span class="s2">0.0f</span><span class="si">}</span><span class="s2"> seconds at equator]&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;Must collapse over hour angle if tracking &quot;</span>
                    <span class="s2">&quot;sources for declination dependent &quot;</span>
                    <span class="s2">&quot;amount of time.&quot;</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Tracking source for fixed amount of time [</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">timetrack</span><span class="si">:</span><span class="s2">0.0f</span><span class="si">}</span><span class="s2"> seconds]&quot;</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="BeamFormBase.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.BeamFormBase.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generic process method.</span>

<span class="sd">        Performs all the beamforming, but not the data parsing.</span>
<span class="sd">        To be complemented by specific process methods in daughter tasks.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        formed_beam : `containers.FormedBeam` or `containers.FormedBeamHA`</span>
<span class="sd">            Formed beams at each source. Shape depends on parameter</span>
<span class="sd">            `collapse_ha`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Perform data dependent beam initialization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_beam_with_data</span><span class="p">()</span>

        <span class="c1"># Contruct containers for formed beams</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapse_ha</span><span class="p">:</span>
            <span class="c1"># Container to hold the formed beams</span>
            <span class="n">formed_beam</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">FormedBeam</span><span class="p">(</span>
                <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span>
                <span class="n">object_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">source_cat</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;object_id&quot;</span><span class="p">],</span>
                <span class="n">pol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">return_pol</span><span class="p">),</span>
                <span class="n">distributed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Container to hold the formed beams</span>
            <span class="n">formed_beam</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">FormedBeamHA</span><span class="p">(</span>
                <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span>
                <span class="n">ha</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nha</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span>
                <span class="n">object_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">source_cat</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;object_id&quot;</span><span class="p">],</span>
                <span class="n">pol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">return_pol</span><span class="p">),</span>
                <span class="n">distributed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Initialize container to zeros.</span>
            <span class="n">formed_beam</span><span class="o">.</span><span class="n">ha</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">formed_beam</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span><span class="n">tag</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tag_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag_catalog</span><span class="p">]</span> <span class="k">if</span> <span class="n">tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Initialize container to zeros.</span>
        <span class="n">formed_beam</span><span class="o">.</span><span class="n">beam</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">formed_beam</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Copy catalog information</span>
        <span class="n">formed_beam</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_cat</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][:]</span>
        <span class="k">if</span> <span class="s2">&quot;redshift&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_cat</span><span class="p">:</span>
            <span class="n">formed_beam</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;redshift&quot;</span><span class="p">)</span>
            <span class="n">formed_beam</span><span class="p">[</span><span class="s2">&quot;redshift&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_cat</span><span class="p">[</span><span class="s2">&quot;redshift&quot;</span><span class="p">][:]</span>

        <span class="c1"># Ensure container is distributed in frequency</span>
        <span class="n">formed_beam</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">freqside</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Indices of local frequency axis. Full axis if freqside is None.</span>
            <span class="n">f_local_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">f_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="n">fbb</span> <span class="o">=</span> <span class="n">formed_beam</span><span class="o">.</span><span class="n">beam</span><span class="p">[:]</span>
        <span class="n">fbw</span> <span class="o">=</span> <span class="n">formed_beam</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span>

        <span class="c1"># For each source, beamform and populate container.</span>
        <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsource</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">src</span> <span class="o">%</span> <span class="mi">1000</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Source </span><span class="si">{</span><span class="n">src</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nsource</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Declination of this source</span>
            <span class="n">dec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sdec</span><span class="p">[</span><span class="n">src</span><span class="p">])</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">freqside</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Get the frequency bin this source is closest to.</span>
                <span class="n">freq_diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="s2">&quot;centre&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sfreq</span><span class="p">[</span><span class="n">src</span><span class="p">])</span>
                <span class="n">sfreq_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">freq_diff</span><span class="p">)</span>
                <span class="c1"># Start and stop indices to process in global frequency axis</span>
                <span class="n">freq_idx0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">sfreq_index</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">freqside</span><span class="p">])</span>
                <span class="n">freq_idx1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">sfreq_index</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">freqside</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="c1"># Mask in full frequency axis</span>
                <span class="n">f_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="n">f_mask</span><span class="p">[</span><span class="n">freq_idx0</span><span class="p">:</span><span class="n">freq_idx1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="c1"># Restrict frequency mask to local range</span>
                <span class="n">f_mask</span> <span class="o">=</span> <span class="n">f_mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lo</span> <span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lo</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">)]</span>

                <span class="c1"># TODO: In principle I should be able to skip</span>
                <span class="c1"># sources that have no indices to be processed</span>
                <span class="c1"># in this rank. I am getting a NaN error, however.</span>
                <span class="c1"># I may need an mpiutil.barrier() call before the</span>
                <span class="c1"># return statement.</span>
                <span class="k">if</span> <span class="n">f_mask</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="c1"># If there are no indices to be processed in</span>
                    <span class="c1"># the local frequency range, skip source.</span>
                    <span class="k">continue</span>

                <span class="c1"># Frequency indices to process in local range</span>
                <span class="n">f_local_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">f_mask</span><span class="p">)]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sstream</span><span class="p">:</span>
                <span class="c1"># Get RA bin this source is closest to.</span>
                <span class="c1"># Phasing will actually be done at src position.</span>
                <span class="n">sra_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ra</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sra</span><span class="p">[</span><span class="n">src</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Cannot use searchsorted, because RA might not be</span>
                <span class="c1"># monotonically increasing. Slower.</span>
                <span class="c1"># Notice: in case there is more than one transit,</span>
                <span class="c1"># this will pick a single transit quasi-randomly!</span>
                <span class="n">transit_diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ra</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sra</span><span class="p">[</span><span class="n">src</span><span class="p">])</span>
                <span class="n">sra_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">transit_diff</span><span class="p">)</span>
                <span class="c1"># For now, skip sources that do not transit in the data</span>
                <span class="n">ra_cadence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ra</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ra</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">transit_diff</span><span class="p">[</span><span class="n">sra_index</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">ra_cadence</span><span class="p">:</span>
                    <span class="k">continue</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_timetrack</span><span class="p">:</span>
                <span class="n">ha_side</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ha_side</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dec</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ha_side</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ha_side</span><span class="p">)</span>

            <span class="c1"># Compute hour angle array</span>
            <span class="n">ha_array</span><span class="p">,</span> <span class="n">ra_index_range</span><span class="p">,</span> <span class="n">ha_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ha_array</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ra</span><span class="p">,</span> <span class="n">sra_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sra</span><span class="p">[</span><span class="n">src</span><span class="p">],</span> <span class="n">ha_side</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sstream</span>
            <span class="p">)</span>

            <span class="c1"># Arrays to store beams and weights for this source</span>
            <span class="c1"># for all polarizations prior to combining polarizations</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapse_ha</span><span class="p">:</span>
                <span class="n">formed_beam_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">npol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="n">weight_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">npol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">formed_beam_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nha</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span>
                <span class="p">)</span>
                <span class="n">weight_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">npol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nha</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="c1"># Loop over polarisations</span>
            <span class="k">for</span> <span class="n">pol</span><span class="p">,</span> <span class="n">pol_str</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">process_pol</span><span class="p">):</span>
                <span class="n">primary_beam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beamfunc</span><span class="p">(</span><span class="n">pol_str</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">ha_array</span><span class="p">)</span>

                <span class="c1"># Fringestop and sum over products</span>
                <span class="c1"># &#39;beamform&#39; does not normalize sum.</span>
                <span class="n">this_formed_beam</span> <span class="o">=</span> <span class="n">beamform</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vis</span><span class="p">[</span><span class="n">pol</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sumweight</span><span class="p">[</span><span class="n">pol</span><span class="p">],</span>
                    <span class="n">dec</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ha_array</span><span class="p">),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ha_array</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">bvec</span><span class="p">[</span><span class="n">pol</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">bvec</span><span class="p">[</span><span class="n">pol</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">f_local_indices</span><span class="p">,</span>
                    <span class="n">ra_index_range</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="n">sumweight_inrange</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sumweight</span><span class="p">[</span><span class="n">pol</span><span class="p">][:,</span> <span class="n">ra_index_range</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">visweight_inrange</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visweight</span><span class="p">[</span><span class="n">pol</span><span class="p">][:,</span> <span class="n">ra_index_range</span><span class="p">,</span> <span class="p">:]</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapse_ha</span><span class="p">:</span>
                    <span class="c1"># Sum over RA. Does not multiply by weights because</span>
                    <span class="c1"># this_formed_beam was never normalized (this avoids</span>
                    <span class="c1"># re-work and makes code more efficient).</span>

                    <span class="n">this_sumweight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sumweight_inrange</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">primary_beam</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
                    <span class="p">)</span>

                    <span class="n">formed_beam_full</span><span class="p">[</span><span class="n">pol</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="n">this_formed_beam</span> <span class="o">*</span> <span class="n">primary_beam</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
                    <span class="p">)</span> <span class="o">*</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">this_sumweight</span><span class="p">)</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">!=</span> <span class="s2">&quot;inverse_variance&quot;</span><span class="p">:</span>
                        <span class="n">this_weight2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                                <span class="n">sumweight_inrange</span><span class="o">**</span><span class="mi">2</span>
                                <span class="o">*</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">visweight_inrange</span><span class="p">),</span>
                                <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                            <span class="p">)</span>
                            <span class="o">*</span> <span class="n">primary_beam</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                        <span class="p">)</span>

                        <span class="n">weight_full</span><span class="p">[</span><span class="n">pol</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_sumweight</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">invert_no_zero</span><span class="p">(</span>
                            <span class="n">this_weight2</span>
                        <span class="p">)</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">weight_full</span><span class="p">[</span><span class="n">pol</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_sumweight</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Need to divide by weight here for proper</span>
                    <span class="c1"># normalization because it is not done in</span>
                    <span class="c1"># beamform()</span>
                    <span class="n">this_sumweight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sumweight_inrange</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="c1"># Populate only where ha_mask is true. Zero otherwise.</span>
                    <span class="n">formed_beam_full</span><span class="p">[</span><span class="n">pol</span><span class="p">][:,</span> <span class="n">ha_mask</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">this_formed_beam</span> <span class="o">*</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">this_sumweight</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">!=</span> <span class="s2">&quot;inverse_variance&quot;</span><span class="p">:</span>
                        <span class="n">this_weight2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                            <span class="n">sumweight_inrange</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">visweight_inrange</span><span class="p">),</span>
                            <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="c1"># Populate only where ha_mask is true. Zero otherwise.</span>
                        <span class="n">weight_full</span><span class="p">[</span><span class="n">pol</span><span class="p">][:,</span> <span class="n">ha_mask</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">this_sumweight</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">this_weight2</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">weight_full</span><span class="p">[</span><span class="n">pol</span><span class="p">][:,</span> <span class="n">ha_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_sumweight</span>

                <span class="c1"># Ensure weights are zero for non-processed frequencies</span>
                <span class="n">weight_full</span><span class="p">[</span><span class="n">pol</span><span class="p">][</span><span class="n">f_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="c1"># Combine polarizations if needed.</span>
            <span class="c1"># TODO: For now I am ignoring differences in the X and</span>
            <span class="c1"># Y beams and just adding them as is.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span> <span class="o">==</span> <span class="s2">&quot;I&quot;</span><span class="p">:</span>
                <span class="n">formed_beam_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="n">formed_beam_full</span> <span class="o">*</span> <span class="n">weight_full</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span> <span class="o">*</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight_full</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                <span class="n">weight_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight_full</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># Add an axis for the polarization</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapse_ha</span><span class="p">:</span>
                    <span class="n">formed_beam_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">formed_beam_full</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">))</span>
                    <span class="n">weight_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">weight_full</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">formed_beam_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                        <span class="n">formed_beam_full</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nha</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">weight_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">weight_full</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nha</span><span class="p">))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarization</span> <span class="o">==</span> <span class="s2">&quot;stokes&quot;</span><span class="p">:</span>
                <span class="c1"># TODO: Not implemented</span>
                <span class="k">pass</span>

            <span class="c1"># Populate container.</span>
            <span class="n">fbb</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="n">formed_beam_full</span>

            <span class="c1"># Scale the weights by a factor of 2 to account for the fact that we</span>
            <span class="c1"># have taken the real-component of the fringestopped visibility, which</span>
            <span class="c1"># has a variance that is 1/2 the variance of the complex visibility</span>
            <span class="c1"># that was encoded in our original weight dataset.</span>
            <span class="n">fbw</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">weight_full</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapse_ha</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sstream</span><span class="p">:</span>
                    <span class="n">formed_beam</span><span class="o">.</span><span class="n">ha</span><span class="p">[</span><span class="n">src</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ha_array</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Populate only where ha_mask is true.</span>
                    <span class="n">formed_beam</span><span class="o">.</span><span class="n">ha</span><span class="p">[</span><span class="n">src</span><span class="p">,</span> <span class="n">ha_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">ha_array</span>

        <span class="k">return</span> <span class="n">formed_beam</span></div>


<div class="viewcode-block" id="BeamFormBase.process_finish">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.BeamFormBase.process_finish">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process_finish</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clear lists holding copies of data.</span>

<span class="sd">        These lists will persist beyond this task being done, so</span>
<span class="sd">        the data stored there will continue to use memory.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;vis&quot;</span><span class="p">,</span> <span class="s2">&quot;visweight&quot;</span><span class="p">,</span> <span class="s2">&quot;bvec&quot;</span><span class="p">,</span> <span class="s2">&quot;sumweight&quot;</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_ha_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">source_ra_index</span><span class="p">,</span> <span class="n">source_ra</span><span class="p">,</span> <span class="n">ha_side</span><span class="p">,</span> <span class="n">is_sstream</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Hour angle for each RA/time bin to be processed.</span>

<span class="sd">        Also return the indices of these bins in the full RA/time axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ra : array</span>
<span class="sd">            RA axis in the data</span>
<span class="sd">        source_ra_index : int</span>
<span class="sd">            Index in data.index_map[&#39;ra&#39;] closest to source_ra</span>
<span class="sd">        source_ra : float</span>
<span class="sd">            RA of the quasar</span>
<span class="sd">        ha_side : int</span>
<span class="sd">            Number of RA/HA bins on each side of transit.</span>
<span class="sd">        is_sstream : bool</span>
<span class="sd">            True if data is sidereal stream. Flase if time stream</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ha_array : np.ndarray</span>
<span class="sd">            Hour angle array in the range -180. to 180</span>
<span class="sd">        ra_index_range : np.ndarray of int</span>
<span class="sd">            Indices (in data.index_map[&#39;ra&#39;]) corresponding</span>
<span class="sd">            to ha_array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># RA range to track this quasar through the beam.</span>
        <span class="n">ra_index_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
            <span class="n">source_ra_index</span> <span class="o">-</span> <span class="n">ha_side</span><span class="p">,</span> <span class="n">source_ra_index</span> <span class="o">+</span> <span class="n">ha_side</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span>
        <span class="p">)</span>
        <span class="c1"># Number of RA bins in data.</span>
        <span class="n">nra</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ra</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_sstream</span><span class="p">:</span>
            <span class="c1"># Wrap RA indices around edges.</span>
            <span class="n">ra_index_range</span><span class="p">[</span><span class="n">ra_index_range</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">nra</span>
            <span class="n">ra_index_range</span><span class="p">[</span><span class="n">ra_index_range</span> <span class="o">&gt;=</span> <span class="n">nra</span><span class="p">]</span> <span class="o">-=</span> <span class="n">nra</span>
            <span class="c1"># Hour angle array (convert to radians)</span>
            <span class="n">ha_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">ra</span><span class="p">[</span><span class="n">ra_index_range</span><span class="p">]</span> <span class="o">-</span> <span class="n">source_ra</span><span class="p">)</span>
            <span class="c1"># For later convenience it is better if `ha_array` is</span>
            <span class="c1"># in the range -pi to pi instead of 0 to 2pi.</span>
            <span class="n">ha_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">ha_array</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="c1"># In this case the ha_mask is trivial</span>
            <span class="n">ha_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ra_index_range</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Mask-out indices out of range</span>
            <span class="n">ha_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">ra_index_range</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ra_index_range</span> <span class="o">&lt;</span> <span class="n">nra</span><span class="p">)</span>
            <span class="c1"># Return smaller HA range, and mask.</span>
            <span class="n">ra_index_range</span> <span class="o">=</span> <span class="n">ra_index_range</span><span class="p">[</span><span class="n">ha_mask</span><span class="p">]</span>
            <span class="c1"># Hour angle array (convert to radians)</span>
            <span class="n">ha_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">ra</span><span class="p">[</span><span class="n">ra_index_range</span><span class="p">]</span> <span class="o">-</span> <span class="n">source_ra</span><span class="p">)</span>
            <span class="c1"># For later convenience it is better if `ha_array` is</span>
            <span class="c1"># in the range -pi to pi instead of 0 to 2pi.</span>
            <span class="n">ha_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">ha_array</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="k">return</span> <span class="n">ha_array</span><span class="p">,</span> <span class="n">ra_index_range</span><span class="p">,</span> <span class="n">ha_mask</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_initialize_beam_with_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Beam initialization that requires data.</span>

<span class="sd">        This is called at the start of the process method</span>
<span class="sd">        and can be overridden to perform any beam initialization</span>
<span class="sd">        that requires the data and catalog to be parsed first.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find the index of the local frequencies in</span>
        <span class="c1"># the frequency axis of the telescope instance</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_beam_model</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">freq_local_telescope_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">nu</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">frequencies</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_local</span>
                <span class="p">]</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_beamfunc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">ha</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the primary beam at the location of a source as it transits.</span>

<span class="sd">        Uses the frequencies in the freq_local_telescope_index attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pol : str</span>
<span class="sd">            String specifying the polarisation,</span>
<span class="sd">            either &#39;XX&#39;, &#39;XY&#39;, &#39;YX&#39;, or &#39;YY&#39;.</span>
<span class="sd">        dec : float</span>
<span class="sd">            The declination of the source in radians.</span>
<span class="sd">        ha : np.ndarray[nha,]</span>
<span class="sd">            The hour angle of the source in radians.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        primary_beam : np.ndarray[nfreq, nha]</span>
<span class="sd">            The primary beam as a function of frequency and hour angle</span>
<span class="sd">            at the sources declination for the requested polarisation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nfreq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_local</span><span class="o">.</span><span class="n">size</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_beam_model</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">ha</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="n">angpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">dec</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ha</span><span class="p">),</span> <span class="n">ha</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="n">primary_beam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">ha</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ff</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freq_local_telescope_index</span><span class="p">):</span>
            <span class="n">bii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">beam</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_pol_feed</span><span class="p">[</span><span class="n">pol</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">freq</span><span class="p">,</span> <span class="n">angpos</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">pol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pol</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">bjj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">beam</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_pol_feed</span><span class="p">[</span><span class="n">pol</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">freq</span><span class="p">,</span> <span class="n">angpos</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bjj</span> <span class="o">=</span> <span class="n">bii</span>

            <span class="n">primary_beam</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bii</span> <span class="o">*</span> <span class="n">bjj</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">primary_beam</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Store code for parsing and formating data prior to beamforming.&quot;&quot;&quot;</span>
        <span class="c1"># Easy access to communicator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm_</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">comm</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tag_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;tag&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># Extract data info</span>
        <span class="k">if</span> <span class="s2">&quot;ra&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_sstream</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ra</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;ra&quot;</span><span class="p">]</span>

            <span class="c1"># Calculate the epoch for the data so we can calculate the correct</span>
            <span class="c1"># CIRS coordinates</span>
            <span class="k">if</span> <span class="s2">&quot;lsd&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;SiderealStream must have an LSD attribute to calculate the epoch.&quot;</span>
                <span class="p">)</span>

            <span class="n">lsd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">lsd_to_unix</span><span class="p">(</span><span class="n">lsd</span><span class="p">)</span>

            <span class="n">dt</span> <span class="o">=</span> <span class="mf">240.0</span> <span class="o">*</span> <span class="n">constants</span><span class="o">.</span><span class="n">SIDEREAL_S</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ra</span><span class="p">)))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_sstream</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># Convert data timestamps into LSAs (degrees)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">unix_to_lsa</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

            <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nfreq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
        <span class="c1"># Ensure data is distributed in freq axis</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Number of RA bins to track each source at each side of transit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ha_side</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timetrack</span> <span class="o">/</span> <span class="n">dt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nha</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ha_side</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># polmap: indices of each vis product in</span>
        <span class="c1"># polarization list: [&#39;XX&#39;, &#39;XY&#39;, &#39;YX&#39;, &#39;YY&#39;]</span>
        <span class="n">polmap</span> <span class="o">=</span> <span class="n">polarization_map</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="p">)</span>
        <span class="c1"># Baseline vectors in meters</span>
        <span class="n">bvec_m</span> <span class="o">=</span> <span class="n">baseline_vector</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="p">)</span>

        <span class="c1"># MPI distribution values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lo</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">local_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ls</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">local_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freq_local</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="s2">&quot;centre&quot;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">lo</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">lo</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">]</span>

        <span class="c1"># These are to be used when gathering results in the end.</span>
        <span class="c1"># Tuple (not list!) of number of frequencies in each rank</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fsize</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allgather</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">))</span>
        <span class="c1"># Tuple (not list!) of displacements of each rank array in full array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">foffset</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allgather</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lo</span><span class="p">))</span>

        <span class="n">fullpol</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;XX&quot;</span><span class="p">,</span> <span class="s2">&quot;XY&quot;</span><span class="p">,</span> <span class="s2">&quot;YX&quot;</span><span class="p">,</span> <span class="s2">&quot;YY&quot;</span><span class="p">]</span>
        <span class="c1"># Save subsets of the data for each polarization, changing</span>
        <span class="c1"># the ordering to &#39;C&#39; (needed for the cython part).</span>
        <span class="c1"># This doubles the memory usage.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">visweight</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bvec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sumweight</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_pol</span><span class="p">:</span>
            <span class="n">pol</span> <span class="o">=</span> <span class="n">fullpol</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pol</span><span class="p">)</span>
            <span class="n">polmask</span> <span class="o">=</span> <span class="n">polmap</span> <span class="o">==</span> <span class="n">pol</span>
            <span class="c1"># Swap order of product(1) and RA(2) axes, to reduce striding</span>
            <span class="c1"># through memory later on.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="p">[:,</span> <span class="n">polmask</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># Restrict visweight to the local frequencies</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visweight</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span>
                        <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lo</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">lo</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ls</span><span class="p">][:,</span> <span class="n">polmask</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
                    <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># Multiply bvec_m by frequencies to get vector in wavelengths.</span>
            <span class="c1"># Shape: (2, nfreq_local, nvis), for each pol.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bvec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                    <span class="n">bvec_m</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">polmask</span><span class="p">]</span>
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_local</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                    <span class="o">*</span> <span class="mf">1e6</span>
                    <span class="o">/</span> <span class="n">C</span><span class="p">,</span>
                    <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;inverse_variance&quot;</span><span class="p">:</span>
                <span class="c1"># Weights for sum are just the visibility weights</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sumweight</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">visweight</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Ensure zero visweights result in zero sumweights</span>
                <span class="n">this_sumweight</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">visweight</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="n">ssi</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">input_flags</span><span class="p">[:]</span>
                <span class="n">ssp</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">][:]</span>
                <span class="n">sss</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reverse_map</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">][</span><span class="s2">&quot;stack&quot;</span><span class="p">][:]</span>
                <span class="n">nstack</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># this redundancy takes into account input flags.</span>
                <span class="c1"># It has shape (nstack, ntime)</span>
                <span class="n">redundancy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span>
                    <span class="n">calculate_redundancy</span><span class="p">(</span><span class="n">ssi</span><span class="p">,</span> <span class="n">ssp</span><span class="p">,</span> <span class="n">sss</span><span class="p">,</span> <span class="n">nstack</span><span class="p">)[</span><span class="n">polmask</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
                    <span class="p">),</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="mi">1</span><span class="p">,</span>
                <span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                <span class="c1"># redundancy = (self.telescope.redundancy[polmask].</span>
                <span class="c1">#        astype(np.float64)[np.newaxis, np.newaxis, :])</span>
                <span class="n">this_sumweight</span> <span class="o">*=</span> <span class="n">redundancy</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
                    <span class="n">this_sumweight</span> <span class="o">=</span> <span class="p">(</span><span class="n">this_sumweight</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sumweight</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">this_sumweight</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_catalog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">catalog</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process the catalog to get CIRS coordinates at the correct epoch.</span>

<span class="sd">        Note that `self._process_data` must have been called before this.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;position&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">catalog</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input is missing a position table.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;epoch&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Epoch not set. Was the requested data not available?&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_available</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span>

        <span class="n">coord</span> <span class="o">=</span> <span class="n">catalog</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;coordinates&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coord</span> <span class="o">==</span> <span class="s2">&quot;CIRS&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Catalog already in CIRS coordinates.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sra</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;ra&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sdec</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;dec&quot;</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Converting catalog from ICRS to CIRS coordinates.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sra</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sdec</span> <span class="o">=</span> <span class="n">icrs_to_cirs</span><span class="p">(</span>
                <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;ra&quot;</span><span class="p">],</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;dec&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">freqside</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;redshift&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">catalog</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input is missing a required redshift table.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sfreq</span> <span class="o">=</span> <span class="n">NU21</span> <span class="o">/</span> <span class="p">(</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;redshift&quot;</span><span class="p">][</span><span class="s2">&quot;z&quot;</span><span class="p">][:]</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>  <span class="c1"># MHz</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">source_cat</span> <span class="o">=</span> <span class="n">catalog</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsource</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sra</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tag_catalog</span> <span class="o">=</span> <span class="n">catalog</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;tag&quot;</span> <span class="ow">in</span> <span class="n">catalog</span><span class="o">.</span><span class="n">attrs</span> <span class="k">else</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="BeamForm">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.BeamForm">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BeamForm</span><span class="p">(</span><span class="n">BeamFormBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;BeamForm for a single source catalog and multiple visibility datasets.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="BeamForm.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.BeamForm.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">manager</span><span class="p">,</span> <span class="n">source_cat</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse the source catalog and performs the generic setup.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        manager : either `ProductManager`, `BeamTransfer` or `TransitTelescope`</span>
<span class="sd">            Contains a TransitTelescope object describing the telescope.</span>

<span class="sd">        source_cat : :class:`containers.SourceCatalog`</span>
<span class="sd">            Catalog of points to beamform at.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">manager</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span> <span class="o">=</span> <span class="n">source_cat</span></div>


<div class="viewcode-block" id="BeamForm.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.BeamForm.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse the visibility data and beamforms all sources.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : `containers.SiderealStream` or `containers.TimeStream`</span>
<span class="sd">            Data to beamform on.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        formed_beam : `containers.FormedBeam` or `containers.FormedBeamHA`</span>
<span class="sd">            Formed beams at each source.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Process and make available various data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_catalog</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_available</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Call generic process method.</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">process</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="BeamFormCat">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.BeamFormCat">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BeamFormCat</span><span class="p">(</span><span class="n">BeamFormBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;BeamForm for multiple source catalogs and a single visibility dataset.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="BeamFormCat.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.BeamFormCat.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">manager</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse the visibility data and performs the generic setup.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        manager : either `ProductManager`, `BeamTransfer` or `TransitTelescope`</span>
<span class="sd">            Contains a TransitTelescope object describing the telescope.</span>

<span class="sd">        data : `containers.SiderealStream` or `containers.TimeStream`</span>
<span class="sd">            Data to beamform on.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">manager</span><span class="p">)</span>

        <span class="c1"># Process and make available various data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="BeamFormCat.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.BeamFormCat.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_cat</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse the source catalog and beamforms all sources.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_cat : :class:`containers.SourceCatalog`</span>
<span class="sd">            Catalog of points to beamform at.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        formed_beam : `containers.FormedBeam` or `containers.FormedBeamHA`</span>
<span class="sd">            Formed beams at each source.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_catalog</span><span class="p">(</span><span class="n">source_cat</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_available</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Call generic process method.</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">process</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="BeamFormExternalMixin">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.BeamFormExternalMixin">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BeamFormExternalMixin</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for tasks that beamform using an external model of the primary beam.</span>

<span class="sd">    The primary beam is provided to the task during setup.  Do not use this class</span>
<span class="sd">    directly, instead use BeamFormExternal and BeamFormExternalCat.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BeamFormExternalMixin.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.BeamFormExternalMixin.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beam</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the beam.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        beam : GridBeam</span>
<span class="sd">            Model for the primary beam.</span>
<span class="sd">        args : optional</span>
<span class="sd">            Additional argument to pass to the super class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_beam</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_initialize_beam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beam</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize based on the beam container type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        beam : GridBeam</span>
<span class="sd">            Container holding the model for the primary beam.</span>
<span class="sd">            Currently only accepts GridBeam type containers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">beam</span><span class="p">,</span> <span class="n">containers</span><span class="o">.</span><span class="n">GridBeam</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_grid_beam</span><span class="p">(</span><span class="n">beam</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_beamfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_beam</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Do not recognize beam container: </span><span class="si">{</span><span class="n">beam</span><span class="o">.</span><span class="vm">__class__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_initialize_beam_with_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Ensure that the beam and visibilities have the same frequency axis.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freq_local</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beam_freq</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Beam and visibility frequency axes do not match.&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_initialize_grid_beam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gbeam</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create an interpolator for a GridBeam.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gbeam : GridBeam</span>
<span class="sd">            Model for the primary beam on a celestial grid where</span>
<span class="sd">            (theta, phi) = (declination, hour angle) in degrees.  The beam</span>
<span class="sd">            must be in power units and must have a length 1 input axis that</span>
<span class="sd">            contains the &quot;baseline averaged&quot; beam, which will be applied to</span>
<span class="sd">            all baselines of a given polarisation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure the beam is in celestial coordinates</span>
        <span class="k">if</span> <span class="n">gbeam</span><span class="o">.</span><span class="n">coords</span> <span class="o">!=</span> <span class="s2">&quot;celestial&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;GridBeam must be converted to celestial coordinates for beamforming.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Make sure there is a single beam to use for all inputs</span>
        <span class="k">if</span> <span class="n">gbeam</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Do not support input-dependent beams at the moment.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Distribute over frequencies, extract local frequencies</span>
        <span class="n">gbeam</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">lo</span> <span class="o">=</span> <span class="n">gbeam</span><span class="o">.</span><span class="n">beam</span><span class="o">.</span><span class="n">local_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nfreq</span> <span class="o">=</span> <span class="n">gbeam</span><span class="o">.</span><span class="n">beam</span><span class="o">.</span><span class="n">local_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_beam_freq</span> <span class="o">=</span> <span class="n">gbeam</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="n">lo</span> <span class="p">:</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">nfreq</span><span class="p">]</span>

        <span class="c1"># Find the relevant indices into the polarisation axis</span>
        <span class="n">process_pol</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;process_pol&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">gbeam</span><span class="o">.</span><span class="n">pol</span><span class="p">))</span>
        <span class="n">ipol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">gbeam</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pstr</span><span class="p">)</span> <span class="k">for</span> <span class="n">pstr</span> <span class="ow">in</span> <span class="n">process_pol</span><span class="p">])</span>
        <span class="n">npol</span> <span class="o">=</span> <span class="n">ipol</span><span class="o">.</span><span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_beam_pol</span> <span class="o">=</span> <span class="p">[</span><span class="n">gbeam</span><span class="o">.</span><span class="n">pol</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span> <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">ipol</span><span class="p">]</span>

        <span class="c1"># Extract beam</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">gbeam</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">][:,</span> <span class="n">ipol</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span>
        <span class="n">beam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="n">gbeam</span><span class="o">.</span><span class="n">beam</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">][:,</span> <span class="n">ipol</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="c1"># Convert the declination and hour angle axis to radians, make sure they are sorted</span>
        <span class="n">ha</span> <span class="o">=</span> <span class="p">(</span><span class="n">gbeam</span><span class="o">.</span><span class="n">phi</span> <span class="o">+</span> <span class="mf">180.0</span><span class="p">)</span> <span class="o">%</span> <span class="mf">360.0</span> <span class="o">-</span> <span class="mf">180.0</span>
        <span class="n">isort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">ha</span><span class="p">)</span>
        <span class="n">ha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">ha</span><span class="p">[</span><span class="n">isort</span><span class="p">])</span>

        <span class="n">dec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">gbeam</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>

        <span class="c1"># Create a 2D interpolator for the beam at each frequency and polarisation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_beam</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span>
                <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span><span class="n">dec</span><span class="p">,</span> <span class="n">ha</span><span class="p">,</span> <span class="n">beam</span><span class="p">[</span><span class="n">ff</span><span class="p">,</span> <span class="n">pp</span><span class="p">][:,</span> <span class="n">isort</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npol</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nfreq</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Create a similair interpolator for the flag array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_beam_flag</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span>
                <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span>
                    <span class="n">dec</span><span class="p">,</span> <span class="n">ha</span><span class="p">,</span> <span class="n">flag</span><span class="p">[</span><span class="n">ff</span><span class="p">,</span> <span class="n">pp</span><span class="p">][:,</span> <span class="n">isort</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npol</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nfreq</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Grid beam initialized.&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_grid_beam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">ha</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interpolate a GridBeam to the requested declination and hour angles.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pol : str</span>
<span class="sd">            String specifying the polarisation,</span>
<span class="sd">            either &#39;XX&#39;, &#39;XY&#39;, &#39;YX&#39;, or &#39;YY&#39;.</span>
<span class="sd">        dec : float</span>
<span class="sd">            The declination of the source in radians.</span>
<span class="sd">        ha : np.ndarray[nha,]</span>
<span class="sd">            The hour angle of the source in radians.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        primay_beam : np.ndarray[nfreq, nha]</span>
<span class="sd">            The primary beam as a function of frequency and hour angle</span>
<span class="sd">            at the sources declination for the requested polarisation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beam_pol</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pol</span><span class="p">)</span>

        <span class="n">primay_beam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_beam</span><span class="p">[</span><span class="n">ff</span><span class="p">][</span><span class="n">pp</span><span class="p">](</span><span class="n">dec</span><span class="p">,</span> <span class="n">ha</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_beam_freq</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="p">)</span>

        <span class="c1"># If the interpolated flags deviate from 1.0, then we mask</span>
        <span class="c1"># the interpolated beam, since some fraction the underlying</span>
        <span class="c1"># data used to construct the interpolator was masked.</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_beam_flag</span><span class="p">[</span><span class="n">ff</span><span class="p">][</span><span class="n">pp</span><span class="p">](</span><span class="n">dec</span><span class="p">,</span> <span class="n">ha</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.01</span>
                <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_beam_freq</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="n">primay_beam</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span></div>



<div class="viewcode-block" id="BeamFormExternal">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.BeamFormExternal">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BeamFormExternal</span><span class="p">(</span><span class="n">BeamFormExternalMixin</span><span class="p">,</span> <span class="n">BeamForm</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Beamform a single catalog and multiple datasets using an external beam model.</span>

<span class="sd">    The setup method requires [beam, manager, source_cat] as arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="BeamFormExternalCat">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.BeamFormExternalCat">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BeamFormExternalCat</span><span class="p">(</span><span class="n">BeamFormExternalMixin</span><span class="p">,</span> <span class="n">BeamFormCat</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Beamform multiple catalogs and a single dataset using an external beam model.</span>

<span class="sd">    The setup method requires [beam, manager, data] as arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="RingMapBeamForm">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.RingMapBeamForm">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RingMapBeamForm</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Beamform by extracting the pixel containing each source form a RingMap.</span>

<span class="sd">    This is significantly faster than `Beamform` or `BeamformCat` with the caveat</span>
<span class="sd">    that they can beamform exactly on a source whereas this task is at the mercy of</span>
<span class="sd">    what was done to produce the `RingMap` (use `DeconvolveHybridM` for best</span>
<span class="sd">    results).</span>

<span class="sd">    Unless it has an explicit `lsd` attribute, the ring map is assumed to be in the</span>
<span class="sd">    same coordinate epoch as the catalog. If it does, the input catalog is assumed to be</span>
<span class="sd">    in ICRS and then is precessed to the CIRS coordinates in the epoch of the map.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RingMapBeamForm.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.RingMapBeamForm.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">telescope</span><span class="p">:</span> <span class="n">io</span><span class="o">.</span><span class="n">TelescopeConvertible</span><span class="p">,</span> <span class="n">ringmap</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">RingMap</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the telescope object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        telescope</span>
<span class="sd">            The telescope object to use.</span>
<span class="sd">        ringmap</span>
<span class="sd">            The ringmap to extract the sources from. See the class documentation for how</span>
<span class="sd">            the epoch is determined.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">get_telescope</span><span class="p">(</span><span class="n">telescope</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ringmap</span> <span class="o">=</span> <span class="n">ringmap</span></div>


<div class="viewcode-block" id="RingMapBeamForm.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.RingMapBeamForm.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">catalog</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">SourceCatalog</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">FormedBeam</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract sources from a ringmap.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        catalog</span>
<span class="sd">            The catalog to extract sources from.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sources</span>
<span class="sd">            The source spectra.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ringmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ringmap</span>

        <span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_catalog</span><span class="p">(</span><span class="n">catalog</span><span class="p">)</span>

        <span class="c1"># Get the pixel indices</span>
        <span class="n">ra_ind</span><span class="p">,</span> <span class="n">el_ind</span><span class="p">,</span> <span class="n">src_ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_ind</span><span class="p">(</span><span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span><span class="p">)</span>

        <span class="c1"># Container to hold the formed beams</span>
        <span class="n">formed_beam</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">FormedBeam</span><span class="p">(</span>
            <span class="n">object_id</span><span class="o">=</span><span class="n">catalog</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;object_id&quot;</span><span class="p">][</span><span class="n">src_ind</span><span class="p">],</span>
            <span class="n">axes_from</span><span class="o">=</span><span class="n">ringmap</span><span class="p">,</span>
            <span class="n">attrs_from</span><span class="o">=</span><span class="n">catalog</span><span class="p">,</span>
            <span class="n">distributed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Initialize container to zeros.</span>
        <span class="n">formed_beam</span><span class="o">.</span><span class="n">beam</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">formed_beam</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Copy catalog information</span>
        <span class="n">formed_beam</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="n">src_ind</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;redshift&quot;</span> <span class="ow">in</span> <span class="n">catalog</span><span class="p">:</span>
            <span class="n">formed_beam</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;redshift&quot;</span><span class="p">)</span>
            <span class="n">formed_beam</span><span class="p">[</span><span class="s2">&quot;redshift&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;redshift&quot;</span><span class="p">][</span><span class="n">src_ind</span><span class="p">]</span>

        <span class="c1"># Ensure containers are distributed in frequency</span>
        <span class="n">formed_beam</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
        <span class="n">ringmap</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">has_weight</span> <span class="o">=</span> <span class="s2">&quot;weight&quot;</span> <span class="ow">in</span> <span class="n">ringmap</span><span class="o">.</span><span class="n">datasets</span>

        <span class="c1"># Dereference the datasets</span>
        <span class="n">fbb</span> <span class="o">=</span> <span class="n">formed_beam</span><span class="o">.</span><span class="n">beam</span><span class="p">[:]</span>
        <span class="n">fbw</span> <span class="o">=</span> <span class="n">formed_beam</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span>
        <span class="n">rmm</span> <span class="o">=</span> <span class="n">ringmap</span><span class="o">.</span><span class="n">map</span><span class="p">[:]</span>
        <span class="n">rmw</span> <span class="o">=</span> <span class="n">ringmap</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="k">if</span> <span class="n">has_weight</span> <span class="k">else</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">ringmap</span><span class="o">.</span><span class="n">rms</span><span class="p">[:])</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="c1"># Loop over sources and extract the polarised pencil beams containing them from</span>
        <span class="c1"># the ringmaps</span>
        <span class="k">for</span> <span class="n">si</span><span class="p">,</span> <span class="p">(</span><span class="n">ri</span><span class="p">,</span> <span class="n">ei</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ra_ind</span><span class="p">,</span> <span class="n">el_ind</span><span class="p">)):</span>
            <span class="n">fbb</span><span class="p">[</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="n">rmm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">ri</span><span class="p">,</span> <span class="n">ei</span><span class="p">]</span>
            <span class="n">fbw</span><span class="p">[</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="n">rmw</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ri</span><span class="p">,</span> <span class="n">ei</span><span class="p">]</span> <span class="k">if</span> <span class="n">has_weight</span> <span class="k">else</span> <span class="n">rmw</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ri</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">formed_beam</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_process_catalog</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">catalog</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">SourceCatalog</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the current epoch coordinates of the catalog.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;position&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">catalog</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input is missing a position table.&quot;</span><span class="p">)</span>

        <span class="c1"># Calculate the epoch for the data so we can calculate the correct</span>
        <span class="c1"># CIRS coordinates</span>
        <span class="k">if</span> <span class="s2">&quot;lsd&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ringmap</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Input map has no epoch set, assuming that it matches the catalog.&quot;</span>
            <span class="p">)</span>
            <span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;ra&quot;</span><span class="p">],</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;dec&quot;</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">lsd</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ringmap</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ringmap</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
                <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">ringmap</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">epoch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">lsd_to_unix</span><span class="p">(</span><span class="n">lsd</span><span class="p">)</span>

            <span class="c1"># Get the source positions at the current epoch</span>
            <span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span> <span class="o">=</span> <span class="n">icrs_to_cirs</span><span class="p">(</span>
                <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;ra&quot;</span><span class="p">],</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;dec&quot;</span><span class="p">],</span> <span class="n">epoch</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_source_ind</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">src_ra</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">src_dec</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the indices of the pixels nearest to an array of source coordinates.</span>

<span class="sd">        Given arrays of source right ascensions and declinations, this method finds</span>
<span class="sd">        the indices into the RA and elevation axis of a ringmap corresponding to the</span>
<span class="sd">        nearest pixels.  It excludes any sources that fall outside the ringmap.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_ra : np.ndarray[nsource,]</span>
<span class="sd">            Source right ascensions in degrees.</span>
<span class="sd">        src_dec : np.ndarray[nsource,]</span>
<span class="sd">            Source declinations in degrees.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ra_ind : np.ndarray[nvalid,]</span>
<span class="sd">            Indices into the RA axis corresponding to the nearest pixel</span>
<span class="sd">            for valid sources.</span>
<span class="sd">        el_ind : np.ndarray[nvalid,]</span>
<span class="sd">            Indices into the elevation axis corresponding to the nearest pixel</span>
<span class="sd">            for valid sources.</span>
<span class="sd">        src_ind : np.ndarray[nvalid,]</span>
<span class="sd">            Indices of the sources that fall within the map&#39;s RA and elevation range.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">src_el</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">src_dec</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">latitude</span><span class="p">))</span>

        <span class="c1"># Get the map grid in RA and sin(ZA)</span>
        <span class="n">ra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ringmap</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;ra&quot;</span><span class="p">]</span>
        <span class="n">el</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ringmap</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;el&quot;</span><span class="p">]</span>

        <span class="n">delta_ra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ra</span><span class="p">)))</span>
        <span class="n">delta_el</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">el</span><span class="p">)))</span>

        <span class="c1"># Get the source indices in RA</span>
        <span class="c1"># NOTE: that we need to take into account that sources might be less than 360</span>
        <span class="c1"># deg, but still closer to ind=0</span>
        <span class="n">ra_ind</span> <span class="o">=</span> <span class="n">_search_nearest</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ra</span><span class="p">,</span> <span class="mf">360.0</span> <span class="o">+</span> <span class="n">ra</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">src_ra</span><span class="p">)</span> <span class="o">%</span> <span class="n">ra</span><span class="o">.</span><span class="n">size</span>

        <span class="n">ra_sep</span> <span class="o">=</span> <span class="n">src_ra</span> <span class="o">-</span> <span class="n">ra</span><span class="p">[</span><span class="n">ra_ind</span><span class="p">]</span>
        <span class="n">ra_sep</span> <span class="o">=</span> <span class="p">(</span><span class="n">ra_sep</span> <span class="o">+</span> <span class="mf">180.0</span><span class="p">)</span> <span class="o">%</span> <span class="mf">360.0</span> <span class="o">-</span> <span class="mf">180.0</span>

        <span class="c1"># Get the indices for the ZA direction</span>
        <span class="n">el_ind</span> <span class="o">=</span> <span class="n">_search_nearest</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">src_el</span><span class="p">)</span>

        <span class="n">el_sep</span> <span class="o">=</span> <span class="n">src_el</span> <span class="o">-</span> <span class="n">el</span><span class="p">[</span><span class="n">el_ind</span><span class="p">]</span>

        <span class="c1"># Make sure no source are outside of the range covered by the map</span>
        <span class="n">src_flag</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ra_sep</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">delta_ra</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">el_sep</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">delta_el</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">src_flag</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;There are </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">src_flag</span><span class="p">)</span><span class="si">}</span><span class="s2"> (of </span><span class="si">{</span><span class="n">src_flag</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2">) &quot;</span>
                <span class="s2">&quot;sources outside of the RA and Declination range covered by the map.&quot;</span>
            <span class="p">)</span>

        <span class="n">src_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="o">~</span><span class="n">src_flag</span><span class="p">)</span>
        <span class="n">ra_ind</span> <span class="o">=</span> <span class="n">ra_ind</span><span class="p">[</span><span class="n">src_ind</span><span class="p">]</span>
        <span class="n">el_ind</span> <span class="o">=</span> <span class="n">el_ind</span><span class="p">[</span><span class="n">src_ind</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">ra_ind</span><span class="p">,</span> <span class="n">el_ind</span><span class="p">,</span> <span class="n">src_ind</span></div>



<div class="viewcode-block" id="RingMapStack2D">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.RingMapStack2D">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RingMapStack2D</span><span class="p">(</span><span class="n">RingMapBeamForm</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Stack RingMap&#39;s on sources directly.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num_ra, num_dec : int</span>
<span class="sd">        The number of RA and DEC pixels to stack either side of the source.</span>
<span class="sd">    num_freq : int</span>
<span class="sd">        Number of final frequency channels either side of the source redshift to</span>
<span class="sd">        stack.</span>
<span class="sd">    freq_width : float</span>
<span class="sd">        Length of frequency interval either side of source to use in MHz.</span>
<span class="sd">        If set to zero, then will default to use the ringmaps native resolution.</span>
<span class="sd">    weight : {&quot;patch&quot;, &quot;dec&quot;, &quot;enum&quot;}</span>
<span class="sd">        How to weight the data. If `&quot;input&quot;` the data is weighted on a pixel by pixel</span>
<span class="sd">        basis according to the input data. If `&quot;patch&quot;` then the inverse of the</span>
<span class="sd">        variance of the extracted patch is used. If `&quot;dec&quot;` then the inverse variance</span>
<span class="sd">        of each declination strip is used.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">num_ra</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">num_dec</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">num_freq</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">256</span><span class="p">)</span>
    <span class="n">freq_width</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">enum</span><span class="p">([</span><span class="s2">&quot;patch&quot;</span><span class="p">,</span> <span class="s2">&quot;dec&quot;</span><span class="p">,</span> <span class="s2">&quot;input&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;input&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="RingMapStack2D.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.RingMapStack2D.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">catalog</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">SourceCatalog</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">FormedBeam</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract sources from a ringmap.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        catalog</span>
<span class="sd">            The catalog to extract sources from.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sources</span>
<span class="sd">            The source spectra.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">mpi4py</span><span class="w"> </span><span class="kn">import</span> <span class="n">MPI</span>

        <span class="n">ringmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ringmap</span>

        <span class="c1"># Get the current epoch catalog position</span>
        <span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_catalog</span><span class="p">(</span><span class="n">catalog</span><span class="p">)</span>
        <span class="n">src_z</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;redshift&quot;</span><span class="p">][</span><span class="s2">&quot;z&quot;</span><span class="p">]</span>

        <span class="c1"># Get the pixel indices</span>
        <span class="n">ra_ind</span><span class="p">,</span> <span class="n">el_ind</span><span class="p">,</span> <span class="n">src_ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source_ind</span><span class="p">(</span><span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span><span class="p">)</span>

        <span class="c1"># Exclude sources outside of the map</span>
        <span class="n">src_z</span> <span class="o">=</span> <span class="n">src_z</span><span class="p">[</span><span class="n">src_ind</span><span class="p">]</span>

        <span class="c1"># Ensure containers are distributed in frequency</span>
        <span class="n">ringmap</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Get the frequencies on this rank</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">ringmap</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">local_offset</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">fe</span> <span class="o">=</span> <span class="n">fs</span> <span class="o">+</span> <span class="n">ringmap</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">local_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">local_freq</span> <span class="o">=</span> <span class="n">ringmap</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="n">fs</span><span class="p">:</span><span class="n">fe</span><span class="p">]</span>

        <span class="c1"># RA and EL grid info</span>
        <span class="n">ra</span> <span class="o">=</span> <span class="n">ringmap</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;ra&quot;</span><span class="p">]</span>
        <span class="n">el</span> <span class="o">=</span> <span class="n">ringmap</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;el&quot;</span><span class="p">]</span>

        <span class="n">dra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ra</span><span class="p">)))</span>
        <span class="n">dell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">el</span><span class="p">)))</span>

        <span class="n">nra</span> <span class="o">=</span> <span class="n">ra</span><span class="o">.</span><span class="n">size</span>
        <span class="n">nel</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># Determine if the RA axis wraps around from 360 to 0 deg</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="n">dra</span> <span class="o">/</span> <span class="mf">100.0</span>
        <span class="n">ra_wraps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">ra</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dra</span><span class="p">,</span> <span class="mf">360.0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
            <span class="n">ra</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">tol</span>
        <span class="p">)</span>

        <span class="c1"># Calculate the frequencies bins to use</span>
        <span class="n">nbins</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_freq</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_width</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">freq_width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_width</span><span class="p">,</span> <span class="n">nbins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ringmap</span><span class="o">.</span><span class="n">freq</span><span class="p">)))</span>
            <span class="n">bin_edges</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">num_freq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_freq</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">df</span>

        <span class="c1"># Calculate the edges of the frequency distribution, sources outside this range</span>
        <span class="c1"># will be dropped</span>
        <span class="n">global_fmin</span> <span class="o">=</span> <span class="n">ringmap</span><span class="o">.</span><span class="n">freq</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">global_fmax</span> <span class="o">=</span> <span class="n">ringmap</span><span class="o">.</span><span class="n">freq</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

        <span class="c1"># Dereference the datasets</span>
        <span class="n">rmm</span> <span class="o">=</span> <span class="n">ringmap</span><span class="o">.</span><span class="n">map</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="k">if</span> <span class="s2">&quot;weight&quot;</span> <span class="ow">in</span> <span class="n">ringmap</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
            <span class="n">rmw</span> <span class="o">=</span> <span class="n">ringmap</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rmw</span> <span class="o">=</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">ringmap</span><span class="o">.</span><span class="n">rms</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">rmw</span> <span class="o">=</span> <span class="n">rmw</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

        <span class="c1"># Create temporary array to accumulate into</span>
        <span class="n">wstack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="n">nbins</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ringmap</span><span class="o">.</span><span class="n">pol</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ra</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="n">nbins</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ringmap</span><span class="o">.</span><span class="n">pol</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ra</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">rmvar</span> <span class="o">=</span> <span class="n">rmm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">w_global</span> <span class="o">=</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">rmvar</span> <span class="o">&lt;</span> <span class="mf">3e-7</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">rmvar</span><span class="p">))</span>

        <span class="c1"># Loop over sources and extract the polarised pencil beams containing them from</span>
        <span class="c1"># the ringmaps</span>
        <span class="k">for</span> <span class="n">si</span><span class="p">,</span> <span class="p">(</span><span class="n">ri</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ra_ind</span><span class="p">,</span> <span class="n">el_ind</span><span class="p">,</span> <span class="n">src_z</span><span class="p">)):</span>
            <span class="n">source_freq</span> <span class="o">=</span> <span class="n">NU21</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">source_freq</span> <span class="o">&gt;</span> <span class="n">global_fmax</span> <span class="ow">or</span> <span class="n">source_freq</span> <span class="o">&lt;</span> <span class="n">global_fmin</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Get bin indices</span>
            <span class="n">bin_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">local_freq</span> <span class="o">-</span> <span class="n">source_freq</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">)</span>

            <span class="c1"># Get the el slice to extract the enclosing angular region</span>
            <span class="n">estart</span><span class="p">,</span> <span class="n">estop</span> <span class="o">=</span> <span class="n">ei</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dec</span><span class="p">,</span> <span class="n">ei</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dec</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">ei_start</span><span class="p">,</span> <span class="n">ei_stop</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">estart</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">estop</span><span class="p">,</span> <span class="n">nel</span><span class="p">)</span>

            <span class="n">ei_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">ei_start</span><span class="p">,</span> <span class="n">ei_stop</span><span class="p">)</span>
            <span class="n">ei_out</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">estart</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dec</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">estop</span> <span class="o">-</span> <span class="n">nel</span><span class="p">))</span>

            <span class="c1"># Get the ra slice to extract the enclosing angular region</span>
            <span class="n">rstart</span><span class="p">,</span> <span class="n">rstop</span> <span class="o">=</span> <span class="n">ri</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ra</span><span class="p">,</span> <span class="n">ri</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ra</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">ra_wraps</span> <span class="ow">and</span> <span class="p">((</span><span class="n">rstart</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">rstop</span> <span class="o">&gt;</span> <span class="n">nra</span><span class="p">)):</span>
                <span class="c1"># The source is near one of the ends of the RA axis,</span>
                <span class="c1"># so we will need to wrap around.  Do this by creating</span>
                <span class="c1"># two slices, one at each end, and concatenating them.</span>
                <span class="n">ri_slice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">((</span><span class="n">nra</span> <span class="o">+</span> <span class="n">rstart</span><span class="p">)</span> <span class="o">%</span> <span class="n">nra</span><span class="p">,</span> <span class="n">nra</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">rstop</span> <span class="o">%</span> <span class="n">nra</span><span class="p">)]</span>
                <span class="n">ri_out</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

                <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="nb">tuple</span><span class="p">(</span><span class="n">rmm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">slc</span><span class="p">,</span> <span class="n">ei_slice</span><span class="p">]</span> <span class="k">for</span> <span class="n">slc</span> <span class="ow">in</span> <span class="n">ri_slice</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span>
                <span class="p">)</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="nb">tuple</span><span class="p">(</span><span class="n">rmw</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">slc</span><span class="p">,</span> <span class="n">ei_slice</span><span class="p">]</span> <span class="k">for</span> <span class="n">slc</span> <span class="ow">in</span> <span class="n">ri_slice</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span>
                <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">ri_start</span><span class="p">,</span> <span class="n">ri_stop</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">rstart</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">rstop</span><span class="p">,</span> <span class="n">nra</span><span class="p">)</span>
                <span class="n">ri_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">ri_start</span><span class="p">,</span> <span class="n">ri_stop</span><span class="p">)</span>

                <span class="n">ri_out</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span>
                    <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">rstart</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ra</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">rstop</span> <span class="o">-</span> <span class="n">nra</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="n">b</span> <span class="o">=</span> <span class="n">rmm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">ri_slice</span><span class="p">,</span> <span class="n">ei_slice</span><span class="p">]</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">rmw</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ri_slice</span><span class="p">,</span> <span class="n">ei_slice</span><span class="p">]</span>

            <span class="c1"># Determine the weight that is given to this source</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;patch&quot;</span><span class="p">:</span>
                <span class="c1"># Replace the weights with the variance of the patch</span>
                <span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))[</span>
                    <span class="p">:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span>
                <span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;dec&quot;</span><span class="p">:</span>
                <span class="c1"># w = (w != 0) * invert_no_zero(b.var(axis=2))[:, :, np.newaxis, :]</span>
                <span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">w_global</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">ei_slice</span><span class="p">]</span>

            <span class="n">bw</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">w</span>

            <span class="c1"># TODO: this is probably slow so should be moved into Cython</span>
            <span class="k">for</span> <span class="n">lfi</span><span class="p">,</span> <span class="n">bi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bin_ind</span><span class="p">):</span>
                <span class="n">wstack</span><span class="p">[</span><span class="n">bi</span><span class="p">,</span> <span class="p">:,</span> <span class="n">ri_out</span><span class="p">,</span> <span class="n">ei_out</span><span class="p">]</span> <span class="o">+=</span> <span class="n">bw</span><span class="p">[:,</span> <span class="n">lfi</span><span class="p">]</span>
                <span class="n">weight</span><span class="p">[</span><span class="n">bi</span><span class="p">,</span> <span class="p">:,</span> <span class="n">ri_out</span><span class="p">,</span> <span class="n">ei_out</span><span class="p">]</span> <span class="o">+=</span> <span class="n">w</span><span class="p">[:,</span> <span class="n">lfi</span><span class="p">]</span>

        <span class="c1"># Arrays to reduce the data into</span>
        <span class="n">wstack_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">wstack</span><span class="p">)</span>
        <span class="n">weight_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Allreduce</span><span class="p">(</span><span class="n">wstack</span><span class="p">,</span> <span class="n">wstack_all</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">SUM</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Allreduce</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">weight_all</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">SUM</span><span class="p">)</span>

        <span class="n">stack_all</span> <span class="o">=</span> <span class="n">wstack_all</span> <span class="o">*</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">weight_all</span><span class="p">)</span>

        <span class="c1"># Create the axes of the 3D grid</span>
        <span class="n">delta_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbins</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;centre&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;width&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)])</span>
        <span class="n">delta_f</span><span class="p">[</span><span class="s2">&quot;centre&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">delta_f</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">delta_ra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ra</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ra</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dra</span>
        <span class="n">delta_dec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dell</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Create the container to store the data in</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">Stack3D</span><span class="p">(</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">delta_f</span><span class="p">,</span>
            <span class="n">delta_ra</span><span class="o">=</span><span class="n">delta_ra</span><span class="p">,</span>
            <span class="n">delta_dec</span><span class="o">=</span><span class="n">delta_dec</span><span class="p">,</span>
            <span class="n">axes_from</span><span class="o">=</span><span class="n">ringmap</span><span class="p">,</span>
            <span class="n">attrs_from</span><span class="o">=</span><span class="n">ringmap</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">catalog</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">stack</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">stack_all</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">weight_all</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">stack</span></div>
</div>



<div class="viewcode-block" id="HybridVisBeamForm">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.HybridVisBeamForm">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">HybridVisBeamForm</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Beamform on a catalog of sources using the HybridVisStream data product.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    window : float</span>
<span class="sd">        Window size in degrees.  For each source, right ascensions corresponding to</span>
<span class="sd">        abs(ra - source_ra) &lt;= window are extracted from the hybrid beamformed</span>
<span class="sd">        visibility at the declination closest to the sources location.  Default is</span>
<span class="sd">        5 degrees.</span>
<span class="sd">    ignore_rot : bool</span>
<span class="sd">        Ignore the telescope rotation_angle when calculating the baseline distances</span>
<span class="sd">        used to beamform in the east-west direction.  Defaults to False.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">window</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span>
    <span class="n">ignore_rot</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="HybridVisBeamForm.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.HybridVisBeamForm.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">manager</span><span class="p">,</span> <span class="n">catalog</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Define the observer and the catalog of sources.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        manager : draco.core.io.TelescopeConvertible</span>
<span class="sd">            Observer object holding the geographic location of the telescope.</span>
<span class="sd">            Note that if ignore_rot is False and this object has a non-zero</span>
<span class="sd">            rotation_angle, then the beamforming will account for the phase</span>
<span class="sd">            due to the north-south component of the rotation.</span>

<span class="sd">        catalog : draco.core.containers.SourceCatalog</span>
<span class="sd">            Beamform on sources in this catalog.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">get_telescope</span><span class="p">(</span><span class="n">manager</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_rot</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="p">,</span> <span class="s2">&quot;rotation_angle&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Correcting for phase due to north-south component of a &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">rotation_angle</span><span class="si">:</span><span class="s2">0.2f</span><span class="si">}</span><span class="s2"> degree rotation.&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">rotation_angle</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rot</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span> <span class="o">=</span> <span class="n">catalog</span></div>


<div class="viewcode-block" id="HybridVisBeamForm.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.HybridVisBeamForm.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hvis</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Finish beamforming in the east-west direction.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hvis : draco.core.containers.HybridVisStream</span>
<span class="sd">            Visibilities beamformed in the north-south direction to</span>
<span class="sd">            a grid of declinations along the meridian.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : draco.core.containers.HybridFormedBeamHA</span>
<span class="sd">            Visibilities beamformed to the location of sources</span>
<span class="sd">            in a catalog.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hvis</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">fringestopped</span> <span class="o">=</span> <span class="n">hvis</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fringestopped&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Get source positions</span>
        <span class="n">lsd</span> <span class="o">=</span> <span class="n">hvis</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lsd&quot;</span><span class="p">,</span> <span class="n">hvis</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;csd&quot;</span><span class="p">))</span>

        <span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;ra&quot;</span><span class="p">][:],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;dec&quot;</span><span class="p">][:],</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">lsd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">epoch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">lsd_to_unix</span><span class="p">(</span><span class="n">lsd</span><span class="p">))</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">icrs_to_cirs</span><span class="p">(</span><span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span><span class="p">,</span> <span class="n">ep</span><span class="p">)</span> <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">epoch</span><span class="p">]</span>
            <span class="n">src_ra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">src_dec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Find nearest declination</span>
        <span class="n">dec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">hvis</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;el&quot;</span><span class="p">])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span>
        <span class="n">nearest_dec</span> <span class="o">=</span> <span class="n">_search_nearest</span><span class="p">(</span><span class="n">dec</span><span class="p">,</span> <span class="n">src_dec</span><span class="p">)</span>

        <span class="n">delta_dec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">dec</span><span class="p">)))</span>
        <span class="n">valid_src</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">src_dec</span> <span class="o">-</span> <span class="n">dec</span><span class="p">[</span><span class="n">nearest_dec</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">delta_dec</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;There are </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">valid_src</span><span class="p">)</span><span class="si">}</span><span class="s2"> catalog sources in this declination range.&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Find hour angle window</span>
        <span class="n">ra</span> <span class="o">=</span> <span class="n">hvis</span><span class="o">.</span><span class="n">ra</span>
        <span class="n">ha_arr</span> <span class="o">=</span> <span class="n">correct_phase_wrap</span><span class="p">(</span><span class="n">ra</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">src_ra</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">deg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ha_arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span>

        <span class="n">nha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">valid</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">ra_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">ra</span><span class="p">)</span>

        <span class="c1"># Calculate baseline distances</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">hvis</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="n">hvis</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_bounds</span><span class="p">]</span>
        <span class="n">lmbda</span> <span class="o">=</span> <span class="n">C</span> <span class="o">*</span> <span class="mf">1e-6</span> <span class="o">/</span> <span class="n">freq</span>

        <span class="n">ew</span> <span class="o">=</span> <span class="n">hvis</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;ew&quot;</span><span class="p">]</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">ew</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">/</span> <span class="n">lmbda</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span>

        <span class="c1"># Dereference input datasets</span>
        <span class="n">vis</span> <span class="o">=</span> <span class="n">hvis</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>  <span class="c1"># pol, freq, ew, el, ra</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">hvis</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>  <span class="c1"># pol, freq, ew, ra</span>

        <span class="c1"># Create the output container</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">FormedBeamHAEW</span><span class="p">(</span>
            <span class="n">object_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;object_id&quot;</span><span class="p">],</span>
            <span class="n">ha</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">nha</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>
            <span class="n">axes_from</span><span class="o">=</span><span class="n">hvis</span><span class="p">,</span>
            <span class="n">attrs_from</span><span class="o">=</span><span class="n">hvis</span><span class="p">,</span>
            <span class="n">distributed</span><span class="o">=</span><span class="n">hvis</span><span class="o">.</span><span class="n">distributed</span><span class="p">,</span>
            <span class="n">comm</span><span class="o">=</span><span class="n">hvis</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;redshift&quot;</span> <span class="ow">in</span> <span class="n">hvis</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;redshift&quot;</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">redshift</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">hvis</span><span class="o">.</span><span class="n">redshift</span><span class="p">[:]</span>

        <span class="n">out</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="s2">&quot;ra&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">src_ra</span>
        <span class="n">out</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="s2">&quot;dec&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">src_dec</span>

        <span class="n">out</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Dereference output datasets</span>
        <span class="n">ofb</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">beam</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">ofb</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">owe</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">owe</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">oha</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">ha</span><span class="p">[:]</span>
        <span class="n">oha</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Loop over sources and fringestop</span>
        <span class="k">for</span> <span class="n">ss</span><span class="p">,</span> <span class="p">(</span><span class="n">idec</span><span class="p">,</span> <span class="n">sdec</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">nearest_dec</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">src_dec</span><span class="p">))):</span>
            <span class="n">in_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">valid</span><span class="p">[</span><span class="n">ss</span><span class="p">])</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">in_range</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">valid_src</span><span class="p">[</span><span class="n">ss</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="n">cos_dec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">dec</span><span class="p">[</span><span class="n">idec</span><span class="p">]))</span>

            <span class="n">isort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">ha_arr</span><span class="p">[</span><span class="n">ss</span><span class="p">,</span> <span class="n">in_range</span><span class="p">])</span>
            <span class="n">in_range</span> <span class="o">=</span> <span class="n">in_range</span><span class="p">[</span><span class="n">isort</span><span class="p">]</span>

            <span class="n">islcs</span> <span class="o">=</span> <span class="n">find_contiguous_slices</span><span class="p">(</span><span class="n">in_range</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">islc</span> <span class="ow">in</span> <span class="n">islcs</span><span class="p">:</span>
                <span class="n">svis</span> <span class="o">=</span> <span class="n">vis</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">idec</span><span class="p">,</span> <span class="n">islc</span><span class="p">]</span>  <span class="c1"># pol, freq, ew, ha</span>
                <span class="n">sweight</span> <span class="o">=</span> <span class="n">weight</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">islc</span><span class="p">]</span>

                <span class="n">nsample</span> <span class="o">=</span> <span class="n">svis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">oslc</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="n">nsample</span><span class="p">)</span>
                <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="n">nsample</span>

                <span class="n">oha</span><span class="p">[</span><span class="n">ss</span><span class="p">,</span> <span class="n">oslc</span><span class="p">]</span> <span class="o">=</span> <span class="n">ha_arr</span><span class="p">[</span><span class="n">ss</span><span class="p">,</span> <span class="n">islc</span><span class="p">]</span>
                <span class="n">ha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">ha_arr</span><span class="p">[</span><span class="n">ss</span><span class="p">,</span> <span class="n">islc</span><span class="p">])</span>

                <span class="c1"># Loop over local frequencies and fringestop</span>
                <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">svis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">owe</span><span class="p">[</span><span class="n">ss</span><span class="p">,</span> <span class="p">:,</span> <span class="n">ff</span><span class="p">,</span> <span class="p">:,</span> <span class="n">oslc</span><span class="p">]</span> <span class="o">=</span> <span class="n">sweight</span><span class="p">[:,</span> <span class="n">ff</span><span class="p">]</span>

                    <span class="c1"># Calculate the phase</span>
                    <span class="n">phi</span> <span class="o">=</span> <span class="n">interferometry</span><span class="o">.</span><span class="n">fringestop_phase</span><span class="p">(</span>
                        <span class="n">ha</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span> <span class="n">sdec</span><span class="p">,</span> <span class="n">u</span><span class="p">[</span><span class="n">ff</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span>
                    <span class="p">)</span>

                    <span class="c1"># If the container has already been fringestopped,</span>
                    <span class="c1"># then we need to remove that contribution from the phase</span>
                    <span class="k">if</span> <span class="n">fringestopped</span><span class="p">:</span>
                        <span class="n">omega</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">ew</span> <span class="o">*</span> <span class="n">cos_dec</span> <span class="o">/</span> <span class="n">lmbda</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span>
                        <span class="n">phi</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                            <span class="o">-</span><span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">omega</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">ra_rad</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">islc</span><span class="p">]</span>
                        <span class="p">)</span>

                    <span class="n">ofb</span><span class="p">[</span><span class="n">ss</span><span class="p">,</span> <span class="p">:,</span> <span class="n">ff</span><span class="p">,</span> <span class="p">:,</span> <span class="n">oslc</span><span class="p">]</span> <span class="o">=</span> <span class="n">svis</span><span class="p">[:,</span> <span class="n">ff</span><span class="p">]</span> <span class="o">*</span> <span class="n">phi</span>

        <span class="k">return</span> <span class="n">out</span></div>
</div>



<div class="viewcode-block" id="FitBeamFormed">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.FitBeamFormed">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FitBeamFormed</span><span class="p">(</span><span class="n">BeamFormExternalMixin</span><span class="p">,</span> <span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fit beamformed visibilities as a function of hour angle to a primary beam model.</span>

<span class="sd">    Must provide a GridBeam object in celestial coordinates as argument to setup.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    weight : &quot;uniform&quot; or &quot;inverse_variance&quot;</span>
<span class="sd">        How to weight different hour angles during the fit.</span>
<span class="sd">    max_ha : float</span>
<span class="sd">        Only consider hour angles less than this value in degrees.</span>
<span class="sd">        If not provided, then will include all hour angles in the</span>
<span class="sd">        input container.</span>
<span class="sd">    epsilon : float</span>
<span class="sd">        Regularisation used during the fit.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">weight</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">enum</span><span class="p">([</span><span class="s2">&quot;uniform&quot;</span><span class="p">,</span> <span class="s2">&quot;inverse_variance&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;uniform&quot;</span><span class="p">)</span>
    <span class="n">max_ha</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">min_num_background</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">min_frac_beam</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.50</span><span class="p">)</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0e-10</span><span class="p">)</span>

<div class="viewcode-block" id="FitBeamFormed.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.FitBeamFormed.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fit a model to the beamformed visibilites along the hour angle axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : FormedBeamHA or FormedBeamHAEW</span>
<span class="sd">            Visibilities beamformed to the location of sources in a catalog.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : FitFormedBeam or FitFormedBeamEW</span>
<span class="sd">            Best-fit parameters describing the hour-angle dependence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">container_lookup</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">containers</span><span class="o">.</span><span class="n">FormedBeamHA</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">FitFormedBeam</span><span class="p">,</span>
            <span class="n">containers</span><span class="o">.</span><span class="n">FormedBeamHAEW</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">FitFormedBeamEW</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># Distrbitue over frequency</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Identify local frequencies</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freq_local</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">beam</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_bounds</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_beam_with_data</span><span class="p">()</span>

        <span class="c1"># Create output container</span>
        <span class="n">OutputContainer</span> <span class="o">=</span> <span class="n">container_lookup</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="vm">__class__</span><span class="p">]</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">OutputContainer</span><span class="p">(</span>
            <span class="n">axes_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">attrs_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">distributed</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">distributed</span><span class="p">,</span>
            <span class="n">comm</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">out</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Initialize everything to zero</span>
        <span class="k">for</span> <span class="n">dset</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">dset</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Copy over source coordinates</span>
        <span class="n">out</span><span class="o">.</span><span class="n">position</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">position</span><span class="p">[:]</span>
        <span class="k">if</span> <span class="s2">&quot;redshift&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;redshift&quot;</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">redshift</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">redshift</span><span class="p">[:]</span>

        <span class="c1"># Dereference datasets</span>
        <span class="n">beam</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">beam</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="n">obeam</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">beam</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">oweight</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="n">obkg</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">background</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">oweightbkg</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">weight_background</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">ocorr</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">corr_background_beam</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="c1"># Get source coordinates</span>
        <span class="n">src_dec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="s2">&quot;dec&quot;</span><span class="p">][:])</span>

        <span class="n">src_ha</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">ha</span><span class="p">[:]</span>
        <span class="n">max_nha</span> <span class="o">=</span> <span class="n">src_ha</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Loop over sources</span>
        <span class="k">for</span> <span class="n">ss</span><span class="p">,</span> <span class="n">sdec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">src_dec</span><span class="p">):</span>
            <span class="c1"># Ignore missing sources</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">weight</span><span class="p">[</span><span class="n">ss</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># Extract hour angle axis</span>
            <span class="n">nha</span> <span class="o">=</span> <span class="n">max_nha</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">src_ha</span><span class="p">[</span><span class="n">ss</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">))</span>
            <span class="n">slc</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nha</span><span class="p">)</span>
            <span class="n">sha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">src_ha</span><span class="p">[</span><span class="n">ss</span><span class="p">,</span> <span class="n">slc</span><span class="p">])</span>

            <span class="c1"># Loop over polarisation</span>
            <span class="k">for</span> <span class="n">pp</span><span class="p">,</span> <span class="n">pol</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">pol</span><span class="p">):</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">beam</span><span class="p">[</span><span class="n">ss</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">slc</span><span class="p">]</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">weight</span><span class="p">[</span><span class="n">ss</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">slc</span><span class="p">]</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
                    <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="mf">0.0</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_ha</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">flag_ha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sha</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_ha</span><span class="p">)</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">flag_ha</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">flag_ha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nha</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

                <span class="c1"># Get the template as a function of hour angle</span>
                <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_template</span><span class="p">(</span><span class="n">pol</span><span class="p">,</span> <span class="n">sdec</span><span class="p">,</span> <span class="n">sha</span><span class="p">)</span>
                <span class="k">if</span> <span class="s2">&quot;ew&quot;</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
                    <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

                <span class="c1"># Identify frequencies/baselines that are missing a significant fraction of samples</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="n">offsrc</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.05</span>
                <span class="n">flag_background</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">f</span> <span class="o">*</span> <span class="n">offsrc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_num_background</span>
                <span class="n">flag_beam</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">f</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="o">*</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flag_ha</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
                <span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_frac_beam</span>

                <span class="n">flag</span> <span class="o">=</span> <span class="n">flag_background</span> <span class="o">&amp;</span> <span class="n">flag_beam</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">flag</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Construct the inverse parameter covariance matrix</span>
                <span class="n">XT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">XT</span><span class="p">,</span> <span class="n">w</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span>

                <span class="c1"># Solve for the parameters and their covariance</span>
                <span class="n">proj_wb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="n">XT</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">b</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>

                <span class="n">coeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">proj_wb</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

                <span class="c1"># Save to output container</span>
                <span class="n">obeam</span><span class="p">[</span><span class="n">ss</span><span class="p">,</span> <span class="n">pp</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">obkg</span><span class="p">[</span><span class="n">ss</span><span class="p">,</span> <span class="n">pp</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
                    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">XT</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

                <span class="n">oweight</span><span class="p">[</span><span class="n">ss</span><span class="p">,</span> <span class="n">pp</span><span class="p">]</span> <span class="o">=</span> <span class="n">flag</span> <span class="o">*</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">cov</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">oweightbkg</span><span class="p">[</span><span class="n">ss</span><span class="p">,</span> <span class="n">pp</span><span class="p">]</span> <span class="o">=</span> <span class="n">flag</span> <span class="o">*</span> <span class="n">invert_no_zero</span><span class="p">(</span><span class="n">cov</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

                <span class="n">ocorr</span><span class="p">[</span><span class="n">ss</span><span class="p">,</span> <span class="n">pp</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                    <span class="n">oweight</span><span class="p">[</span><span class="n">ss</span><span class="p">,</span> <span class="n">pp</span><span class="p">]</span> <span class="o">*</span> <span class="n">oweightbkg</span><span class="p">[</span><span class="n">ss</span><span class="p">,</span> <span class="n">pp</span><span class="p">]</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="FitBeamFormed.get_template">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.FitBeamFormed.get_template">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_template</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">ha</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the template as a function of hour angle to fit to transit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pol : str</span>
<span class="sd">            String specifying the polarisation,</span>
<span class="sd">            either &#39;XX&#39;, &#39;XY&#39;, &#39;YX&#39;, or &#39;YY&#39;.</span>
<span class="sd">        dec : float</span>
<span class="sd">            The declination of the source in radians.</span>
<span class="sd">        ha : np.ndarray[nha,]</span>
<span class="sd">            The hour angle of the source in radians.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        t : np.ndarray[nha, 2]</span>
<span class="sd">            Template for the source transit as a function of hour angle.</span>
<span class="sd">            First column is entirely 1 and corresponds to an overall additive</span>
<span class="sd">            offset. Second column is the primary beam model versus hour angle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">freq_local</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">ha</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">t</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beamfunc</span><span class="p">(</span><span class="n">pol</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">ha</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">t</span></div>
</div>



<div class="viewcode-block" id="HealpixBeamForm">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.HealpixBeamForm">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">HealpixBeamForm</span><span class="p">(</span><span class="n">tasklib</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ContainerTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Beamform by extracting the pixel containing each source form a Healpix map.</span>

<span class="sd">    Unless it has an explicit `epoch` attribute, the Healpix map is assumed to be in the</span>
<span class="sd">    same coordinate epoch as the catalog. If it does, the input catalog is assumed to be</span>
<span class="sd">    in ICRS and then is precessed to the CIRS coordinates in the epoch of the map.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    fwhm : float</span>
<span class="sd">        Smooth the map with a Gaussian with the specified FWHM in degrees. If `None`</span>
<span class="sd">        (default), leave at native map resolution. This will modify the input map in</span>
<span class="sd">        place.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">fwhm</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

<div class="viewcode-block" id="HealpixBeamForm.setup">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.HealpixBeamForm.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hpmap</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">Map</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the map to extract beams from at each catalog location.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hpmap</span>
<span class="sd">            The Healpix map to extract the sources from.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map</span> <span class="o">=</span> <span class="n">hpmap</span>
        <span class="n">mv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">map</span><span class="p">[:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Smoothing input Healpix map.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">lfi</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">mv</span><span class="o">.</span><span class="n">enumerate</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">pi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">mv</span><span class="p">[</span><span class="n">lfi</span><span class="p">,</span> <span class="n">pi</span><span class="p">]</span> <span class="o">=</span> <span class="n">healpy</span><span class="o">.</span><span class="n">smoothing</span><span class="p">(</span>
                    <span class="n">mv</span><span class="p">[</span><span class="n">lfi</span><span class="p">,</span> <span class="n">pi</span><span class="p">],</span> <span class="n">fwhm</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fwhm</span><span class="p">),</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span></div>


<div class="viewcode-block" id="HealpixBeamForm.process">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.HealpixBeamForm.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">catalog</span><span class="p">:</span> <span class="n">containers</span><span class="o">.</span><span class="n">SourceCatalog</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">FormedBeam</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract sources from a ringmap.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        catalog</span>
<span class="sd">            The catalog to extract sources from.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        formed_beam</span>
<span class="sd">            The source spectra.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;position&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">catalog</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input is missing a position table.&quot;</span><span class="p">)</span>

        <span class="c1"># Container to hold the formed beams</span>
        <span class="n">formed_beam</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">FormedBeam</span><span class="p">(</span>
            <span class="n">object_id</span><span class="o">=</span><span class="n">catalog</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;object_id&quot;</span><span class="p">],</span>
            <span class="n">axes_from</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">,</span>
            <span class="n">distributed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Initialize container to zeros.</span>
        <span class="n">formed_beam</span><span class="o">.</span><span class="n">beam</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">formed_beam</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Copy catalog information</span>
        <span class="n">formed_beam</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][:]</span>
        <span class="k">if</span> <span class="s2">&quot;redshift&quot;</span> <span class="ow">in</span> <span class="n">catalog</span><span class="p">:</span>
            <span class="n">formed_beam</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;redshift&quot;</span><span class="p">)</span>
            <span class="n">formed_beam</span><span class="p">[</span><span class="s2">&quot;redshift&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;redshift&quot;</span><span class="p">][:]</span>

        <span class="c1"># Get the source positions at the epoch of the input map</span>
        <span class="n">epoch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;epoch&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">epoch</span> <span class="o">=</span> <span class="n">ctime</span><span class="o">.</span><span class="n">ensure_unix</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span> <span class="k">if</span> <span class="n">epoch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">epoch</span><span class="p">:</span>
            <span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span> <span class="o">=</span> <span class="n">icrs_to_cirs</span><span class="p">(</span>
                <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;ra&quot;</span><span class="p">],</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;dec&quot;</span><span class="p">],</span> <span class="n">epoch</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Input map has no epoch set, assuming that it matches the catalog.&quot;</span>
            <span class="p">)</span>
            <span class="n">src_ra</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;ra&quot;</span><span class="p">]</span>
            <span class="n">src_dec</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;dec&quot;</span><span class="p">]</span>

        <span class="c1"># Use Healpix to get the pixels containing the sources</span>
        <span class="n">pix_ind</span> <span class="o">=</span> <span class="n">healpy</span><span class="o">.</span><span class="n">ang2pix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">nside</span><span class="p">,</span> <span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span><span class="p">,</span> <span class="n">lonlat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Ensure containers are distributed in frequency</span>
        <span class="n">formed_beam</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">formed_beam</span><span class="o">.</span><span class="n">beam</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">map</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">pix_ind</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Set to some non-zero value as the Map container doesn&#39;t have a weight</span>
        <span class="n">formed_beam</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="k">return</span> <span class="n">formed_beam</span></div>
</div>



<div class="viewcode-block" id="icrs_to_cirs">
<a class="viewcode-back" href="../../../_autosummary/draco.analysis.beamform.html#draco.analysis.beamform.icrs_to_cirs">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">icrs_to_cirs</span><span class="p">(</span><span class="n">ra</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">epoch</span><span class="p">,</span> <span class="n">apparent</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a set of positions from ICRS to CIRS at a given data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ra, dec : float or np.ndarray</span>
<span class="sd">        Positions of source in ICRS coordinates including an optional</span>
<span class="sd">        redshift position.</span>
<span class="sd">    epoch : time_like</span>
<span class="sd">        Time to convert the positions to. Can be any type convertible to a</span>
<span class="sd">        time using `caput.astro.time.ensure_unix`.</span>
<span class="sd">    apparent : bool</span>
<span class="sd">        Calculate the apparent position (includes abberation and deflection).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ra_cirs, dec_cirs : float or np.ndarray</span>
<span class="sd">        Arrays of the positions in *CIRS* coordiantes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">positions</span> <span class="o">=</span> <span class="n">Star</span><span class="p">(</span><span class="n">ra</span><span class="o">=</span><span class="n">Angle</span><span class="p">(</span><span class="n">degrees</span><span class="o">=</span><span class="n">ra</span><span class="p">),</span> <span class="n">dec</span><span class="o">=</span><span class="n">Angle</span><span class="p">(</span><span class="n">degrees</span><span class="o">=</span><span class="n">dec</span><span class="p">))</span>

    <span class="n">epoch</span> <span class="o">=</span> <span class="n">skf</span><span class="o">.</span><span class="n">unix_to_skyfield_time</span><span class="p">(</span><span class="n">ctime</span><span class="o">.</span><span class="n">ensure_unix</span><span class="p">(</span><span class="n">epoch</span><span class="p">))</span>

    <span class="n">earth</span> <span class="o">=</span> <span class="n">skf</span><span class="o">.</span><span class="n">skyfield_wrapper</span><span class="o">.</span><span class="n">ephemeris</span><span class="p">[</span><span class="s2">&quot;earth&quot;</span><span class="p">]</span>
    <span class="n">positions</span> <span class="o">=</span> <span class="n">earth</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">apparent</span><span class="p">:</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">positions</span><span class="o">.</span><span class="n">apparent</span><span class="p">()</span>

    <span class="n">ra_cirs</span><span class="p">,</span> <span class="n">dec_cirs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">positions</span><span class="o">.</span><span class="n">cirs_radec</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ra_cirs</span><span class="o">.</span><span class="n">_degrees</span><span class="p">,</span> <span class="n">dec_cirs</span><span class="o">.</span><span class="n">_degrees</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016, Richard Shaw.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>